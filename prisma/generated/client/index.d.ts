
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Developer
 * 
 */
export type Developer = $Result.DefaultSelection<Prisma.$DeveloperPayload>
/**
 * Model Job
 * 
 */
export type Job = $Result.DefaultSelection<Prisma.$JobPayload>
/**
 * Model CurriculumVitae
 * 
 */
export type CurriculumVitae = $Result.DefaultSelection<Prisma.$CurriculumVitaePayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model PreSelectionTest
 * 
 */
export type PreSelectionTest = $Result.DefaultSelection<Prisma.$PreSelectionTestPayload>
/**
 * Model SelectionTestQuestion
 * 
 */
export type SelectionTestQuestion = $Result.DefaultSelection<Prisma.$SelectionTestQuestionPayload>
/**
 * Model JobApplication
 * 
 */
export type JobApplication = $Result.DefaultSelection<Prisma.$JobApplicationPayload>
/**
 * Model Interview
 * 
 */
export type Interview = $Result.DefaultSelection<Prisma.$InterviewPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Assessment
 * 
 */
export type Assessment = $Result.DefaultSelection<Prisma.$AssessmentPayload>
/**
 * Model UserAssessment
 * 
 */
export type UserAssessment = $Result.DefaultSelection<Prisma.$UserAssessmentPayload>
/**
 * Model AssessmentQuestion
 * 
 */
export type AssessmentQuestion = $Result.DefaultSelection<Prisma.$AssessmentQuestionPayload>
/**
 * Model Certificate
 * 
 */
export type Certificate = $Result.DefaultSelection<Prisma.$CertificatePayload>
/**
 * Model UserSubscription
 * 
 */
export type UserSubscription = $Result.DefaultSelection<Prisma.$UserSubscriptionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Gender: {
  female: 'female',
  male: 'male'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const LastEdu: {
  highSchoolDiploma: 'highSchoolDiploma',
  bachelor: 'bachelor',
  diploma: 'diploma',
  doctoral: 'doctoral',
  master: 'master'
};

export type LastEdu = (typeof LastEdu)[keyof typeof LastEdu]


export const JobCategory: {
  accountancy: 'accountancy',
  sales: 'sales',
  marketing: 'marketing',
  engineering: 'engineering',
  construction: 'construction',
  tourism: 'tourism',
  administration: 'administration',
  manufacture: 'manufacture',
  informatics: 'informatics'
};

export type JobCategory = (typeof JobCategory)[keyof typeof JobCategory]


export const SubscriptionCategory: {
  standard: 'standard',
  professional: 'professional'
};

export type SubscriptionCategory = (typeof SubscriptionCategory)[keyof typeof SubscriptionCategory]


export const JobApplicationStatus: {
  rejected: 'rejected',
  accepted: 'accepted',
  processed: 'processed',
  interviewed: 'interviewed'
};

export type JobApplicationStatus = (typeof JobApplicationStatus)[keyof typeof JobApplicationStatus]


export const TransactionStatus: {
  pending: 'pending',
  settlement: 'settlement',
  cancel: 'cancel'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const UserAssessmentStatus: {
  failed: 'failed',
  passed: 'passed'
};

export type UserAssessmentStatus = (typeof UserAssessmentStatus)[keyof typeof UserAssessmentStatus]

}

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type LastEdu = $Enums.LastEdu

export const LastEdu: typeof $Enums.LastEdu

export type JobCategory = $Enums.JobCategory

export const JobCategory: typeof $Enums.JobCategory

export type SubscriptionCategory = $Enums.SubscriptionCategory

export const SubscriptionCategory: typeof $Enums.SubscriptionCategory

export type JobApplicationStatus = $Enums.JobApplicationStatus

export const JobApplicationStatus: typeof $Enums.JobApplicationStatus

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type UserAssessmentStatus = $Enums.UserAssessmentStatus

export const UserAssessmentStatus: typeof $Enums.UserAssessmentStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.developer`: Exposes CRUD operations for the **Developer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Developers
    * const developers = await prisma.developer.findMany()
    * ```
    */
  get developer(): Prisma.DeveloperDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job`: Exposes CRUD operations for the **Job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.job.findMany()
    * ```
    */
  get job(): Prisma.JobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.curriculumVitae`: Exposes CRUD operations for the **CurriculumVitae** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CurriculumVitaes
    * const curriculumVitaes = await prisma.curriculumVitae.findMany()
    * ```
    */
  get curriculumVitae(): Prisma.CurriculumVitaeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.preSelectionTest`: Exposes CRUD operations for the **PreSelectionTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PreSelectionTests
    * const preSelectionTests = await prisma.preSelectionTest.findMany()
    * ```
    */
  get preSelectionTest(): Prisma.PreSelectionTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.selectionTestQuestion`: Exposes CRUD operations for the **SelectionTestQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SelectionTestQuestions
    * const selectionTestQuestions = await prisma.selectionTestQuestion.findMany()
    * ```
    */
  get selectionTestQuestion(): Prisma.SelectionTestQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobApplication`: Exposes CRUD operations for the **JobApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobApplications
    * const jobApplications = await prisma.jobApplication.findMany()
    * ```
    */
  get jobApplication(): Prisma.JobApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interview`: Exposes CRUD operations for the **Interview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interviews
    * const interviews = await prisma.interview.findMany()
    * ```
    */
  get interview(): Prisma.InterviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assessment`: Exposes CRUD operations for the **Assessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assessments
    * const assessments = await prisma.assessment.findMany()
    * ```
    */
  get assessment(): Prisma.AssessmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAssessment`: Exposes CRUD operations for the **UserAssessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAssessments
    * const userAssessments = await prisma.userAssessment.findMany()
    * ```
    */
  get userAssessment(): Prisma.UserAssessmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assessmentQuestion`: Exposes CRUD operations for the **AssessmentQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssessmentQuestions
    * const assessmentQuestions = await prisma.assessmentQuestion.findMany()
    * ```
    */
  get assessmentQuestion(): Prisma.AssessmentQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certificate`: Exposes CRUD operations for the **Certificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificate.findMany()
    * ```
    */
  get certificate(): Prisma.CertificateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSubscription`: Exposes CRUD operations for the **UserSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSubscriptions
    * const userSubscriptions = await prisma.userSubscription.findMany()
    * ```
    */
  get userSubscription(): Prisma.UserSubscriptionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.2.1
   * Query Engine version: 4123509d24aa4dede1e864b46351bf2790323b69
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Admin: 'Admin',
    Developer: 'Developer',
    Job: 'Job',
    CurriculumVitae: 'CurriculumVitae',
    Location: 'Location',
    Subscription: 'Subscription',
    PreSelectionTest: 'PreSelectionTest',
    SelectionTestQuestion: 'SelectionTestQuestion',
    JobApplication: 'JobApplication',
    Interview: 'Interview',
    Review: 'Review',
    Transaction: 'Transaction',
    Assessment: 'Assessment',
    UserAssessment: 'UserAssessment',
    AssessmentQuestion: 'AssessmentQuestion',
    Certificate: 'Certificate',
    UserSubscription: 'UserSubscription'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "admin" | "developer" | "job" | "curriculumVitae" | "location" | "subscription" | "preSelectionTest" | "selectionTestQuestion" | "jobApplication" | "interview" | "review" | "transaction" | "assessment" | "userAssessment" | "assessmentQuestion" | "certificate" | "userSubscription"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Developer: {
        payload: Prisma.$DeveloperPayload<ExtArgs>
        fields: Prisma.DeveloperFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeveloperFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeveloperFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload>
          }
          findFirst: {
            args: Prisma.DeveloperFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeveloperFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload>
          }
          findMany: {
            args: Prisma.DeveloperFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload>[]
          }
          create: {
            args: Prisma.DeveloperCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload>
          }
          createMany: {
            args: Prisma.DeveloperCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeveloperCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload>[]
          }
          delete: {
            args: Prisma.DeveloperDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload>
          }
          update: {
            args: Prisma.DeveloperUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload>
          }
          deleteMany: {
            args: Prisma.DeveloperDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeveloperUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeveloperUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload>[]
          }
          upsert: {
            args: Prisma.DeveloperUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeveloperPayload>
          }
          aggregate: {
            args: Prisma.DeveloperAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeveloper>
          }
          groupBy: {
            args: Prisma.DeveloperGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeveloperGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeveloperCountArgs<ExtArgs>
            result: $Utils.Optional<DeveloperCountAggregateOutputType> | number
          }
        }
      }
      Job: {
        payload: Prisma.$JobPayload<ExtArgs>
        fields: Prisma.JobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findFirst: {
            args: Prisma.JobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findMany: {
            args: Prisma.JobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          create: {
            args: Prisma.JobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          createMany: {
            args: Prisma.JobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          delete: {
            args: Prisma.JobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          update: {
            args: Prisma.JobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          deleteMany: {
            args: Prisma.JobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          upsert: {
            args: Prisma.JobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          aggregate: {
            args: Prisma.JobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob>
          }
          groupBy: {
            args: Prisma.JobGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobCountArgs<ExtArgs>
            result: $Utils.Optional<JobCountAggregateOutputType> | number
          }
        }
      }
      CurriculumVitae: {
        payload: Prisma.$CurriculumVitaePayload<ExtArgs>
        fields: Prisma.CurriculumVitaeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurriculumVitaeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumVitaePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurriculumVitaeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumVitaePayload>
          }
          findFirst: {
            args: Prisma.CurriculumVitaeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumVitaePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurriculumVitaeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumVitaePayload>
          }
          findMany: {
            args: Prisma.CurriculumVitaeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumVitaePayload>[]
          }
          create: {
            args: Prisma.CurriculumVitaeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumVitaePayload>
          }
          createMany: {
            args: Prisma.CurriculumVitaeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CurriculumVitaeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumVitaePayload>[]
          }
          delete: {
            args: Prisma.CurriculumVitaeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumVitaePayload>
          }
          update: {
            args: Prisma.CurriculumVitaeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumVitaePayload>
          }
          deleteMany: {
            args: Prisma.CurriculumVitaeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurriculumVitaeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CurriculumVitaeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumVitaePayload>[]
          }
          upsert: {
            args: Prisma.CurriculumVitaeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumVitaePayload>
          }
          aggregate: {
            args: Prisma.CurriculumVitaeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurriculumVitae>
          }
          groupBy: {
            args: Prisma.CurriculumVitaeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurriculumVitaeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurriculumVitaeCountArgs<ExtArgs>
            result: $Utils.Optional<CurriculumVitaeCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      PreSelectionTest: {
        payload: Prisma.$PreSelectionTestPayload<ExtArgs>
        fields: Prisma.PreSelectionTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PreSelectionTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreSelectionTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PreSelectionTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreSelectionTestPayload>
          }
          findFirst: {
            args: Prisma.PreSelectionTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreSelectionTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PreSelectionTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreSelectionTestPayload>
          }
          findMany: {
            args: Prisma.PreSelectionTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreSelectionTestPayload>[]
          }
          create: {
            args: Prisma.PreSelectionTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreSelectionTestPayload>
          }
          createMany: {
            args: Prisma.PreSelectionTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PreSelectionTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreSelectionTestPayload>[]
          }
          delete: {
            args: Prisma.PreSelectionTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreSelectionTestPayload>
          }
          update: {
            args: Prisma.PreSelectionTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreSelectionTestPayload>
          }
          deleteMany: {
            args: Prisma.PreSelectionTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PreSelectionTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PreSelectionTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreSelectionTestPayload>[]
          }
          upsert: {
            args: Prisma.PreSelectionTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreSelectionTestPayload>
          }
          aggregate: {
            args: Prisma.PreSelectionTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePreSelectionTest>
          }
          groupBy: {
            args: Prisma.PreSelectionTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<PreSelectionTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.PreSelectionTestCountArgs<ExtArgs>
            result: $Utils.Optional<PreSelectionTestCountAggregateOutputType> | number
          }
        }
      }
      SelectionTestQuestion: {
        payload: Prisma.$SelectionTestQuestionPayload<ExtArgs>
        fields: Prisma.SelectionTestQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SelectionTestQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionTestQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SelectionTestQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionTestQuestionPayload>
          }
          findFirst: {
            args: Prisma.SelectionTestQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionTestQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SelectionTestQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionTestQuestionPayload>
          }
          findMany: {
            args: Prisma.SelectionTestQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionTestQuestionPayload>[]
          }
          create: {
            args: Prisma.SelectionTestQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionTestQuestionPayload>
          }
          createMany: {
            args: Prisma.SelectionTestQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SelectionTestQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionTestQuestionPayload>[]
          }
          delete: {
            args: Prisma.SelectionTestQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionTestQuestionPayload>
          }
          update: {
            args: Prisma.SelectionTestQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionTestQuestionPayload>
          }
          deleteMany: {
            args: Prisma.SelectionTestQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SelectionTestQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SelectionTestQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionTestQuestionPayload>[]
          }
          upsert: {
            args: Prisma.SelectionTestQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelectionTestQuestionPayload>
          }
          aggregate: {
            args: Prisma.SelectionTestQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSelectionTestQuestion>
          }
          groupBy: {
            args: Prisma.SelectionTestQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SelectionTestQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SelectionTestQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<SelectionTestQuestionCountAggregateOutputType> | number
          }
        }
      }
      JobApplication: {
        payload: Prisma.$JobApplicationPayload<ExtArgs>
        fields: Prisma.JobApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          findFirst: {
            args: Prisma.JobApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          findMany: {
            args: Prisma.JobApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>[]
          }
          create: {
            args: Prisma.JobApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          createMany: {
            args: Prisma.JobApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>[]
          }
          delete: {
            args: Prisma.JobApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          update: {
            args: Prisma.JobApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          deleteMany: {
            args: Prisma.JobApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobApplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>[]
          }
          upsert: {
            args: Prisma.JobApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          aggregate: {
            args: Prisma.JobApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobApplication>
          }
          groupBy: {
            args: Prisma.JobApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<JobApplicationCountAggregateOutputType> | number
          }
        }
      }
      Interview: {
        payload: Prisma.$InterviewPayload<ExtArgs>
        fields: Prisma.InterviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          findFirst: {
            args: Prisma.InterviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          findMany: {
            args: Prisma.InterviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>[]
          }
          create: {
            args: Prisma.InterviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          createMany: {
            args: Prisma.InterviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>[]
          }
          delete: {
            args: Prisma.InterviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          update: {
            args: Prisma.InterviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          deleteMany: {
            args: Prisma.InterviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>[]
          }
          upsert: {
            args: Prisma.InterviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          aggregate: {
            args: Prisma.InterviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterview>
          }
          groupBy: {
            args: Prisma.InterviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterviewCountArgs<ExtArgs>
            result: $Utils.Optional<InterviewCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Assessment: {
        payload: Prisma.$AssessmentPayload<ExtArgs>
        fields: Prisma.AssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          findFirst: {
            args: Prisma.AssessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          findMany: {
            args: Prisma.AssessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>[]
          }
          create: {
            args: Prisma.AssessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          createMany: {
            args: Prisma.AssessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssessmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>[]
          }
          delete: {
            args: Prisma.AssessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          update: {
            args: Prisma.AssessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          deleteMany: {
            args: Prisma.AssessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssessmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>[]
          }
          upsert: {
            args: Prisma.AssessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          aggregate: {
            args: Prisma.AssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssessment>
          }
          groupBy: {
            args: Prisma.AssessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssessmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssessmentCountAggregateOutputType> | number
          }
        }
      }
      UserAssessment: {
        payload: Prisma.$UserAssessmentPayload<ExtArgs>
        fields: Prisma.UserAssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAssessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAssessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentPayload>
          }
          findFirst: {
            args: Prisma.UserAssessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAssessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentPayload>
          }
          findMany: {
            args: Prisma.UserAssessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentPayload>[]
          }
          create: {
            args: Prisma.UserAssessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentPayload>
          }
          createMany: {
            args: Prisma.UserAssessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAssessmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentPayload>[]
          }
          delete: {
            args: Prisma.UserAssessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentPayload>
          }
          update: {
            args: Prisma.UserAssessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentPayload>
          }
          deleteMany: {
            args: Prisma.UserAssessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAssessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAssessmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentPayload>[]
          }
          upsert: {
            args: Prisma.UserAssessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAssessmentPayload>
          }
          aggregate: {
            args: Prisma.UserAssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAssessment>
          }
          groupBy: {
            args: Prisma.UserAssessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAssessmentCountArgs<ExtArgs>
            result: $Utils.Optional<UserAssessmentCountAggregateOutputType> | number
          }
        }
      }
      AssessmentQuestion: {
        payload: Prisma.$AssessmentQuestionPayload<ExtArgs>
        fields: Prisma.AssessmentQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssessmentQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssessmentQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>
          }
          findFirst: {
            args: Prisma.AssessmentQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssessmentQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>
          }
          findMany: {
            args: Prisma.AssessmentQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>[]
          }
          create: {
            args: Prisma.AssessmentQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>
          }
          createMany: {
            args: Prisma.AssessmentQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssessmentQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>[]
          }
          delete: {
            args: Prisma.AssessmentQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>
          }
          update: {
            args: Prisma.AssessmentQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>
          }
          deleteMany: {
            args: Prisma.AssessmentQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssessmentQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssessmentQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>[]
          }
          upsert: {
            args: Prisma.AssessmentQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>
          }
          aggregate: {
            args: Prisma.AssessmentQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssessmentQuestion>
          }
          groupBy: {
            args: Prisma.AssessmentQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssessmentQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssessmentQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<AssessmentQuestionCountAggregateOutputType> | number
          }
        }
      }
      Certificate: {
        payload: Prisma.$CertificatePayload<ExtArgs>
        fields: Prisma.CertificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findFirst: {
            args: Prisma.CertificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findMany: {
            args: Prisma.CertificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          create: {
            args: Prisma.CertificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          createMany: {
            args: Prisma.CertificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          delete: {
            args: Prisma.CertificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          update: {
            args: Prisma.CertificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          deleteMany: {
            args: Prisma.CertificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CertificateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          upsert: {
            args: Prisma.CertificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          aggregate: {
            args: Prisma.CertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificate>
          }
          groupBy: {
            args: Prisma.CertificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificateCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateCountAggregateOutputType> | number
          }
        }
      }
      UserSubscription: {
        payload: Prisma.$UserSubscriptionPayload<ExtArgs>
        fields: Prisma.UserSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.UserSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          findMany: {
            args: Prisma.UserSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          create: {
            args: Prisma.UserSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          createMany: {
            args: Prisma.UserSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.UserSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          update: {
            args: Prisma.UserSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.UserSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.UserSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.UserSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSubscription>
          }
          groupBy: {
            args: Prisma.UserSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSubscriptionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    admin?: AdminOmit
    developer?: DeveloperOmit
    job?: JobOmit
    curriculumVitae?: CurriculumVitaeOmit
    location?: LocationOmit
    subscription?: SubscriptionOmit
    preSelectionTest?: PreSelectionTestOmit
    selectionTestQuestion?: SelectionTestQuestionOmit
    jobApplication?: JobApplicationOmit
    interview?: InterviewOmit
    review?: ReviewOmit
    transaction?: TransactionOmit
    assessment?: AssessmentOmit
    userAssessment?: UserAssessmentOmit
    assessmentQuestion?: AssessmentQuestionOmit
    certificate?: CertificateOmit
    userSubscription?: UserSubscriptionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    CurriculumVitae: number
    JobApplication: number
    Review: number
    Transaction: number
    UserAssessment: number
    UserSubscription: number
    Interview: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CurriculumVitae?: boolean | UserCountOutputTypeCountCurriculumVitaeArgs
    JobApplication?: boolean | UserCountOutputTypeCountJobApplicationArgs
    Review?: boolean | UserCountOutputTypeCountReviewArgs
    Transaction?: boolean | UserCountOutputTypeCountTransactionArgs
    UserAssessment?: boolean | UserCountOutputTypeCountUserAssessmentArgs
    UserSubscription?: boolean | UserCountOutputTypeCountUserSubscriptionArgs
    Interview?: boolean | UserCountOutputTypeCountInterviewArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCurriculumVitaeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurriculumVitaeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJobApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAssessmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInterviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewWhereInput
  }


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    Job: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Job?: boolean | AdminCountOutputTypeCountJobArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }


  /**
   * Count Type JobCountOutputType
   */

  export type JobCountOutputType = {
    JobApplication: number
    PreSelectionTest: number
    Review: number
    Interview: number
  }

  export type JobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    JobApplication?: boolean | JobCountOutputTypeCountJobApplicationArgs
    PreSelectionTest?: boolean | JobCountOutputTypeCountPreSelectionTestArgs
    Review?: boolean | JobCountOutputTypeCountReviewArgs
    Interview?: boolean | JobCountOutputTypeCountInterviewArgs
  }

  // Custom InputTypes
  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCountOutputType
     */
    select?: JobCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountJobApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicationWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountPreSelectionTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreSelectionTestWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountInterviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    Job: number
    User: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Job?: boolean | LocationCountOutputTypeCountJobArgs
    User?: boolean | LocationCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    Transaction: number
    UserSubscription: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Transaction?: boolean | SubscriptionCountOutputTypeCountTransactionArgs
    UserSubscription?: boolean | SubscriptionCountOutputTypeCountUserSubscriptionArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountUserSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubscriptionWhereInput
  }


  /**
   * Count Type PreSelectionTestCountOutputType
   */

  export type PreSelectionTestCountOutputType = {
    SelectionTestQuestion: number
  }

  export type PreSelectionTestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SelectionTestQuestion?: boolean | PreSelectionTestCountOutputTypeCountSelectionTestQuestionArgs
  }

  // Custom InputTypes
  /**
   * PreSelectionTestCountOutputType without action
   */
  export type PreSelectionTestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreSelectionTestCountOutputType
     */
    select?: PreSelectionTestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PreSelectionTestCountOutputType without action
   */
  export type PreSelectionTestCountOutputTypeCountSelectionTestQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SelectionTestQuestionWhereInput
  }


  /**
   * Count Type AssessmentCountOutputType
   */

  export type AssessmentCountOutputType = {
    AssessmentQuestion: number
    UserAssessment: number
  }

  export type AssessmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AssessmentQuestion?: boolean | AssessmentCountOutputTypeCountAssessmentQuestionArgs
    UserAssessment?: boolean | AssessmentCountOutputTypeCountUserAssessmentArgs
  }

  // Custom InputTypes
  /**
   * AssessmentCountOutputType without action
   */
  export type AssessmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentCountOutputType
     */
    select?: AssessmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssessmentCountOutputType without action
   */
  export type AssessmentCountOutputTypeCountAssessmentQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentQuestionWhereInput
  }

  /**
   * AssessmentCountOutputType without action
   */
  export type AssessmentCountOutputTypeCountUserAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAssessmentWhereInput
  }


  /**
   * Count Type CertificateCountOutputType
   */

  export type CertificateCountOutputType = {
    UserAssessment: number
  }

  export type CertificateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserAssessment?: boolean | CertificateCountOutputTypeCountUserAssessmentArgs
  }

  // Custom InputTypes
  /**
   * CertificateCountOutputType without action
   */
  export type CertificateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateCountOutputType
     */
    select?: CertificateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CertificateCountOutputType without action
   */
  export type CertificateCountOutputTypeCountUserAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAssessmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    domicileId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    domicileId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    fullname: string | null
    email: string | null
    password: string | null
    isVerified: boolean | null
    avatar: string | null
    gender: $Enums.Gender | null
    dob: Date | null
    lastEdu: $Enums.LastEdu | null
    domicileId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    fullname: string | null
    email: string | null
    password: string | null
    isVerified: boolean | null
    avatar: string | null
    gender: $Enums.Gender | null
    dob: Date | null
    lastEdu: $Enums.LastEdu | null
    domicileId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    fullname: number
    email: number
    password: number
    isVerified: number
    avatar: number
    gender: number
    dob: number
    lastEdu: number
    domicileId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    domicileId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    domicileId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    fullname?: true
    email?: true
    password?: true
    isVerified?: true
    avatar?: true
    gender?: true
    dob?: true
    lastEdu?: true
    domicileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    fullname?: true
    email?: true
    password?: true
    isVerified?: true
    avatar?: true
    gender?: true
    dob?: true
    lastEdu?: true
    domicileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    fullname?: true
    email?: true
    password?: true
    isVerified?: true
    avatar?: true
    gender?: true
    dob?: true
    lastEdu?: true
    domicileId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    fullname: string | null
    email: string
    password: string
    isVerified: boolean
    avatar: string
    gender: $Enums.Gender | null
    dob: Date | null
    lastEdu: $Enums.LastEdu | null
    domicileId: number | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    fullname?: boolean
    email?: boolean
    password?: boolean
    isVerified?: boolean
    avatar?: boolean
    gender?: boolean
    dob?: boolean
    lastEdu?: boolean
    domicileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    CurriculumVitae?: boolean | User$CurriculumVitaeArgs<ExtArgs>
    JobApplication?: boolean | User$JobApplicationArgs<ExtArgs>
    Review?: boolean | User$ReviewArgs<ExtArgs>
    Transaction?: boolean | User$TransactionArgs<ExtArgs>
    location?: boolean | User$locationArgs<ExtArgs>
    UserAssessment?: boolean | User$UserAssessmentArgs<ExtArgs>
    UserSubscription?: boolean | User$UserSubscriptionArgs<ExtArgs>
    Interview?: boolean | User$InterviewArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    fullname?: boolean
    email?: boolean
    password?: boolean
    isVerified?: boolean
    avatar?: boolean
    gender?: boolean
    dob?: boolean
    lastEdu?: boolean
    domicileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | User$locationArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    fullname?: boolean
    email?: boolean
    password?: boolean
    isVerified?: boolean
    avatar?: boolean
    gender?: boolean
    dob?: boolean
    lastEdu?: boolean
    domicileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | User$locationArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    fullname?: boolean
    email?: boolean
    password?: boolean
    isVerified?: boolean
    avatar?: boolean
    gender?: boolean
    dob?: boolean
    lastEdu?: boolean
    domicileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "fullname" | "email" | "password" | "isVerified" | "avatar" | "gender" | "dob" | "lastEdu" | "domicileId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CurriculumVitae?: boolean | User$CurriculumVitaeArgs<ExtArgs>
    JobApplication?: boolean | User$JobApplicationArgs<ExtArgs>
    Review?: boolean | User$ReviewArgs<ExtArgs>
    Transaction?: boolean | User$TransactionArgs<ExtArgs>
    location?: boolean | User$locationArgs<ExtArgs>
    UserAssessment?: boolean | User$UserAssessmentArgs<ExtArgs>
    UserSubscription?: boolean | User$UserSubscriptionArgs<ExtArgs>
    Interview?: boolean | User$InterviewArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | User$locationArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | User$locationArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      CurriculumVitae: Prisma.$CurriculumVitaePayload<ExtArgs>[]
      JobApplication: Prisma.$JobApplicationPayload<ExtArgs>[]
      Review: Prisma.$ReviewPayload<ExtArgs>[]
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
      location: Prisma.$LocationPayload<ExtArgs> | null
      UserAssessment: Prisma.$UserAssessmentPayload<ExtArgs>[]
      UserSubscription: Prisma.$UserSubscriptionPayload<ExtArgs>[]
      Interview: Prisma.$InterviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      fullname: string | null
      email: string
      password: string
      isVerified: boolean
      avatar: string
      gender: $Enums.Gender | null
      dob: Date | null
      lastEdu: $Enums.LastEdu | null
      domicileId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CurriculumVitae<T extends User$CurriculumVitaeArgs<ExtArgs> = {}>(args?: Subset<T, User$CurriculumVitaeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurriculumVitaePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    JobApplication<T extends User$JobApplicationArgs<ExtArgs> = {}>(args?: Subset<T, User$JobApplicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Review<T extends User$ReviewArgs<ExtArgs> = {}>(args?: Subset<T, User$ReviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Transaction<T extends User$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, User$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    location<T extends User$locationArgs<ExtArgs> = {}>(args?: Subset<T, User$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    UserAssessment<T extends User$UserAssessmentArgs<ExtArgs> = {}>(args?: Subset<T, User$UserAssessmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAssessmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    UserSubscription<T extends User$UserSubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$UserSubscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Interview<T extends User$InterviewArgs<ExtArgs> = {}>(args?: Subset<T, User$InterviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly fullname: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'Gender'>
    readonly dob: FieldRef<"User", 'DateTime'>
    readonly lastEdu: FieldRef<"User", 'LastEdu'>
    readonly domicileId: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.CurriculumVitae
   */
  export type User$CurriculumVitaeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumVitae
     */
    select?: CurriculumVitaeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumVitae
     */
    omit?: CurriculumVitaeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumVitaeInclude<ExtArgs> | null
    where?: CurriculumVitaeWhereInput
    orderBy?: CurriculumVitaeOrderByWithRelationInput | CurriculumVitaeOrderByWithRelationInput[]
    cursor?: CurriculumVitaeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CurriculumVitaeScalarFieldEnum | CurriculumVitaeScalarFieldEnum[]
  }

  /**
   * User.JobApplication
   */
  export type User$JobApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    where?: JobApplicationWhereInput
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    cursor?: JobApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }

  /**
   * User.Review
   */
  export type User$ReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.Transaction
   */
  export type User$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.location
   */
  export type User$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * User.UserAssessment
   */
  export type User$UserAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessment
     */
    select?: UserAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessment
     */
    omit?: UserAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentInclude<ExtArgs> | null
    where?: UserAssessmentWhereInput
    orderBy?: UserAssessmentOrderByWithRelationInput | UserAssessmentOrderByWithRelationInput[]
    cursor?: UserAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAssessmentScalarFieldEnum | UserAssessmentScalarFieldEnum[]
  }

  /**
   * User.UserSubscription
   */
  export type User$UserSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    where?: UserSubscriptionWhereInput
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    cursor?: UserSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * User.Interview
   */
  export type User$InterviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    where?: InterviewWhereInput
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    cursor?: InterviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    companyName: string | null
    email: string | null
    password: string | null
    description: string | null
    isVerified: boolean | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    noHandphone: string | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    companyName: string | null
    email: string | null
    password: string | null
    description: string | null
    isVerified: boolean | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    noHandphone: string | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    companyName: number
    email: number
    password: number
    description: number
    isVerified: number
    logo: number
    createdAt: number
    updatedAt: number
    noHandphone: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    companyName?: true
    email?: true
    password?: true
    description?: true
    isVerified?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    noHandphone?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    companyName?: true
    email?: true
    password?: true
    description?: true
    isVerified?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    noHandphone?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    companyName?: true
    email?: true
    password?: true
    description?: true
    isVerified?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    noHandphone?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    companyName: string
    email: string
    password: string
    description: string
    isVerified: boolean
    logo: string | null
    createdAt: Date
    updatedAt: Date
    noHandphone: string
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    email?: boolean
    password?: boolean
    description?: boolean
    isVerified?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    noHandphone?: boolean
    Job?: boolean | Admin$JobArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    email?: boolean
    password?: boolean
    description?: boolean
    isVerified?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    noHandphone?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyName?: boolean
    email?: boolean
    password?: boolean
    description?: boolean
    isVerified?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    noHandphone?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    companyName?: boolean
    email?: boolean
    password?: boolean
    description?: boolean
    isVerified?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    noHandphone?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyName" | "email" | "password" | "description" | "isVerified" | "logo" | "createdAt" | "updatedAt" | "noHandphone", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Job?: boolean | Admin$JobArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      Job: Prisma.$JobPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      companyName: string
      email: string
      password: string
      description: string
      isVerified: boolean
      logo: string | null
      createdAt: Date
      updatedAt: Date
      noHandphone: string
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Job<T extends Admin$JobArgs<ExtArgs> = {}>(args?: Subset<T, Admin$JobArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly companyName: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly password: FieldRef<"Admin", 'String'>
    readonly description: FieldRef<"Admin", 'String'>
    readonly isVerified: FieldRef<"Admin", 'Boolean'>
    readonly logo: FieldRef<"Admin", 'String'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
    readonly noHandphone: FieldRef<"Admin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }

  /**
   * Admin.Job
   */
  export type Admin$JobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Developer
   */

  export type AggregateDeveloper = {
    _count: DeveloperCountAggregateOutputType | null
    _avg: DeveloperAvgAggregateOutputType | null
    _sum: DeveloperSumAggregateOutputType | null
    _min: DeveloperMinAggregateOutputType | null
    _max: DeveloperMaxAggregateOutputType | null
  }

  export type DeveloperAvgAggregateOutputType = {
    id: number | null
  }

  export type DeveloperSumAggregateOutputType = {
    id: number | null
  }

  export type DeveloperMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
  }

  export type DeveloperMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
  }

  export type DeveloperCountAggregateOutputType = {
    id: number
    email: number
    password: number
    _all: number
  }


  export type DeveloperAvgAggregateInputType = {
    id?: true
  }

  export type DeveloperSumAggregateInputType = {
    id?: true
  }

  export type DeveloperMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
  }

  export type DeveloperMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
  }

  export type DeveloperCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    _all?: true
  }

  export type DeveloperAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Developer to aggregate.
     */
    where?: DeveloperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Developers to fetch.
     */
    orderBy?: DeveloperOrderByWithRelationInput | DeveloperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeveloperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Developers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Developers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Developers
    **/
    _count?: true | DeveloperCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeveloperAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeveloperSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeveloperMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeveloperMaxAggregateInputType
  }

  export type GetDeveloperAggregateType<T extends DeveloperAggregateArgs> = {
        [P in keyof T & keyof AggregateDeveloper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeveloper[P]>
      : GetScalarType<T[P], AggregateDeveloper[P]>
  }




  export type DeveloperGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeveloperWhereInput
    orderBy?: DeveloperOrderByWithAggregationInput | DeveloperOrderByWithAggregationInput[]
    by: DeveloperScalarFieldEnum[] | DeveloperScalarFieldEnum
    having?: DeveloperScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeveloperCountAggregateInputType | true
    _avg?: DeveloperAvgAggregateInputType
    _sum?: DeveloperSumAggregateInputType
    _min?: DeveloperMinAggregateInputType
    _max?: DeveloperMaxAggregateInputType
  }

  export type DeveloperGroupByOutputType = {
    id: number
    email: string
    password: string
    _count: DeveloperCountAggregateOutputType | null
    _avg: DeveloperAvgAggregateOutputType | null
    _sum: DeveloperSumAggregateOutputType | null
    _min: DeveloperMinAggregateOutputType | null
    _max: DeveloperMaxAggregateOutputType | null
  }

  type GetDeveloperGroupByPayload<T extends DeveloperGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeveloperGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeveloperGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeveloperGroupByOutputType[P]>
            : GetScalarType<T[P], DeveloperGroupByOutputType[P]>
        }
      >
    >


  export type DeveloperSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
  }, ExtArgs["result"]["developer"]>

  export type DeveloperSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
  }, ExtArgs["result"]["developer"]>

  export type DeveloperSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
  }, ExtArgs["result"]["developer"]>

  export type DeveloperSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
  }

  export type DeveloperOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password", ExtArgs["result"]["developer"]>

  export type $DeveloperPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Developer"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
    }, ExtArgs["result"]["developer"]>
    composites: {}
  }

  type DeveloperGetPayload<S extends boolean | null | undefined | DeveloperDefaultArgs> = $Result.GetResult<Prisma.$DeveloperPayload, S>

  type DeveloperCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeveloperFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeveloperCountAggregateInputType | true
    }

  export interface DeveloperDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Developer'], meta: { name: 'Developer' } }
    /**
     * Find zero or one Developer that matches the filter.
     * @param {DeveloperFindUniqueArgs} args - Arguments to find a Developer
     * @example
     * // Get one Developer
     * const developer = await prisma.developer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeveloperFindUniqueArgs>(args: SelectSubset<T, DeveloperFindUniqueArgs<ExtArgs>>): Prisma__DeveloperClient<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Developer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeveloperFindUniqueOrThrowArgs} args - Arguments to find a Developer
     * @example
     * // Get one Developer
     * const developer = await prisma.developer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeveloperFindUniqueOrThrowArgs>(args: SelectSubset<T, DeveloperFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeveloperClient<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Developer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeveloperFindFirstArgs} args - Arguments to find a Developer
     * @example
     * // Get one Developer
     * const developer = await prisma.developer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeveloperFindFirstArgs>(args?: SelectSubset<T, DeveloperFindFirstArgs<ExtArgs>>): Prisma__DeveloperClient<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Developer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeveloperFindFirstOrThrowArgs} args - Arguments to find a Developer
     * @example
     * // Get one Developer
     * const developer = await prisma.developer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeveloperFindFirstOrThrowArgs>(args?: SelectSubset<T, DeveloperFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeveloperClient<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Developers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeveloperFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Developers
     * const developers = await prisma.developer.findMany()
     * 
     * // Get first 10 Developers
     * const developers = await prisma.developer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const developerWithIdOnly = await prisma.developer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeveloperFindManyArgs>(args?: SelectSubset<T, DeveloperFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Developer.
     * @param {DeveloperCreateArgs} args - Arguments to create a Developer.
     * @example
     * // Create one Developer
     * const Developer = await prisma.developer.create({
     *   data: {
     *     // ... data to create a Developer
     *   }
     * })
     * 
     */
    create<T extends DeveloperCreateArgs>(args: SelectSubset<T, DeveloperCreateArgs<ExtArgs>>): Prisma__DeveloperClient<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Developers.
     * @param {DeveloperCreateManyArgs} args - Arguments to create many Developers.
     * @example
     * // Create many Developers
     * const developer = await prisma.developer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeveloperCreateManyArgs>(args?: SelectSubset<T, DeveloperCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Developers and returns the data saved in the database.
     * @param {DeveloperCreateManyAndReturnArgs} args - Arguments to create many Developers.
     * @example
     * // Create many Developers
     * const developer = await prisma.developer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Developers and only return the `id`
     * const developerWithIdOnly = await prisma.developer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeveloperCreateManyAndReturnArgs>(args?: SelectSubset<T, DeveloperCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Developer.
     * @param {DeveloperDeleteArgs} args - Arguments to delete one Developer.
     * @example
     * // Delete one Developer
     * const Developer = await prisma.developer.delete({
     *   where: {
     *     // ... filter to delete one Developer
     *   }
     * })
     * 
     */
    delete<T extends DeveloperDeleteArgs>(args: SelectSubset<T, DeveloperDeleteArgs<ExtArgs>>): Prisma__DeveloperClient<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Developer.
     * @param {DeveloperUpdateArgs} args - Arguments to update one Developer.
     * @example
     * // Update one Developer
     * const developer = await prisma.developer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeveloperUpdateArgs>(args: SelectSubset<T, DeveloperUpdateArgs<ExtArgs>>): Prisma__DeveloperClient<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Developers.
     * @param {DeveloperDeleteManyArgs} args - Arguments to filter Developers to delete.
     * @example
     * // Delete a few Developers
     * const { count } = await prisma.developer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeveloperDeleteManyArgs>(args?: SelectSubset<T, DeveloperDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Developers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeveloperUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Developers
     * const developer = await prisma.developer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeveloperUpdateManyArgs>(args: SelectSubset<T, DeveloperUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Developers and returns the data updated in the database.
     * @param {DeveloperUpdateManyAndReturnArgs} args - Arguments to update many Developers.
     * @example
     * // Update many Developers
     * const developer = await prisma.developer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Developers and only return the `id`
     * const developerWithIdOnly = await prisma.developer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeveloperUpdateManyAndReturnArgs>(args: SelectSubset<T, DeveloperUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Developer.
     * @param {DeveloperUpsertArgs} args - Arguments to update or create a Developer.
     * @example
     * // Update or create a Developer
     * const developer = await prisma.developer.upsert({
     *   create: {
     *     // ... data to create a Developer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Developer we want to update
     *   }
     * })
     */
    upsert<T extends DeveloperUpsertArgs>(args: SelectSubset<T, DeveloperUpsertArgs<ExtArgs>>): Prisma__DeveloperClient<$Result.GetResult<Prisma.$DeveloperPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Developers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeveloperCountArgs} args - Arguments to filter Developers to count.
     * @example
     * // Count the number of Developers
     * const count = await prisma.developer.count({
     *   where: {
     *     // ... the filter for the Developers we want to count
     *   }
     * })
    **/
    count<T extends DeveloperCountArgs>(
      args?: Subset<T, DeveloperCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeveloperCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Developer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeveloperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeveloperAggregateArgs>(args: Subset<T, DeveloperAggregateArgs>): Prisma.PrismaPromise<GetDeveloperAggregateType<T>>

    /**
     * Group by Developer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeveloperGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeveloperGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeveloperGroupByArgs['orderBy'] }
        : { orderBy?: DeveloperGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeveloperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeveloperGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Developer model
   */
  readonly fields: DeveloperFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Developer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeveloperClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Developer model
   */ 
  interface DeveloperFieldRefs {
    readonly id: FieldRef<"Developer", 'Int'>
    readonly email: FieldRef<"Developer", 'String'>
    readonly password: FieldRef<"Developer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Developer findUnique
   */
  export type DeveloperFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * Filter, which Developer to fetch.
     */
    where: DeveloperWhereUniqueInput
  }

  /**
   * Developer findUniqueOrThrow
   */
  export type DeveloperFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * Filter, which Developer to fetch.
     */
    where: DeveloperWhereUniqueInput
  }

  /**
   * Developer findFirst
   */
  export type DeveloperFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * Filter, which Developer to fetch.
     */
    where?: DeveloperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Developers to fetch.
     */
    orderBy?: DeveloperOrderByWithRelationInput | DeveloperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Developers.
     */
    cursor?: DeveloperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Developers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Developers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Developers.
     */
    distinct?: DeveloperScalarFieldEnum | DeveloperScalarFieldEnum[]
  }

  /**
   * Developer findFirstOrThrow
   */
  export type DeveloperFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * Filter, which Developer to fetch.
     */
    where?: DeveloperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Developers to fetch.
     */
    orderBy?: DeveloperOrderByWithRelationInput | DeveloperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Developers.
     */
    cursor?: DeveloperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Developers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Developers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Developers.
     */
    distinct?: DeveloperScalarFieldEnum | DeveloperScalarFieldEnum[]
  }

  /**
   * Developer findMany
   */
  export type DeveloperFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * Filter, which Developers to fetch.
     */
    where?: DeveloperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Developers to fetch.
     */
    orderBy?: DeveloperOrderByWithRelationInput | DeveloperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Developers.
     */
    cursor?: DeveloperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Developers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Developers.
     */
    skip?: number
    distinct?: DeveloperScalarFieldEnum | DeveloperScalarFieldEnum[]
  }

  /**
   * Developer create
   */
  export type DeveloperCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * The data needed to create a Developer.
     */
    data: XOR<DeveloperCreateInput, DeveloperUncheckedCreateInput>
  }

  /**
   * Developer createMany
   */
  export type DeveloperCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Developers.
     */
    data: DeveloperCreateManyInput | DeveloperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Developer createManyAndReturn
   */
  export type DeveloperCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * The data used to create many Developers.
     */
    data: DeveloperCreateManyInput | DeveloperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Developer update
   */
  export type DeveloperUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * The data needed to update a Developer.
     */
    data: XOR<DeveloperUpdateInput, DeveloperUncheckedUpdateInput>
    /**
     * Choose, which Developer to update.
     */
    where: DeveloperWhereUniqueInput
  }

  /**
   * Developer updateMany
   */
  export type DeveloperUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Developers.
     */
    data: XOR<DeveloperUpdateManyMutationInput, DeveloperUncheckedUpdateManyInput>
    /**
     * Filter which Developers to update
     */
    where?: DeveloperWhereInput
  }

  /**
   * Developer updateManyAndReturn
   */
  export type DeveloperUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * The data used to update Developers.
     */
    data: XOR<DeveloperUpdateManyMutationInput, DeveloperUncheckedUpdateManyInput>
    /**
     * Filter which Developers to update
     */
    where?: DeveloperWhereInput
  }

  /**
   * Developer upsert
   */
  export type DeveloperUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * The filter to search for the Developer to update in case it exists.
     */
    where: DeveloperWhereUniqueInput
    /**
     * In case the Developer found by the `where` argument doesn't exist, create a new Developer with this data.
     */
    create: XOR<DeveloperCreateInput, DeveloperUncheckedCreateInput>
    /**
     * In case the Developer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeveloperUpdateInput, DeveloperUncheckedUpdateInput>
  }

  /**
   * Developer delete
   */
  export type DeveloperDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
    /**
     * Filter which Developer to delete.
     */
    where: DeveloperWhereUniqueInput
  }

  /**
   * Developer deleteMany
   */
  export type DeveloperDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Developers to delete
     */
    where?: DeveloperWhereInput
  }

  /**
   * Developer without action
   */
  export type DeveloperDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Developer
     */
    select?: DeveloperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Developer
     */
    omit?: DeveloperOmit<ExtArgs> | null
  }


  /**
   * Model Job
   */

  export type AggregateJob = {
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  export type JobAvgAggregateOutputType = {
    adminId: number | null
    salary: number | null
    locationId: number | null
  }

  export type JobSumAggregateOutputType = {
    adminId: number | null
    salary: number | null
    locationId: number | null
  }

  export type JobMinAggregateOutputType = {
    id: string | null
    title: string | null
    adminId: number | null
    banner: string | null
    category: $Enums.JobCategory | null
    role: string | null
    salary: number | null
    description: string | null
    endDate: Date | null
    isPublished: boolean | null
    isTestActive: boolean | null
    locationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
  }

  export type JobMaxAggregateOutputType = {
    id: string | null
    title: string | null
    adminId: number | null
    banner: string | null
    category: $Enums.JobCategory | null
    role: string | null
    salary: number | null
    description: string | null
    endDate: Date | null
    isPublished: boolean | null
    isTestActive: boolean | null
    locationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
  }

  export type JobCountAggregateOutputType = {
    id: number
    title: number
    adminId: number
    banner: number
    category: number
    role: number
    salary: number
    description: number
    endDate: number
    isPublished: number
    isTestActive: number
    tags: number
    locationId: number
    createdAt: number
    updatedAt: number
    isActive: number
    _all: number
  }


  export type JobAvgAggregateInputType = {
    adminId?: true
    salary?: true
    locationId?: true
  }

  export type JobSumAggregateInputType = {
    adminId?: true
    salary?: true
    locationId?: true
  }

  export type JobMinAggregateInputType = {
    id?: true
    title?: true
    adminId?: true
    banner?: true
    category?: true
    role?: true
    salary?: true
    description?: true
    endDate?: true
    isPublished?: true
    isTestActive?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
  }

  export type JobMaxAggregateInputType = {
    id?: true
    title?: true
    adminId?: true
    banner?: true
    category?: true
    role?: true
    salary?: true
    description?: true
    endDate?: true
    isPublished?: true
    isTestActive?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
  }

  export type JobCountAggregateInputType = {
    id?: true
    title?: true
    adminId?: true
    banner?: true
    category?: true
    role?: true
    salary?: true
    description?: true
    endDate?: true
    isPublished?: true
    isTestActive?: true
    tags?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    _all?: true
  }

  export type JobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Job to aggregate.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobMaxAggregateInputType
  }

  export type GetJobAggregateType<T extends JobAggregateArgs> = {
        [P in keyof T & keyof AggregateJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob[P]>
      : GetScalarType<T[P], AggregateJob[P]>
  }




  export type JobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
    orderBy?: JobOrderByWithAggregationInput | JobOrderByWithAggregationInput[]
    by: JobScalarFieldEnum[] | JobScalarFieldEnum
    having?: JobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCountAggregateInputType | true
    _avg?: JobAvgAggregateInputType
    _sum?: JobSumAggregateInputType
    _min?: JobMinAggregateInputType
    _max?: JobMaxAggregateInputType
  }

  export type JobGroupByOutputType = {
    id: string
    title: string
    adminId: number
    banner: string | null
    category: $Enums.JobCategory
    role: string
    salary: number | null
    description: string
    endDate: Date
    isPublished: boolean
    isTestActive: boolean
    tags: string[]
    locationId: number
    createdAt: Date
    updatedAt: Date
    isActive: boolean
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  type GetJobGroupByPayload<T extends JobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobGroupByOutputType[P]>
            : GetScalarType<T[P], JobGroupByOutputType[P]>
        }
      >
    >


  export type JobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    adminId?: boolean
    banner?: boolean
    category?: boolean
    role?: boolean
    salary?: boolean
    description?: boolean
    endDate?: boolean
    isPublished?: boolean
    isTestActive?: boolean
    tags?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    JobApplication?: boolean | Job$JobApplicationArgs<ExtArgs>
    PreSelectionTest?: boolean | Job$PreSelectionTestArgs<ExtArgs>
    Review?: boolean | Job$ReviewArgs<ExtArgs>
    Interview?: boolean | Job$InterviewArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    adminId?: boolean
    banner?: boolean
    category?: boolean
    role?: boolean
    salary?: boolean
    description?: boolean
    endDate?: boolean
    isPublished?: boolean
    isTestActive?: boolean
    tags?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    adminId?: boolean
    banner?: boolean
    category?: boolean
    role?: boolean
    salary?: boolean
    description?: boolean
    endDate?: boolean
    isPublished?: boolean
    isTestActive?: boolean
    tags?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectScalar = {
    id?: boolean
    title?: boolean
    adminId?: boolean
    banner?: boolean
    category?: boolean
    role?: boolean
    salary?: boolean
    description?: boolean
    endDate?: boolean
    isPublished?: boolean
    isTestActive?: boolean
    tags?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
  }

  export type JobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "adminId" | "banner" | "category" | "role" | "salary" | "description" | "endDate" | "isPublished" | "isTestActive" | "tags" | "locationId" | "createdAt" | "updatedAt" | "isActive", ExtArgs["result"]["job"]>
  export type JobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    JobApplication?: boolean | Job$JobApplicationArgs<ExtArgs>
    PreSelectionTest?: boolean | Job$PreSelectionTestArgs<ExtArgs>
    Review?: boolean | Job$ReviewArgs<ExtArgs>
    Interview?: boolean | Job$InterviewArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type JobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $JobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Job"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
      JobApplication: Prisma.$JobApplicationPayload<ExtArgs>[]
      PreSelectionTest: Prisma.$PreSelectionTestPayload<ExtArgs>[]
      Review: Prisma.$ReviewPayload<ExtArgs>[]
      Interview: Prisma.$InterviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      adminId: number
      banner: string | null
      category: $Enums.JobCategory
      role: string
      salary: number | null
      description: string
      endDate: Date
      isPublished: boolean
      isTestActive: boolean
      tags: string[]
      locationId: number
      createdAt: Date
      updatedAt: Date
      isActive: boolean
    }, ExtArgs["result"]["job"]>
    composites: {}
  }

  type JobGetPayload<S extends boolean | null | undefined | JobDefaultArgs> = $Result.GetResult<Prisma.$JobPayload, S>

  type JobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobCountAggregateInputType | true
    }

  export interface JobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Job'], meta: { name: 'Job' } }
    /**
     * Find zero or one Job that matches the filter.
     * @param {JobFindUniqueArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobFindUniqueArgs>(args: SelectSubset<T, JobFindUniqueArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Job that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobFindUniqueOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobFindUniqueOrThrowArgs>(args: SelectSubset<T, JobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Job that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobFindFirstArgs>(args?: SelectSubset<T, JobFindFirstArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Job that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobFindFirstOrThrowArgs>(args?: SelectSubset<T, JobFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.job.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.job.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobWithIdOnly = await prisma.job.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobFindManyArgs>(args?: SelectSubset<T, JobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Job.
     * @param {JobCreateArgs} args - Arguments to create a Job.
     * @example
     * // Create one Job
     * const Job = await prisma.job.create({
     *   data: {
     *     // ... data to create a Job
     *   }
     * })
     * 
     */
    create<T extends JobCreateArgs>(args: SelectSubset<T, JobCreateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Jobs.
     * @param {JobCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobCreateManyArgs>(args?: SelectSubset<T, JobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jobs and returns the data saved in the database.
     * @param {JobCreateManyAndReturnArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobCreateManyAndReturnArgs>(args?: SelectSubset<T, JobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Job.
     * @param {JobDeleteArgs} args - Arguments to delete one Job.
     * @example
     * // Delete one Job
     * const Job = await prisma.job.delete({
     *   where: {
     *     // ... filter to delete one Job
     *   }
     * })
     * 
     */
    delete<T extends JobDeleteArgs>(args: SelectSubset<T, JobDeleteArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Job.
     * @param {JobUpdateArgs} args - Arguments to update one Job.
     * @example
     * // Update one Job
     * const job = await prisma.job.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobUpdateArgs>(args: SelectSubset<T, JobUpdateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Jobs.
     * @param {JobDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.job.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobDeleteManyArgs>(args?: SelectSubset<T, JobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobUpdateManyArgs>(args: SelectSubset<T, JobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs and returns the data updated in the database.
     * @param {JobUpdateManyAndReturnArgs} args - Arguments to update many Jobs.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobUpdateManyAndReturnArgs>(args: SelectSubset<T, JobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Job.
     * @param {JobUpsertArgs} args - Arguments to update or create a Job.
     * @example
     * // Update or create a Job
     * const job = await prisma.job.upsert({
     *   create: {
     *     // ... data to create a Job
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job we want to update
     *   }
     * })
     */
    upsert<T extends JobUpsertArgs>(args: SelectSubset<T, JobUpsertArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.job.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobCountArgs>(
      args?: Subset<T, JobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobAggregateArgs>(args: Subset<T, JobAggregateArgs>): Prisma.PrismaPromise<GetJobAggregateType<T>>

    /**
     * Group by Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobGroupByArgs['orderBy'] }
        : { orderBy?: JobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Job model
   */
  readonly fields: JobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Job.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    JobApplication<T extends Job$JobApplicationArgs<ExtArgs> = {}>(args?: Subset<T, Job$JobApplicationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    PreSelectionTest<T extends Job$PreSelectionTestArgs<ExtArgs> = {}>(args?: Subset<T, Job$PreSelectionTestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreSelectionTestPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Review<T extends Job$ReviewArgs<ExtArgs> = {}>(args?: Subset<T, Job$ReviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Interview<T extends Job$InterviewArgs<ExtArgs> = {}>(args?: Subset<T, Job$InterviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Job model
   */ 
  interface JobFieldRefs {
    readonly id: FieldRef<"Job", 'String'>
    readonly title: FieldRef<"Job", 'String'>
    readonly adminId: FieldRef<"Job", 'Int'>
    readonly banner: FieldRef<"Job", 'String'>
    readonly category: FieldRef<"Job", 'JobCategory'>
    readonly role: FieldRef<"Job", 'String'>
    readonly salary: FieldRef<"Job", 'Int'>
    readonly description: FieldRef<"Job", 'String'>
    readonly endDate: FieldRef<"Job", 'DateTime'>
    readonly isPublished: FieldRef<"Job", 'Boolean'>
    readonly isTestActive: FieldRef<"Job", 'Boolean'>
    readonly tags: FieldRef<"Job", 'String[]'>
    readonly locationId: FieldRef<"Job", 'Int'>
    readonly createdAt: FieldRef<"Job", 'DateTime'>
    readonly updatedAt: FieldRef<"Job", 'DateTime'>
    readonly isActive: FieldRef<"Job", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Job findUnique
   */
  export type JobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findUniqueOrThrow
   */
  export type JobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findFirst
   */
  export type JobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findFirstOrThrow
   */
  export type JobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findMany
   */
  export type JobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job create
   */
  export type JobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to create a Job.
     */
    data: XOR<JobCreateInput, JobUncheckedCreateInput>
  }

  /**
   * Job createMany
   */
  export type JobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Job createManyAndReturn
   */
  export type JobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Job update
   */
  export type JobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to update a Job.
     */
    data: XOR<JobUpdateInput, JobUncheckedUpdateInput>
    /**
     * Choose, which Job to update.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job updateMany
   */
  export type JobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
  }

  /**
   * Job updateManyAndReturn
   */
  export type JobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Job upsert
   */
  export type JobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The filter to search for the Job to update in case it exists.
     */
    where: JobWhereUniqueInput
    /**
     * In case the Job found by the `where` argument doesn't exist, create a new Job with this data.
     */
    create: XOR<JobCreateInput, JobUncheckedCreateInput>
    /**
     * In case the Job was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobUpdateInput, JobUncheckedUpdateInput>
  }

  /**
   * Job delete
   */
  export type JobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter which Job to delete.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job deleteMany
   */
  export type JobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to delete
     */
    where?: JobWhereInput
  }

  /**
   * Job.JobApplication
   */
  export type Job$JobApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    where?: JobApplicationWhereInput
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    cursor?: JobApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }

  /**
   * Job.PreSelectionTest
   */
  export type Job$PreSelectionTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreSelectionTest
     */
    select?: PreSelectionTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreSelectionTest
     */
    omit?: PreSelectionTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreSelectionTestInclude<ExtArgs> | null
    where?: PreSelectionTestWhereInput
    orderBy?: PreSelectionTestOrderByWithRelationInput | PreSelectionTestOrderByWithRelationInput[]
    cursor?: PreSelectionTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreSelectionTestScalarFieldEnum | PreSelectionTestScalarFieldEnum[]
  }

  /**
   * Job.Review
   */
  export type Job$ReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Job.Interview
   */
  export type Job$InterviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    where?: InterviewWhereInput
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    cursor?: InterviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * Job without action
   */
  export type JobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
  }


  /**
   * Model CurriculumVitae
   */

  export type AggregateCurriculumVitae = {
    _count: CurriculumVitaeCountAggregateOutputType | null
    _avg: CurriculumVitaeAvgAggregateOutputType | null
    _sum: CurriculumVitaeSumAggregateOutputType | null
    _min: CurriculumVitaeMinAggregateOutputType | null
    _max: CurriculumVitaeMaxAggregateOutputType | null
  }

  export type CurriculumVitaeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CurriculumVitaeSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CurriculumVitaeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    summary: string | null
    experience: string | null
    skill: string | null
    education: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurriculumVitaeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    summary: string | null
    experience: string | null
    skill: string | null
    education: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurriculumVitaeCountAggregateOutputType = {
    id: number
    userId: number
    summary: number
    experience: number
    skill: number
    education: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CurriculumVitaeAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CurriculumVitaeSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CurriculumVitaeMinAggregateInputType = {
    id?: true
    userId?: true
    summary?: true
    experience?: true
    skill?: true
    education?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurriculumVitaeMaxAggregateInputType = {
    id?: true
    userId?: true
    summary?: true
    experience?: true
    skill?: true
    education?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurriculumVitaeCountAggregateInputType = {
    id?: true
    userId?: true
    summary?: true
    experience?: true
    skill?: true
    education?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CurriculumVitaeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CurriculumVitae to aggregate.
     */
    where?: CurriculumVitaeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurriculumVitaes to fetch.
     */
    orderBy?: CurriculumVitaeOrderByWithRelationInput | CurriculumVitaeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurriculumVitaeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurriculumVitaes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurriculumVitaes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CurriculumVitaes
    **/
    _count?: true | CurriculumVitaeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurriculumVitaeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurriculumVitaeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurriculumVitaeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurriculumVitaeMaxAggregateInputType
  }

  export type GetCurriculumVitaeAggregateType<T extends CurriculumVitaeAggregateArgs> = {
        [P in keyof T & keyof AggregateCurriculumVitae]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurriculumVitae[P]>
      : GetScalarType<T[P], AggregateCurriculumVitae[P]>
  }




  export type CurriculumVitaeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurriculumVitaeWhereInput
    orderBy?: CurriculumVitaeOrderByWithAggregationInput | CurriculumVitaeOrderByWithAggregationInput[]
    by: CurriculumVitaeScalarFieldEnum[] | CurriculumVitaeScalarFieldEnum
    having?: CurriculumVitaeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurriculumVitaeCountAggregateInputType | true
    _avg?: CurriculumVitaeAvgAggregateInputType
    _sum?: CurriculumVitaeSumAggregateInputType
    _min?: CurriculumVitaeMinAggregateInputType
    _max?: CurriculumVitaeMaxAggregateInputType
  }

  export type CurriculumVitaeGroupByOutputType = {
    id: number
    userId: number
    summary: string
    experience: string
    skill: string
    education: string
    createdAt: Date
    updatedAt: Date
    _count: CurriculumVitaeCountAggregateOutputType | null
    _avg: CurriculumVitaeAvgAggregateOutputType | null
    _sum: CurriculumVitaeSumAggregateOutputType | null
    _min: CurriculumVitaeMinAggregateOutputType | null
    _max: CurriculumVitaeMaxAggregateOutputType | null
  }

  type GetCurriculumVitaeGroupByPayload<T extends CurriculumVitaeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurriculumVitaeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurriculumVitaeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurriculumVitaeGroupByOutputType[P]>
            : GetScalarType<T[P], CurriculumVitaeGroupByOutputType[P]>
        }
      >
    >


  export type CurriculumVitaeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    summary?: boolean
    experience?: boolean
    skill?: boolean
    education?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["curriculumVitae"]>

  export type CurriculumVitaeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    summary?: boolean
    experience?: boolean
    skill?: boolean
    education?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["curriculumVitae"]>

  export type CurriculumVitaeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    summary?: boolean
    experience?: boolean
    skill?: boolean
    education?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["curriculumVitae"]>

  export type CurriculumVitaeSelectScalar = {
    id?: boolean
    userId?: boolean
    summary?: boolean
    experience?: boolean
    skill?: boolean
    education?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CurriculumVitaeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "summary" | "experience" | "skill" | "education" | "createdAt" | "updatedAt", ExtArgs["result"]["curriculumVitae"]>
  export type CurriculumVitaeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CurriculumVitaeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CurriculumVitaeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CurriculumVitaePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CurriculumVitae"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      summary: string
      experience: string
      skill: string
      education: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["curriculumVitae"]>
    composites: {}
  }

  type CurriculumVitaeGetPayload<S extends boolean | null | undefined | CurriculumVitaeDefaultArgs> = $Result.GetResult<Prisma.$CurriculumVitaePayload, S>

  type CurriculumVitaeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CurriculumVitaeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurriculumVitaeCountAggregateInputType | true
    }

  export interface CurriculumVitaeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CurriculumVitae'], meta: { name: 'CurriculumVitae' } }
    /**
     * Find zero or one CurriculumVitae that matches the filter.
     * @param {CurriculumVitaeFindUniqueArgs} args - Arguments to find a CurriculumVitae
     * @example
     * // Get one CurriculumVitae
     * const curriculumVitae = await prisma.curriculumVitae.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurriculumVitaeFindUniqueArgs>(args: SelectSubset<T, CurriculumVitaeFindUniqueArgs<ExtArgs>>): Prisma__CurriculumVitaeClient<$Result.GetResult<Prisma.$CurriculumVitaePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CurriculumVitae that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CurriculumVitaeFindUniqueOrThrowArgs} args - Arguments to find a CurriculumVitae
     * @example
     * // Get one CurriculumVitae
     * const curriculumVitae = await prisma.curriculumVitae.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurriculumVitaeFindUniqueOrThrowArgs>(args: SelectSubset<T, CurriculumVitaeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurriculumVitaeClient<$Result.GetResult<Prisma.$CurriculumVitaePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CurriculumVitae that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumVitaeFindFirstArgs} args - Arguments to find a CurriculumVitae
     * @example
     * // Get one CurriculumVitae
     * const curriculumVitae = await prisma.curriculumVitae.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurriculumVitaeFindFirstArgs>(args?: SelectSubset<T, CurriculumVitaeFindFirstArgs<ExtArgs>>): Prisma__CurriculumVitaeClient<$Result.GetResult<Prisma.$CurriculumVitaePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CurriculumVitae that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumVitaeFindFirstOrThrowArgs} args - Arguments to find a CurriculumVitae
     * @example
     * // Get one CurriculumVitae
     * const curriculumVitae = await prisma.curriculumVitae.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurriculumVitaeFindFirstOrThrowArgs>(args?: SelectSubset<T, CurriculumVitaeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurriculumVitaeClient<$Result.GetResult<Prisma.$CurriculumVitaePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CurriculumVitaes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumVitaeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CurriculumVitaes
     * const curriculumVitaes = await prisma.curriculumVitae.findMany()
     * 
     * // Get first 10 CurriculumVitaes
     * const curriculumVitaes = await prisma.curriculumVitae.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const curriculumVitaeWithIdOnly = await prisma.curriculumVitae.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CurriculumVitaeFindManyArgs>(args?: SelectSubset<T, CurriculumVitaeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurriculumVitaePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CurriculumVitae.
     * @param {CurriculumVitaeCreateArgs} args - Arguments to create a CurriculumVitae.
     * @example
     * // Create one CurriculumVitae
     * const CurriculumVitae = await prisma.curriculumVitae.create({
     *   data: {
     *     // ... data to create a CurriculumVitae
     *   }
     * })
     * 
     */
    create<T extends CurriculumVitaeCreateArgs>(args: SelectSubset<T, CurriculumVitaeCreateArgs<ExtArgs>>): Prisma__CurriculumVitaeClient<$Result.GetResult<Prisma.$CurriculumVitaePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CurriculumVitaes.
     * @param {CurriculumVitaeCreateManyArgs} args - Arguments to create many CurriculumVitaes.
     * @example
     * // Create many CurriculumVitaes
     * const curriculumVitae = await prisma.curriculumVitae.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurriculumVitaeCreateManyArgs>(args?: SelectSubset<T, CurriculumVitaeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CurriculumVitaes and returns the data saved in the database.
     * @param {CurriculumVitaeCreateManyAndReturnArgs} args - Arguments to create many CurriculumVitaes.
     * @example
     * // Create many CurriculumVitaes
     * const curriculumVitae = await prisma.curriculumVitae.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CurriculumVitaes and only return the `id`
     * const curriculumVitaeWithIdOnly = await prisma.curriculumVitae.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CurriculumVitaeCreateManyAndReturnArgs>(args?: SelectSubset<T, CurriculumVitaeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurriculumVitaePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CurriculumVitae.
     * @param {CurriculumVitaeDeleteArgs} args - Arguments to delete one CurriculumVitae.
     * @example
     * // Delete one CurriculumVitae
     * const CurriculumVitae = await prisma.curriculumVitae.delete({
     *   where: {
     *     // ... filter to delete one CurriculumVitae
     *   }
     * })
     * 
     */
    delete<T extends CurriculumVitaeDeleteArgs>(args: SelectSubset<T, CurriculumVitaeDeleteArgs<ExtArgs>>): Prisma__CurriculumVitaeClient<$Result.GetResult<Prisma.$CurriculumVitaePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CurriculumVitae.
     * @param {CurriculumVitaeUpdateArgs} args - Arguments to update one CurriculumVitae.
     * @example
     * // Update one CurriculumVitae
     * const curriculumVitae = await prisma.curriculumVitae.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurriculumVitaeUpdateArgs>(args: SelectSubset<T, CurriculumVitaeUpdateArgs<ExtArgs>>): Prisma__CurriculumVitaeClient<$Result.GetResult<Prisma.$CurriculumVitaePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CurriculumVitaes.
     * @param {CurriculumVitaeDeleteManyArgs} args - Arguments to filter CurriculumVitaes to delete.
     * @example
     * // Delete a few CurriculumVitaes
     * const { count } = await prisma.curriculumVitae.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurriculumVitaeDeleteManyArgs>(args?: SelectSubset<T, CurriculumVitaeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CurriculumVitaes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumVitaeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CurriculumVitaes
     * const curriculumVitae = await prisma.curriculumVitae.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurriculumVitaeUpdateManyArgs>(args: SelectSubset<T, CurriculumVitaeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CurriculumVitaes and returns the data updated in the database.
     * @param {CurriculumVitaeUpdateManyAndReturnArgs} args - Arguments to update many CurriculumVitaes.
     * @example
     * // Update many CurriculumVitaes
     * const curriculumVitae = await prisma.curriculumVitae.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CurriculumVitaes and only return the `id`
     * const curriculumVitaeWithIdOnly = await prisma.curriculumVitae.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CurriculumVitaeUpdateManyAndReturnArgs>(args: SelectSubset<T, CurriculumVitaeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurriculumVitaePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CurriculumVitae.
     * @param {CurriculumVitaeUpsertArgs} args - Arguments to update or create a CurriculumVitae.
     * @example
     * // Update or create a CurriculumVitae
     * const curriculumVitae = await prisma.curriculumVitae.upsert({
     *   create: {
     *     // ... data to create a CurriculumVitae
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CurriculumVitae we want to update
     *   }
     * })
     */
    upsert<T extends CurriculumVitaeUpsertArgs>(args: SelectSubset<T, CurriculumVitaeUpsertArgs<ExtArgs>>): Prisma__CurriculumVitaeClient<$Result.GetResult<Prisma.$CurriculumVitaePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CurriculumVitaes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumVitaeCountArgs} args - Arguments to filter CurriculumVitaes to count.
     * @example
     * // Count the number of CurriculumVitaes
     * const count = await prisma.curriculumVitae.count({
     *   where: {
     *     // ... the filter for the CurriculumVitaes we want to count
     *   }
     * })
    **/
    count<T extends CurriculumVitaeCountArgs>(
      args?: Subset<T, CurriculumVitaeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurriculumVitaeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CurriculumVitae.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumVitaeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurriculumVitaeAggregateArgs>(args: Subset<T, CurriculumVitaeAggregateArgs>): Prisma.PrismaPromise<GetCurriculumVitaeAggregateType<T>>

    /**
     * Group by CurriculumVitae.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumVitaeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurriculumVitaeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurriculumVitaeGroupByArgs['orderBy'] }
        : { orderBy?: CurriculumVitaeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurriculumVitaeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurriculumVitaeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CurriculumVitae model
   */
  readonly fields: CurriculumVitaeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CurriculumVitae.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurriculumVitaeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CurriculumVitae model
   */ 
  interface CurriculumVitaeFieldRefs {
    readonly id: FieldRef<"CurriculumVitae", 'Int'>
    readonly userId: FieldRef<"CurriculumVitae", 'Int'>
    readonly summary: FieldRef<"CurriculumVitae", 'String'>
    readonly experience: FieldRef<"CurriculumVitae", 'String'>
    readonly skill: FieldRef<"CurriculumVitae", 'String'>
    readonly education: FieldRef<"CurriculumVitae", 'String'>
    readonly createdAt: FieldRef<"CurriculumVitae", 'DateTime'>
    readonly updatedAt: FieldRef<"CurriculumVitae", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CurriculumVitae findUnique
   */
  export type CurriculumVitaeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumVitae
     */
    select?: CurriculumVitaeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumVitae
     */
    omit?: CurriculumVitaeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumVitaeInclude<ExtArgs> | null
    /**
     * Filter, which CurriculumVitae to fetch.
     */
    where: CurriculumVitaeWhereUniqueInput
  }

  /**
   * CurriculumVitae findUniqueOrThrow
   */
  export type CurriculumVitaeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumVitae
     */
    select?: CurriculumVitaeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumVitae
     */
    omit?: CurriculumVitaeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumVitaeInclude<ExtArgs> | null
    /**
     * Filter, which CurriculumVitae to fetch.
     */
    where: CurriculumVitaeWhereUniqueInput
  }

  /**
   * CurriculumVitae findFirst
   */
  export type CurriculumVitaeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumVitae
     */
    select?: CurriculumVitaeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumVitae
     */
    omit?: CurriculumVitaeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumVitaeInclude<ExtArgs> | null
    /**
     * Filter, which CurriculumVitae to fetch.
     */
    where?: CurriculumVitaeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurriculumVitaes to fetch.
     */
    orderBy?: CurriculumVitaeOrderByWithRelationInput | CurriculumVitaeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CurriculumVitaes.
     */
    cursor?: CurriculumVitaeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurriculumVitaes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurriculumVitaes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CurriculumVitaes.
     */
    distinct?: CurriculumVitaeScalarFieldEnum | CurriculumVitaeScalarFieldEnum[]
  }

  /**
   * CurriculumVitae findFirstOrThrow
   */
  export type CurriculumVitaeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumVitae
     */
    select?: CurriculumVitaeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumVitae
     */
    omit?: CurriculumVitaeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumVitaeInclude<ExtArgs> | null
    /**
     * Filter, which CurriculumVitae to fetch.
     */
    where?: CurriculumVitaeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurriculumVitaes to fetch.
     */
    orderBy?: CurriculumVitaeOrderByWithRelationInput | CurriculumVitaeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CurriculumVitaes.
     */
    cursor?: CurriculumVitaeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurriculumVitaes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurriculumVitaes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CurriculumVitaes.
     */
    distinct?: CurriculumVitaeScalarFieldEnum | CurriculumVitaeScalarFieldEnum[]
  }

  /**
   * CurriculumVitae findMany
   */
  export type CurriculumVitaeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumVitae
     */
    select?: CurriculumVitaeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumVitae
     */
    omit?: CurriculumVitaeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumVitaeInclude<ExtArgs> | null
    /**
     * Filter, which CurriculumVitaes to fetch.
     */
    where?: CurriculumVitaeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurriculumVitaes to fetch.
     */
    orderBy?: CurriculumVitaeOrderByWithRelationInput | CurriculumVitaeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CurriculumVitaes.
     */
    cursor?: CurriculumVitaeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurriculumVitaes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurriculumVitaes.
     */
    skip?: number
    distinct?: CurriculumVitaeScalarFieldEnum | CurriculumVitaeScalarFieldEnum[]
  }

  /**
   * CurriculumVitae create
   */
  export type CurriculumVitaeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumVitae
     */
    select?: CurriculumVitaeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumVitae
     */
    omit?: CurriculumVitaeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumVitaeInclude<ExtArgs> | null
    /**
     * The data needed to create a CurriculumVitae.
     */
    data: XOR<CurriculumVitaeCreateInput, CurriculumVitaeUncheckedCreateInput>
  }

  /**
   * CurriculumVitae createMany
   */
  export type CurriculumVitaeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CurriculumVitaes.
     */
    data: CurriculumVitaeCreateManyInput | CurriculumVitaeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CurriculumVitae createManyAndReturn
   */
  export type CurriculumVitaeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumVitae
     */
    select?: CurriculumVitaeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumVitae
     */
    omit?: CurriculumVitaeOmit<ExtArgs> | null
    /**
     * The data used to create many CurriculumVitaes.
     */
    data: CurriculumVitaeCreateManyInput | CurriculumVitaeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumVitaeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CurriculumVitae update
   */
  export type CurriculumVitaeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumVitae
     */
    select?: CurriculumVitaeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumVitae
     */
    omit?: CurriculumVitaeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumVitaeInclude<ExtArgs> | null
    /**
     * The data needed to update a CurriculumVitae.
     */
    data: XOR<CurriculumVitaeUpdateInput, CurriculumVitaeUncheckedUpdateInput>
    /**
     * Choose, which CurriculumVitae to update.
     */
    where: CurriculumVitaeWhereUniqueInput
  }

  /**
   * CurriculumVitae updateMany
   */
  export type CurriculumVitaeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CurriculumVitaes.
     */
    data: XOR<CurriculumVitaeUpdateManyMutationInput, CurriculumVitaeUncheckedUpdateManyInput>
    /**
     * Filter which CurriculumVitaes to update
     */
    where?: CurriculumVitaeWhereInput
  }

  /**
   * CurriculumVitae updateManyAndReturn
   */
  export type CurriculumVitaeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumVitae
     */
    select?: CurriculumVitaeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumVitae
     */
    omit?: CurriculumVitaeOmit<ExtArgs> | null
    /**
     * The data used to update CurriculumVitaes.
     */
    data: XOR<CurriculumVitaeUpdateManyMutationInput, CurriculumVitaeUncheckedUpdateManyInput>
    /**
     * Filter which CurriculumVitaes to update
     */
    where?: CurriculumVitaeWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumVitaeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CurriculumVitae upsert
   */
  export type CurriculumVitaeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumVitae
     */
    select?: CurriculumVitaeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumVitae
     */
    omit?: CurriculumVitaeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumVitaeInclude<ExtArgs> | null
    /**
     * The filter to search for the CurriculumVitae to update in case it exists.
     */
    where: CurriculumVitaeWhereUniqueInput
    /**
     * In case the CurriculumVitae found by the `where` argument doesn't exist, create a new CurriculumVitae with this data.
     */
    create: XOR<CurriculumVitaeCreateInput, CurriculumVitaeUncheckedCreateInput>
    /**
     * In case the CurriculumVitae was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurriculumVitaeUpdateInput, CurriculumVitaeUncheckedUpdateInput>
  }

  /**
   * CurriculumVitae delete
   */
  export type CurriculumVitaeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumVitae
     */
    select?: CurriculumVitaeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumVitae
     */
    omit?: CurriculumVitaeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumVitaeInclude<ExtArgs> | null
    /**
     * Filter which CurriculumVitae to delete.
     */
    where: CurriculumVitaeWhereUniqueInput
  }

  /**
   * CurriculumVitae deleteMany
   */
  export type CurriculumVitaeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CurriculumVitaes to delete
     */
    where?: CurriculumVitaeWhereInput
  }

  /**
   * CurriculumVitae without action
   */
  export type CurriculumVitaeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumVitae
     */
    select?: CurriculumVitaeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CurriculumVitae
     */
    omit?: CurriculumVitaeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumVitaeInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type LocationSumAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: number | null
    city: string | null
    province: string | null
    latitude: number | null
    longitude: number | null
  }

  export type LocationMaxAggregateOutputType = {
    id: number | null
    city: string | null
    province: string | null
    latitude: number | null
    longitude: number | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    city: number
    province: number
    latitude: number
    longitude: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type LocationSumAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    city?: true
    province?: true
    latitude?: true
    longitude?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    city?: true
    province?: true
    latitude?: true
    longitude?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    city?: true
    province?: true
    latitude?: true
    longitude?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: number
    city: string
    province: string
    latitude: number
    longitude: number
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    city?: boolean
    province?: boolean
    latitude?: boolean
    longitude?: boolean
    Job?: boolean | Location$JobArgs<ExtArgs>
    User?: boolean | Location$UserArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    city?: boolean
    province?: boolean
    latitude?: boolean
    longitude?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    city?: boolean
    province?: boolean
    latitude?: boolean
    longitude?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    city?: boolean
    province?: boolean
    latitude?: boolean
    longitude?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "city" | "province" | "latitude" | "longitude", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Job?: boolean | Location$JobArgs<ExtArgs>
    User?: boolean | Location$UserArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      Job: Prisma.$JobPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      city: string
      province: string
      latitude: number
      longitude: number
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Job<T extends Location$JobArgs<ExtArgs> = {}>(args?: Subset<T, Location$JobArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    User<T extends Location$UserArgs<ExtArgs> = {}>(args?: Subset<T, Location$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */ 
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'Int'>
    readonly city: FieldRef<"Location", 'String'>
    readonly province: FieldRef<"Location", 'String'>
    readonly latitude: FieldRef<"Location", 'Float'>
    readonly longitude: FieldRef<"Location", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
  }

  /**
   * Location.Job
   */
  export type Location$JobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Location.User
   */
  export type Location$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: number | null
    category: $Enums.SubscriptionCategory | null
    price: number | null
    feature: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: number | null
    category: $Enums.SubscriptionCategory | null
    price: number | null
    feature: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    category: number
    price: number
    feature: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type SubscriptionSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    category?: true
    price?: true
    feature?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    category?: true
    price?: true
    feature?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    category?: true
    price?: true
    feature?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: number
    category: $Enums.SubscriptionCategory
    price: number
    feature: string
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    price?: boolean
    feature?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Transaction?: boolean | Subscription$TransactionArgs<ExtArgs>
    UserSubscription?: boolean | Subscription$UserSubscriptionArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    price?: boolean
    feature?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    price?: boolean
    feature?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    category?: boolean
    price?: boolean
    feature?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "price" | "feature" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Transaction?: boolean | Subscription$TransactionArgs<ExtArgs>
    UserSubscription?: boolean | Subscription$UserSubscriptionArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
      UserSubscription: Prisma.$UserSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      category: $Enums.SubscriptionCategory
      price: number
      feature: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Transaction<T extends Subscription$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    UserSubscription<T extends Subscription$UserSubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$UserSubscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'Int'>
    readonly category: FieldRef<"Subscription", 'SubscriptionCategory'>
    readonly price: FieldRef<"Subscription", 'Int'>
    readonly feature: FieldRef<"Subscription", 'String'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription.Transaction
   */
  export type Subscription$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Subscription.UserSubscription
   */
  export type Subscription$UserSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    where?: UserSubscriptionWhereInput
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    cursor?: UserSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model PreSelectionTest
   */

  export type AggregatePreSelectionTest = {
    _count: PreSelectionTestCountAggregateOutputType | null
    _avg: PreSelectionTestAvgAggregateOutputType | null
    _sum: PreSelectionTestSumAggregateOutputType | null
    _min: PreSelectionTestMinAggregateOutputType | null
    _max: PreSelectionTestMaxAggregateOutputType | null
  }

  export type PreSelectionTestAvgAggregateOutputType = {
    id: number | null
  }

  export type PreSelectionTestSumAggregateOutputType = {
    id: number | null
  }

  export type PreSelectionTestMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    jobId: string | null
    createdAt: Date | null
  }

  export type PreSelectionTestMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    jobId: string | null
    createdAt: Date | null
  }

  export type PreSelectionTestCountAggregateOutputType = {
    id: number
    title: number
    description: number
    jobId: number
    createdAt: number
    _all: number
  }


  export type PreSelectionTestAvgAggregateInputType = {
    id?: true
  }

  export type PreSelectionTestSumAggregateInputType = {
    id?: true
  }

  export type PreSelectionTestMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    jobId?: true
    createdAt?: true
  }

  export type PreSelectionTestMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    jobId?: true
    createdAt?: true
  }

  export type PreSelectionTestCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    jobId?: true
    createdAt?: true
    _all?: true
  }

  export type PreSelectionTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PreSelectionTest to aggregate.
     */
    where?: PreSelectionTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreSelectionTests to fetch.
     */
    orderBy?: PreSelectionTestOrderByWithRelationInput | PreSelectionTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PreSelectionTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreSelectionTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreSelectionTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PreSelectionTests
    **/
    _count?: true | PreSelectionTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreSelectionTestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreSelectionTestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreSelectionTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreSelectionTestMaxAggregateInputType
  }

  export type GetPreSelectionTestAggregateType<T extends PreSelectionTestAggregateArgs> = {
        [P in keyof T & keyof AggregatePreSelectionTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreSelectionTest[P]>
      : GetScalarType<T[P], AggregatePreSelectionTest[P]>
  }




  export type PreSelectionTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreSelectionTestWhereInput
    orderBy?: PreSelectionTestOrderByWithAggregationInput | PreSelectionTestOrderByWithAggregationInput[]
    by: PreSelectionTestScalarFieldEnum[] | PreSelectionTestScalarFieldEnum
    having?: PreSelectionTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreSelectionTestCountAggregateInputType | true
    _avg?: PreSelectionTestAvgAggregateInputType
    _sum?: PreSelectionTestSumAggregateInputType
    _min?: PreSelectionTestMinAggregateInputType
    _max?: PreSelectionTestMaxAggregateInputType
  }

  export type PreSelectionTestGroupByOutputType = {
    id: number
    title: string
    description: string
    jobId: string
    createdAt: Date
    _count: PreSelectionTestCountAggregateOutputType | null
    _avg: PreSelectionTestAvgAggregateOutputType | null
    _sum: PreSelectionTestSumAggregateOutputType | null
    _min: PreSelectionTestMinAggregateOutputType | null
    _max: PreSelectionTestMaxAggregateOutputType | null
  }

  type GetPreSelectionTestGroupByPayload<T extends PreSelectionTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreSelectionTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreSelectionTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreSelectionTestGroupByOutputType[P]>
            : GetScalarType<T[P], PreSelectionTestGroupByOutputType[P]>
        }
      >
    >


  export type PreSelectionTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    jobId?: boolean
    createdAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
    SelectionTestQuestion?: boolean | PreSelectionTest$SelectionTestQuestionArgs<ExtArgs>
    _count?: boolean | PreSelectionTestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preSelectionTest"]>

  export type PreSelectionTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    jobId?: boolean
    createdAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preSelectionTest"]>

  export type PreSelectionTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    jobId?: boolean
    createdAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preSelectionTest"]>

  export type PreSelectionTestSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    jobId?: boolean
    createdAt?: boolean
  }

  export type PreSelectionTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "jobId" | "createdAt", ExtArgs["result"]["preSelectionTest"]>
  export type PreSelectionTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
    SelectionTestQuestion?: boolean | PreSelectionTest$SelectionTestQuestionArgs<ExtArgs>
    _count?: boolean | PreSelectionTestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PreSelectionTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }
  export type PreSelectionTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }

  export type $PreSelectionTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PreSelectionTest"
    objects: {
      job: Prisma.$JobPayload<ExtArgs>
      SelectionTestQuestion: Prisma.$SelectionTestQuestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      jobId: string
      createdAt: Date
    }, ExtArgs["result"]["preSelectionTest"]>
    composites: {}
  }

  type PreSelectionTestGetPayload<S extends boolean | null | undefined | PreSelectionTestDefaultArgs> = $Result.GetResult<Prisma.$PreSelectionTestPayload, S>

  type PreSelectionTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PreSelectionTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PreSelectionTestCountAggregateInputType | true
    }

  export interface PreSelectionTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PreSelectionTest'], meta: { name: 'PreSelectionTest' } }
    /**
     * Find zero or one PreSelectionTest that matches the filter.
     * @param {PreSelectionTestFindUniqueArgs} args - Arguments to find a PreSelectionTest
     * @example
     * // Get one PreSelectionTest
     * const preSelectionTest = await prisma.preSelectionTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PreSelectionTestFindUniqueArgs>(args: SelectSubset<T, PreSelectionTestFindUniqueArgs<ExtArgs>>): Prisma__PreSelectionTestClient<$Result.GetResult<Prisma.$PreSelectionTestPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PreSelectionTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PreSelectionTestFindUniqueOrThrowArgs} args - Arguments to find a PreSelectionTest
     * @example
     * // Get one PreSelectionTest
     * const preSelectionTest = await prisma.preSelectionTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PreSelectionTestFindUniqueOrThrowArgs>(args: SelectSubset<T, PreSelectionTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PreSelectionTestClient<$Result.GetResult<Prisma.$PreSelectionTestPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PreSelectionTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreSelectionTestFindFirstArgs} args - Arguments to find a PreSelectionTest
     * @example
     * // Get one PreSelectionTest
     * const preSelectionTest = await prisma.preSelectionTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PreSelectionTestFindFirstArgs>(args?: SelectSubset<T, PreSelectionTestFindFirstArgs<ExtArgs>>): Prisma__PreSelectionTestClient<$Result.GetResult<Prisma.$PreSelectionTestPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PreSelectionTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreSelectionTestFindFirstOrThrowArgs} args - Arguments to find a PreSelectionTest
     * @example
     * // Get one PreSelectionTest
     * const preSelectionTest = await prisma.preSelectionTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PreSelectionTestFindFirstOrThrowArgs>(args?: SelectSubset<T, PreSelectionTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__PreSelectionTestClient<$Result.GetResult<Prisma.$PreSelectionTestPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PreSelectionTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreSelectionTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PreSelectionTests
     * const preSelectionTests = await prisma.preSelectionTest.findMany()
     * 
     * // Get first 10 PreSelectionTests
     * const preSelectionTests = await prisma.preSelectionTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preSelectionTestWithIdOnly = await prisma.preSelectionTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PreSelectionTestFindManyArgs>(args?: SelectSubset<T, PreSelectionTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreSelectionTestPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PreSelectionTest.
     * @param {PreSelectionTestCreateArgs} args - Arguments to create a PreSelectionTest.
     * @example
     * // Create one PreSelectionTest
     * const PreSelectionTest = await prisma.preSelectionTest.create({
     *   data: {
     *     // ... data to create a PreSelectionTest
     *   }
     * })
     * 
     */
    create<T extends PreSelectionTestCreateArgs>(args: SelectSubset<T, PreSelectionTestCreateArgs<ExtArgs>>): Prisma__PreSelectionTestClient<$Result.GetResult<Prisma.$PreSelectionTestPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PreSelectionTests.
     * @param {PreSelectionTestCreateManyArgs} args - Arguments to create many PreSelectionTests.
     * @example
     * // Create many PreSelectionTests
     * const preSelectionTest = await prisma.preSelectionTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PreSelectionTestCreateManyArgs>(args?: SelectSubset<T, PreSelectionTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PreSelectionTests and returns the data saved in the database.
     * @param {PreSelectionTestCreateManyAndReturnArgs} args - Arguments to create many PreSelectionTests.
     * @example
     * // Create many PreSelectionTests
     * const preSelectionTest = await prisma.preSelectionTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PreSelectionTests and only return the `id`
     * const preSelectionTestWithIdOnly = await prisma.preSelectionTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PreSelectionTestCreateManyAndReturnArgs>(args?: SelectSubset<T, PreSelectionTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreSelectionTestPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a PreSelectionTest.
     * @param {PreSelectionTestDeleteArgs} args - Arguments to delete one PreSelectionTest.
     * @example
     * // Delete one PreSelectionTest
     * const PreSelectionTest = await prisma.preSelectionTest.delete({
     *   where: {
     *     // ... filter to delete one PreSelectionTest
     *   }
     * })
     * 
     */
    delete<T extends PreSelectionTestDeleteArgs>(args: SelectSubset<T, PreSelectionTestDeleteArgs<ExtArgs>>): Prisma__PreSelectionTestClient<$Result.GetResult<Prisma.$PreSelectionTestPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PreSelectionTest.
     * @param {PreSelectionTestUpdateArgs} args - Arguments to update one PreSelectionTest.
     * @example
     * // Update one PreSelectionTest
     * const preSelectionTest = await prisma.preSelectionTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PreSelectionTestUpdateArgs>(args: SelectSubset<T, PreSelectionTestUpdateArgs<ExtArgs>>): Prisma__PreSelectionTestClient<$Result.GetResult<Prisma.$PreSelectionTestPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PreSelectionTests.
     * @param {PreSelectionTestDeleteManyArgs} args - Arguments to filter PreSelectionTests to delete.
     * @example
     * // Delete a few PreSelectionTests
     * const { count } = await prisma.preSelectionTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PreSelectionTestDeleteManyArgs>(args?: SelectSubset<T, PreSelectionTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreSelectionTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreSelectionTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PreSelectionTests
     * const preSelectionTest = await prisma.preSelectionTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PreSelectionTestUpdateManyArgs>(args: SelectSubset<T, PreSelectionTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreSelectionTests and returns the data updated in the database.
     * @param {PreSelectionTestUpdateManyAndReturnArgs} args - Arguments to update many PreSelectionTests.
     * @example
     * // Update many PreSelectionTests
     * const preSelectionTest = await prisma.preSelectionTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PreSelectionTests and only return the `id`
     * const preSelectionTestWithIdOnly = await prisma.preSelectionTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PreSelectionTestUpdateManyAndReturnArgs>(args: SelectSubset<T, PreSelectionTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreSelectionTestPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one PreSelectionTest.
     * @param {PreSelectionTestUpsertArgs} args - Arguments to update or create a PreSelectionTest.
     * @example
     * // Update or create a PreSelectionTest
     * const preSelectionTest = await prisma.preSelectionTest.upsert({
     *   create: {
     *     // ... data to create a PreSelectionTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PreSelectionTest we want to update
     *   }
     * })
     */
    upsert<T extends PreSelectionTestUpsertArgs>(args: SelectSubset<T, PreSelectionTestUpsertArgs<ExtArgs>>): Prisma__PreSelectionTestClient<$Result.GetResult<Prisma.$PreSelectionTestPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PreSelectionTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreSelectionTestCountArgs} args - Arguments to filter PreSelectionTests to count.
     * @example
     * // Count the number of PreSelectionTests
     * const count = await prisma.preSelectionTest.count({
     *   where: {
     *     // ... the filter for the PreSelectionTests we want to count
     *   }
     * })
    **/
    count<T extends PreSelectionTestCountArgs>(
      args?: Subset<T, PreSelectionTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreSelectionTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PreSelectionTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreSelectionTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreSelectionTestAggregateArgs>(args: Subset<T, PreSelectionTestAggregateArgs>): Prisma.PrismaPromise<GetPreSelectionTestAggregateType<T>>

    /**
     * Group by PreSelectionTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreSelectionTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreSelectionTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreSelectionTestGroupByArgs['orderBy'] }
        : { orderBy?: PreSelectionTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreSelectionTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreSelectionTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PreSelectionTest model
   */
  readonly fields: PreSelectionTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PreSelectionTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PreSelectionTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    SelectionTestQuestion<T extends PreSelectionTest$SelectionTestQuestionArgs<ExtArgs> = {}>(args?: Subset<T, PreSelectionTest$SelectionTestQuestionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelectionTestQuestionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PreSelectionTest model
   */ 
  interface PreSelectionTestFieldRefs {
    readonly id: FieldRef<"PreSelectionTest", 'Int'>
    readonly title: FieldRef<"PreSelectionTest", 'String'>
    readonly description: FieldRef<"PreSelectionTest", 'String'>
    readonly jobId: FieldRef<"PreSelectionTest", 'String'>
    readonly createdAt: FieldRef<"PreSelectionTest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PreSelectionTest findUnique
   */
  export type PreSelectionTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreSelectionTest
     */
    select?: PreSelectionTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreSelectionTest
     */
    omit?: PreSelectionTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreSelectionTestInclude<ExtArgs> | null
    /**
     * Filter, which PreSelectionTest to fetch.
     */
    where: PreSelectionTestWhereUniqueInput
  }

  /**
   * PreSelectionTest findUniqueOrThrow
   */
  export type PreSelectionTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreSelectionTest
     */
    select?: PreSelectionTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreSelectionTest
     */
    omit?: PreSelectionTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreSelectionTestInclude<ExtArgs> | null
    /**
     * Filter, which PreSelectionTest to fetch.
     */
    where: PreSelectionTestWhereUniqueInput
  }

  /**
   * PreSelectionTest findFirst
   */
  export type PreSelectionTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreSelectionTest
     */
    select?: PreSelectionTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreSelectionTest
     */
    omit?: PreSelectionTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreSelectionTestInclude<ExtArgs> | null
    /**
     * Filter, which PreSelectionTest to fetch.
     */
    where?: PreSelectionTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreSelectionTests to fetch.
     */
    orderBy?: PreSelectionTestOrderByWithRelationInput | PreSelectionTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PreSelectionTests.
     */
    cursor?: PreSelectionTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreSelectionTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreSelectionTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PreSelectionTests.
     */
    distinct?: PreSelectionTestScalarFieldEnum | PreSelectionTestScalarFieldEnum[]
  }

  /**
   * PreSelectionTest findFirstOrThrow
   */
  export type PreSelectionTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreSelectionTest
     */
    select?: PreSelectionTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreSelectionTest
     */
    omit?: PreSelectionTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreSelectionTestInclude<ExtArgs> | null
    /**
     * Filter, which PreSelectionTest to fetch.
     */
    where?: PreSelectionTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreSelectionTests to fetch.
     */
    orderBy?: PreSelectionTestOrderByWithRelationInput | PreSelectionTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PreSelectionTests.
     */
    cursor?: PreSelectionTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreSelectionTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreSelectionTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PreSelectionTests.
     */
    distinct?: PreSelectionTestScalarFieldEnum | PreSelectionTestScalarFieldEnum[]
  }

  /**
   * PreSelectionTest findMany
   */
  export type PreSelectionTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreSelectionTest
     */
    select?: PreSelectionTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreSelectionTest
     */
    omit?: PreSelectionTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreSelectionTestInclude<ExtArgs> | null
    /**
     * Filter, which PreSelectionTests to fetch.
     */
    where?: PreSelectionTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreSelectionTests to fetch.
     */
    orderBy?: PreSelectionTestOrderByWithRelationInput | PreSelectionTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PreSelectionTests.
     */
    cursor?: PreSelectionTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreSelectionTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreSelectionTests.
     */
    skip?: number
    distinct?: PreSelectionTestScalarFieldEnum | PreSelectionTestScalarFieldEnum[]
  }

  /**
   * PreSelectionTest create
   */
  export type PreSelectionTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreSelectionTest
     */
    select?: PreSelectionTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreSelectionTest
     */
    omit?: PreSelectionTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreSelectionTestInclude<ExtArgs> | null
    /**
     * The data needed to create a PreSelectionTest.
     */
    data: XOR<PreSelectionTestCreateInput, PreSelectionTestUncheckedCreateInput>
  }

  /**
   * PreSelectionTest createMany
   */
  export type PreSelectionTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PreSelectionTests.
     */
    data: PreSelectionTestCreateManyInput | PreSelectionTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PreSelectionTest createManyAndReturn
   */
  export type PreSelectionTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreSelectionTest
     */
    select?: PreSelectionTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PreSelectionTest
     */
    omit?: PreSelectionTestOmit<ExtArgs> | null
    /**
     * The data used to create many PreSelectionTests.
     */
    data: PreSelectionTestCreateManyInput | PreSelectionTestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreSelectionTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PreSelectionTest update
   */
  export type PreSelectionTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreSelectionTest
     */
    select?: PreSelectionTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreSelectionTest
     */
    omit?: PreSelectionTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreSelectionTestInclude<ExtArgs> | null
    /**
     * The data needed to update a PreSelectionTest.
     */
    data: XOR<PreSelectionTestUpdateInput, PreSelectionTestUncheckedUpdateInput>
    /**
     * Choose, which PreSelectionTest to update.
     */
    where: PreSelectionTestWhereUniqueInput
  }

  /**
   * PreSelectionTest updateMany
   */
  export type PreSelectionTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PreSelectionTests.
     */
    data: XOR<PreSelectionTestUpdateManyMutationInput, PreSelectionTestUncheckedUpdateManyInput>
    /**
     * Filter which PreSelectionTests to update
     */
    where?: PreSelectionTestWhereInput
  }

  /**
   * PreSelectionTest updateManyAndReturn
   */
  export type PreSelectionTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreSelectionTest
     */
    select?: PreSelectionTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PreSelectionTest
     */
    omit?: PreSelectionTestOmit<ExtArgs> | null
    /**
     * The data used to update PreSelectionTests.
     */
    data: XOR<PreSelectionTestUpdateManyMutationInput, PreSelectionTestUncheckedUpdateManyInput>
    /**
     * Filter which PreSelectionTests to update
     */
    where?: PreSelectionTestWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreSelectionTestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PreSelectionTest upsert
   */
  export type PreSelectionTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreSelectionTest
     */
    select?: PreSelectionTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreSelectionTest
     */
    omit?: PreSelectionTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreSelectionTestInclude<ExtArgs> | null
    /**
     * The filter to search for the PreSelectionTest to update in case it exists.
     */
    where: PreSelectionTestWhereUniqueInput
    /**
     * In case the PreSelectionTest found by the `where` argument doesn't exist, create a new PreSelectionTest with this data.
     */
    create: XOR<PreSelectionTestCreateInput, PreSelectionTestUncheckedCreateInput>
    /**
     * In case the PreSelectionTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PreSelectionTestUpdateInput, PreSelectionTestUncheckedUpdateInput>
  }

  /**
   * PreSelectionTest delete
   */
  export type PreSelectionTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreSelectionTest
     */
    select?: PreSelectionTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreSelectionTest
     */
    omit?: PreSelectionTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreSelectionTestInclude<ExtArgs> | null
    /**
     * Filter which PreSelectionTest to delete.
     */
    where: PreSelectionTestWhereUniqueInput
  }

  /**
   * PreSelectionTest deleteMany
   */
  export type PreSelectionTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PreSelectionTests to delete
     */
    where?: PreSelectionTestWhereInput
  }

  /**
   * PreSelectionTest.SelectionTestQuestion
   */
  export type PreSelectionTest$SelectionTestQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionTestQuestion
     */
    select?: SelectionTestQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionTestQuestion
     */
    omit?: SelectionTestQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionTestQuestionInclude<ExtArgs> | null
    where?: SelectionTestQuestionWhereInput
    orderBy?: SelectionTestQuestionOrderByWithRelationInput | SelectionTestQuestionOrderByWithRelationInput[]
    cursor?: SelectionTestQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SelectionTestQuestionScalarFieldEnum | SelectionTestQuestionScalarFieldEnum[]
  }

  /**
   * PreSelectionTest without action
   */
  export type PreSelectionTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreSelectionTest
     */
    select?: PreSelectionTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreSelectionTest
     */
    omit?: PreSelectionTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreSelectionTestInclude<ExtArgs> | null
  }


  /**
   * Model SelectionTestQuestion
   */

  export type AggregateSelectionTestQuestion = {
    _count: SelectionTestQuestionCountAggregateOutputType | null
    _avg: SelectionTestQuestionAvgAggregateOutputType | null
    _sum: SelectionTestQuestionSumAggregateOutputType | null
    _min: SelectionTestQuestionMinAggregateOutputType | null
    _max: SelectionTestQuestionMaxAggregateOutputType | null
  }

  export type SelectionTestQuestionAvgAggregateOutputType = {
    id: number | null
    preSelectionTestId: number | null
    correctAnswer: number | null
  }

  export type SelectionTestQuestionSumAggregateOutputType = {
    id: number | null
    preSelectionTestId: number | null
    correctAnswer: number | null
  }

  export type SelectionTestQuestionMinAggregateOutputType = {
    id: number | null
    preSelectionTestId: number | null
    question: string | null
    correctAnswer: number | null
  }

  export type SelectionTestQuestionMaxAggregateOutputType = {
    id: number | null
    preSelectionTestId: number | null
    question: string | null
    correctAnswer: number | null
  }

  export type SelectionTestQuestionCountAggregateOutputType = {
    id: number
    preSelectionTestId: number
    question: number
    options: number
    correctAnswer: number
    _all: number
  }


  export type SelectionTestQuestionAvgAggregateInputType = {
    id?: true
    preSelectionTestId?: true
    correctAnswer?: true
  }

  export type SelectionTestQuestionSumAggregateInputType = {
    id?: true
    preSelectionTestId?: true
    correctAnswer?: true
  }

  export type SelectionTestQuestionMinAggregateInputType = {
    id?: true
    preSelectionTestId?: true
    question?: true
    correctAnswer?: true
  }

  export type SelectionTestQuestionMaxAggregateInputType = {
    id?: true
    preSelectionTestId?: true
    question?: true
    correctAnswer?: true
  }

  export type SelectionTestQuestionCountAggregateInputType = {
    id?: true
    preSelectionTestId?: true
    question?: true
    options?: true
    correctAnswer?: true
    _all?: true
  }

  export type SelectionTestQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SelectionTestQuestion to aggregate.
     */
    where?: SelectionTestQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelectionTestQuestions to fetch.
     */
    orderBy?: SelectionTestQuestionOrderByWithRelationInput | SelectionTestQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SelectionTestQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelectionTestQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelectionTestQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SelectionTestQuestions
    **/
    _count?: true | SelectionTestQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SelectionTestQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SelectionTestQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SelectionTestQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SelectionTestQuestionMaxAggregateInputType
  }

  export type GetSelectionTestQuestionAggregateType<T extends SelectionTestQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateSelectionTestQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSelectionTestQuestion[P]>
      : GetScalarType<T[P], AggregateSelectionTestQuestion[P]>
  }




  export type SelectionTestQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SelectionTestQuestionWhereInput
    orderBy?: SelectionTestQuestionOrderByWithAggregationInput | SelectionTestQuestionOrderByWithAggregationInput[]
    by: SelectionTestQuestionScalarFieldEnum[] | SelectionTestQuestionScalarFieldEnum
    having?: SelectionTestQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SelectionTestQuestionCountAggregateInputType | true
    _avg?: SelectionTestQuestionAvgAggregateInputType
    _sum?: SelectionTestQuestionSumAggregateInputType
    _min?: SelectionTestQuestionMinAggregateInputType
    _max?: SelectionTestQuestionMaxAggregateInputType
  }

  export type SelectionTestQuestionGroupByOutputType = {
    id: number
    preSelectionTestId: number
    question: string
    options: string[]
    correctAnswer: number
    _count: SelectionTestQuestionCountAggregateOutputType | null
    _avg: SelectionTestQuestionAvgAggregateOutputType | null
    _sum: SelectionTestQuestionSumAggregateOutputType | null
    _min: SelectionTestQuestionMinAggregateOutputType | null
    _max: SelectionTestQuestionMaxAggregateOutputType | null
  }

  type GetSelectionTestQuestionGroupByPayload<T extends SelectionTestQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SelectionTestQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SelectionTestQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SelectionTestQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], SelectionTestQuestionGroupByOutputType[P]>
        }
      >
    >


  export type SelectionTestQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    preSelectionTestId?: boolean
    question?: boolean
    options?: boolean
    correctAnswer?: boolean
    preSelectionTest?: boolean | PreSelectionTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["selectionTestQuestion"]>

  export type SelectionTestQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    preSelectionTestId?: boolean
    question?: boolean
    options?: boolean
    correctAnswer?: boolean
    preSelectionTest?: boolean | PreSelectionTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["selectionTestQuestion"]>

  export type SelectionTestQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    preSelectionTestId?: boolean
    question?: boolean
    options?: boolean
    correctAnswer?: boolean
    preSelectionTest?: boolean | PreSelectionTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["selectionTestQuestion"]>

  export type SelectionTestQuestionSelectScalar = {
    id?: boolean
    preSelectionTestId?: boolean
    question?: boolean
    options?: boolean
    correctAnswer?: boolean
  }

  export type SelectionTestQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "preSelectionTestId" | "question" | "options" | "correctAnswer", ExtArgs["result"]["selectionTestQuestion"]>
  export type SelectionTestQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preSelectionTest?: boolean | PreSelectionTestDefaultArgs<ExtArgs>
  }
  export type SelectionTestQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preSelectionTest?: boolean | PreSelectionTestDefaultArgs<ExtArgs>
  }
  export type SelectionTestQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preSelectionTest?: boolean | PreSelectionTestDefaultArgs<ExtArgs>
  }

  export type $SelectionTestQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SelectionTestQuestion"
    objects: {
      preSelectionTest: Prisma.$PreSelectionTestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      preSelectionTestId: number
      question: string
      options: string[]
      correctAnswer: number
    }, ExtArgs["result"]["selectionTestQuestion"]>
    composites: {}
  }

  type SelectionTestQuestionGetPayload<S extends boolean | null | undefined | SelectionTestQuestionDefaultArgs> = $Result.GetResult<Prisma.$SelectionTestQuestionPayload, S>

  type SelectionTestQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SelectionTestQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SelectionTestQuestionCountAggregateInputType | true
    }

  export interface SelectionTestQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SelectionTestQuestion'], meta: { name: 'SelectionTestQuestion' } }
    /**
     * Find zero or one SelectionTestQuestion that matches the filter.
     * @param {SelectionTestQuestionFindUniqueArgs} args - Arguments to find a SelectionTestQuestion
     * @example
     * // Get one SelectionTestQuestion
     * const selectionTestQuestion = await prisma.selectionTestQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SelectionTestQuestionFindUniqueArgs>(args: SelectSubset<T, SelectionTestQuestionFindUniqueArgs<ExtArgs>>): Prisma__SelectionTestQuestionClient<$Result.GetResult<Prisma.$SelectionTestQuestionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SelectionTestQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SelectionTestQuestionFindUniqueOrThrowArgs} args - Arguments to find a SelectionTestQuestion
     * @example
     * // Get one SelectionTestQuestion
     * const selectionTestQuestion = await prisma.selectionTestQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SelectionTestQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, SelectionTestQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SelectionTestQuestionClient<$Result.GetResult<Prisma.$SelectionTestQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SelectionTestQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelectionTestQuestionFindFirstArgs} args - Arguments to find a SelectionTestQuestion
     * @example
     * // Get one SelectionTestQuestion
     * const selectionTestQuestion = await prisma.selectionTestQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SelectionTestQuestionFindFirstArgs>(args?: SelectSubset<T, SelectionTestQuestionFindFirstArgs<ExtArgs>>): Prisma__SelectionTestQuestionClient<$Result.GetResult<Prisma.$SelectionTestQuestionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SelectionTestQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelectionTestQuestionFindFirstOrThrowArgs} args - Arguments to find a SelectionTestQuestion
     * @example
     * // Get one SelectionTestQuestion
     * const selectionTestQuestion = await prisma.selectionTestQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SelectionTestQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, SelectionTestQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SelectionTestQuestionClient<$Result.GetResult<Prisma.$SelectionTestQuestionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SelectionTestQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelectionTestQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SelectionTestQuestions
     * const selectionTestQuestions = await prisma.selectionTestQuestion.findMany()
     * 
     * // Get first 10 SelectionTestQuestions
     * const selectionTestQuestions = await prisma.selectionTestQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const selectionTestQuestionWithIdOnly = await prisma.selectionTestQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SelectionTestQuestionFindManyArgs>(args?: SelectSubset<T, SelectionTestQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelectionTestQuestionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SelectionTestQuestion.
     * @param {SelectionTestQuestionCreateArgs} args - Arguments to create a SelectionTestQuestion.
     * @example
     * // Create one SelectionTestQuestion
     * const SelectionTestQuestion = await prisma.selectionTestQuestion.create({
     *   data: {
     *     // ... data to create a SelectionTestQuestion
     *   }
     * })
     * 
     */
    create<T extends SelectionTestQuestionCreateArgs>(args: SelectSubset<T, SelectionTestQuestionCreateArgs<ExtArgs>>): Prisma__SelectionTestQuestionClient<$Result.GetResult<Prisma.$SelectionTestQuestionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SelectionTestQuestions.
     * @param {SelectionTestQuestionCreateManyArgs} args - Arguments to create many SelectionTestQuestions.
     * @example
     * // Create many SelectionTestQuestions
     * const selectionTestQuestion = await prisma.selectionTestQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SelectionTestQuestionCreateManyArgs>(args?: SelectSubset<T, SelectionTestQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SelectionTestQuestions and returns the data saved in the database.
     * @param {SelectionTestQuestionCreateManyAndReturnArgs} args - Arguments to create many SelectionTestQuestions.
     * @example
     * // Create many SelectionTestQuestions
     * const selectionTestQuestion = await prisma.selectionTestQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SelectionTestQuestions and only return the `id`
     * const selectionTestQuestionWithIdOnly = await prisma.selectionTestQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SelectionTestQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, SelectionTestQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelectionTestQuestionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a SelectionTestQuestion.
     * @param {SelectionTestQuestionDeleteArgs} args - Arguments to delete one SelectionTestQuestion.
     * @example
     * // Delete one SelectionTestQuestion
     * const SelectionTestQuestion = await prisma.selectionTestQuestion.delete({
     *   where: {
     *     // ... filter to delete one SelectionTestQuestion
     *   }
     * })
     * 
     */
    delete<T extends SelectionTestQuestionDeleteArgs>(args: SelectSubset<T, SelectionTestQuestionDeleteArgs<ExtArgs>>): Prisma__SelectionTestQuestionClient<$Result.GetResult<Prisma.$SelectionTestQuestionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SelectionTestQuestion.
     * @param {SelectionTestQuestionUpdateArgs} args - Arguments to update one SelectionTestQuestion.
     * @example
     * // Update one SelectionTestQuestion
     * const selectionTestQuestion = await prisma.selectionTestQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SelectionTestQuestionUpdateArgs>(args: SelectSubset<T, SelectionTestQuestionUpdateArgs<ExtArgs>>): Prisma__SelectionTestQuestionClient<$Result.GetResult<Prisma.$SelectionTestQuestionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SelectionTestQuestions.
     * @param {SelectionTestQuestionDeleteManyArgs} args - Arguments to filter SelectionTestQuestions to delete.
     * @example
     * // Delete a few SelectionTestQuestions
     * const { count } = await prisma.selectionTestQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SelectionTestQuestionDeleteManyArgs>(args?: SelectSubset<T, SelectionTestQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SelectionTestQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelectionTestQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SelectionTestQuestions
     * const selectionTestQuestion = await prisma.selectionTestQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SelectionTestQuestionUpdateManyArgs>(args: SelectSubset<T, SelectionTestQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SelectionTestQuestions and returns the data updated in the database.
     * @param {SelectionTestQuestionUpdateManyAndReturnArgs} args - Arguments to update many SelectionTestQuestions.
     * @example
     * // Update many SelectionTestQuestions
     * const selectionTestQuestion = await prisma.selectionTestQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SelectionTestQuestions and only return the `id`
     * const selectionTestQuestionWithIdOnly = await prisma.selectionTestQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SelectionTestQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, SelectionTestQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelectionTestQuestionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one SelectionTestQuestion.
     * @param {SelectionTestQuestionUpsertArgs} args - Arguments to update or create a SelectionTestQuestion.
     * @example
     * // Update or create a SelectionTestQuestion
     * const selectionTestQuestion = await prisma.selectionTestQuestion.upsert({
     *   create: {
     *     // ... data to create a SelectionTestQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SelectionTestQuestion we want to update
     *   }
     * })
     */
    upsert<T extends SelectionTestQuestionUpsertArgs>(args: SelectSubset<T, SelectionTestQuestionUpsertArgs<ExtArgs>>): Prisma__SelectionTestQuestionClient<$Result.GetResult<Prisma.$SelectionTestQuestionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SelectionTestQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelectionTestQuestionCountArgs} args - Arguments to filter SelectionTestQuestions to count.
     * @example
     * // Count the number of SelectionTestQuestions
     * const count = await prisma.selectionTestQuestion.count({
     *   where: {
     *     // ... the filter for the SelectionTestQuestions we want to count
     *   }
     * })
    **/
    count<T extends SelectionTestQuestionCountArgs>(
      args?: Subset<T, SelectionTestQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SelectionTestQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SelectionTestQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelectionTestQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SelectionTestQuestionAggregateArgs>(args: Subset<T, SelectionTestQuestionAggregateArgs>): Prisma.PrismaPromise<GetSelectionTestQuestionAggregateType<T>>

    /**
     * Group by SelectionTestQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelectionTestQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SelectionTestQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SelectionTestQuestionGroupByArgs['orderBy'] }
        : { orderBy?: SelectionTestQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SelectionTestQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSelectionTestQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SelectionTestQuestion model
   */
  readonly fields: SelectionTestQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SelectionTestQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SelectionTestQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    preSelectionTest<T extends PreSelectionTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PreSelectionTestDefaultArgs<ExtArgs>>): Prisma__PreSelectionTestClient<$Result.GetResult<Prisma.$PreSelectionTestPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SelectionTestQuestion model
   */ 
  interface SelectionTestQuestionFieldRefs {
    readonly id: FieldRef<"SelectionTestQuestion", 'Int'>
    readonly preSelectionTestId: FieldRef<"SelectionTestQuestion", 'Int'>
    readonly question: FieldRef<"SelectionTestQuestion", 'String'>
    readonly options: FieldRef<"SelectionTestQuestion", 'String[]'>
    readonly correctAnswer: FieldRef<"SelectionTestQuestion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SelectionTestQuestion findUnique
   */
  export type SelectionTestQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionTestQuestion
     */
    select?: SelectionTestQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionTestQuestion
     */
    omit?: SelectionTestQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionTestQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SelectionTestQuestion to fetch.
     */
    where: SelectionTestQuestionWhereUniqueInput
  }

  /**
   * SelectionTestQuestion findUniqueOrThrow
   */
  export type SelectionTestQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionTestQuestion
     */
    select?: SelectionTestQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionTestQuestion
     */
    omit?: SelectionTestQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionTestQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SelectionTestQuestion to fetch.
     */
    where: SelectionTestQuestionWhereUniqueInput
  }

  /**
   * SelectionTestQuestion findFirst
   */
  export type SelectionTestQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionTestQuestion
     */
    select?: SelectionTestQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionTestQuestion
     */
    omit?: SelectionTestQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionTestQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SelectionTestQuestion to fetch.
     */
    where?: SelectionTestQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelectionTestQuestions to fetch.
     */
    orderBy?: SelectionTestQuestionOrderByWithRelationInput | SelectionTestQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SelectionTestQuestions.
     */
    cursor?: SelectionTestQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelectionTestQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelectionTestQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SelectionTestQuestions.
     */
    distinct?: SelectionTestQuestionScalarFieldEnum | SelectionTestQuestionScalarFieldEnum[]
  }

  /**
   * SelectionTestQuestion findFirstOrThrow
   */
  export type SelectionTestQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionTestQuestion
     */
    select?: SelectionTestQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionTestQuestion
     */
    omit?: SelectionTestQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionTestQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SelectionTestQuestion to fetch.
     */
    where?: SelectionTestQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelectionTestQuestions to fetch.
     */
    orderBy?: SelectionTestQuestionOrderByWithRelationInput | SelectionTestQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SelectionTestQuestions.
     */
    cursor?: SelectionTestQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelectionTestQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelectionTestQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SelectionTestQuestions.
     */
    distinct?: SelectionTestQuestionScalarFieldEnum | SelectionTestQuestionScalarFieldEnum[]
  }

  /**
   * SelectionTestQuestion findMany
   */
  export type SelectionTestQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionTestQuestion
     */
    select?: SelectionTestQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionTestQuestion
     */
    omit?: SelectionTestQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionTestQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SelectionTestQuestions to fetch.
     */
    where?: SelectionTestQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelectionTestQuestions to fetch.
     */
    orderBy?: SelectionTestQuestionOrderByWithRelationInput | SelectionTestQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SelectionTestQuestions.
     */
    cursor?: SelectionTestQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelectionTestQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelectionTestQuestions.
     */
    skip?: number
    distinct?: SelectionTestQuestionScalarFieldEnum | SelectionTestQuestionScalarFieldEnum[]
  }

  /**
   * SelectionTestQuestion create
   */
  export type SelectionTestQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionTestQuestion
     */
    select?: SelectionTestQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionTestQuestion
     */
    omit?: SelectionTestQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionTestQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a SelectionTestQuestion.
     */
    data: XOR<SelectionTestQuestionCreateInput, SelectionTestQuestionUncheckedCreateInput>
  }

  /**
   * SelectionTestQuestion createMany
   */
  export type SelectionTestQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SelectionTestQuestions.
     */
    data: SelectionTestQuestionCreateManyInput | SelectionTestQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SelectionTestQuestion createManyAndReturn
   */
  export type SelectionTestQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionTestQuestion
     */
    select?: SelectionTestQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionTestQuestion
     */
    omit?: SelectionTestQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many SelectionTestQuestions.
     */
    data: SelectionTestQuestionCreateManyInput | SelectionTestQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionTestQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SelectionTestQuestion update
   */
  export type SelectionTestQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionTestQuestion
     */
    select?: SelectionTestQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionTestQuestion
     */
    omit?: SelectionTestQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionTestQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a SelectionTestQuestion.
     */
    data: XOR<SelectionTestQuestionUpdateInput, SelectionTestQuestionUncheckedUpdateInput>
    /**
     * Choose, which SelectionTestQuestion to update.
     */
    where: SelectionTestQuestionWhereUniqueInput
  }

  /**
   * SelectionTestQuestion updateMany
   */
  export type SelectionTestQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SelectionTestQuestions.
     */
    data: XOR<SelectionTestQuestionUpdateManyMutationInput, SelectionTestQuestionUncheckedUpdateManyInput>
    /**
     * Filter which SelectionTestQuestions to update
     */
    where?: SelectionTestQuestionWhereInput
  }

  /**
   * SelectionTestQuestion updateManyAndReturn
   */
  export type SelectionTestQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionTestQuestion
     */
    select?: SelectionTestQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionTestQuestion
     */
    omit?: SelectionTestQuestionOmit<ExtArgs> | null
    /**
     * The data used to update SelectionTestQuestions.
     */
    data: XOR<SelectionTestQuestionUpdateManyMutationInput, SelectionTestQuestionUncheckedUpdateManyInput>
    /**
     * Filter which SelectionTestQuestions to update
     */
    where?: SelectionTestQuestionWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionTestQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SelectionTestQuestion upsert
   */
  export type SelectionTestQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionTestQuestion
     */
    select?: SelectionTestQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionTestQuestion
     */
    omit?: SelectionTestQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionTestQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the SelectionTestQuestion to update in case it exists.
     */
    where: SelectionTestQuestionWhereUniqueInput
    /**
     * In case the SelectionTestQuestion found by the `where` argument doesn't exist, create a new SelectionTestQuestion with this data.
     */
    create: XOR<SelectionTestQuestionCreateInput, SelectionTestQuestionUncheckedCreateInput>
    /**
     * In case the SelectionTestQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SelectionTestQuestionUpdateInput, SelectionTestQuestionUncheckedUpdateInput>
  }

  /**
   * SelectionTestQuestion delete
   */
  export type SelectionTestQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionTestQuestion
     */
    select?: SelectionTestQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionTestQuestion
     */
    omit?: SelectionTestQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionTestQuestionInclude<ExtArgs> | null
    /**
     * Filter which SelectionTestQuestion to delete.
     */
    where: SelectionTestQuestionWhereUniqueInput
  }

  /**
   * SelectionTestQuestion deleteMany
   */
  export type SelectionTestQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SelectionTestQuestions to delete
     */
    where?: SelectionTestQuestionWhereInput
  }

  /**
   * SelectionTestQuestion without action
   */
  export type SelectionTestQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelectionTestQuestion
     */
    select?: SelectionTestQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelectionTestQuestion
     */
    omit?: SelectionTestQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelectionTestQuestionInclude<ExtArgs> | null
  }


  /**
   * Model JobApplication
   */

  export type AggregateJobApplication = {
    _count: JobApplicationCountAggregateOutputType | null
    _avg: JobApplicationAvgAggregateOutputType | null
    _sum: JobApplicationSumAggregateOutputType | null
    _min: JobApplicationMinAggregateOutputType | null
    _max: JobApplicationMaxAggregateOutputType | null
  }

  export type JobApplicationAvgAggregateOutputType = {
    userId: number | null
    expectedSalary: number | null
    selectionTestResult: number | null
  }

  export type JobApplicationSumAggregateOutputType = {
    userId: number | null
    expectedSalary: number | null
    selectionTestResult: number | null
  }

  export type JobApplicationMinAggregateOutputType = {
    userId: number | null
    jobId: string | null
    resume: string | null
    expectedSalary: number | null
    status: $Enums.JobApplicationStatus | null
    isTaken: boolean | null
    rejectedReview: string | null
    selectionTestResult: number | null
    createdAt: Date | null
  }

  export type JobApplicationMaxAggregateOutputType = {
    userId: number | null
    jobId: string | null
    resume: string | null
    expectedSalary: number | null
    status: $Enums.JobApplicationStatus | null
    isTaken: boolean | null
    rejectedReview: string | null
    selectionTestResult: number | null
    createdAt: Date | null
  }

  export type JobApplicationCountAggregateOutputType = {
    userId: number
    jobId: number
    resume: number
    expectedSalary: number
    status: number
    isTaken: number
    rejectedReview: number
    selectionTestResult: number
    createdAt: number
    _all: number
  }


  export type JobApplicationAvgAggregateInputType = {
    userId?: true
    expectedSalary?: true
    selectionTestResult?: true
  }

  export type JobApplicationSumAggregateInputType = {
    userId?: true
    expectedSalary?: true
    selectionTestResult?: true
  }

  export type JobApplicationMinAggregateInputType = {
    userId?: true
    jobId?: true
    resume?: true
    expectedSalary?: true
    status?: true
    isTaken?: true
    rejectedReview?: true
    selectionTestResult?: true
    createdAt?: true
  }

  export type JobApplicationMaxAggregateInputType = {
    userId?: true
    jobId?: true
    resume?: true
    expectedSalary?: true
    status?: true
    isTaken?: true
    rejectedReview?: true
    selectionTestResult?: true
    createdAt?: true
  }

  export type JobApplicationCountAggregateInputType = {
    userId?: true
    jobId?: true
    resume?: true
    expectedSalary?: true
    status?: true
    isTaken?: true
    rejectedReview?: true
    selectionTestResult?: true
    createdAt?: true
    _all?: true
  }

  export type JobApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobApplication to aggregate.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobApplications
    **/
    _count?: true | JobApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobApplicationMaxAggregateInputType
  }

  export type GetJobApplicationAggregateType<T extends JobApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateJobApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobApplication[P]>
      : GetScalarType<T[P], AggregateJobApplication[P]>
  }




  export type JobApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicationWhereInput
    orderBy?: JobApplicationOrderByWithAggregationInput | JobApplicationOrderByWithAggregationInput[]
    by: JobApplicationScalarFieldEnum[] | JobApplicationScalarFieldEnum
    having?: JobApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobApplicationCountAggregateInputType | true
    _avg?: JobApplicationAvgAggregateInputType
    _sum?: JobApplicationSumAggregateInputType
    _min?: JobApplicationMinAggregateInputType
    _max?: JobApplicationMaxAggregateInputType
  }

  export type JobApplicationGroupByOutputType = {
    userId: number
    jobId: string
    resume: string
    expectedSalary: number
    status: $Enums.JobApplicationStatus
    isTaken: boolean
    rejectedReview: string | null
    selectionTestResult: number | null
    createdAt: Date
    _count: JobApplicationCountAggregateOutputType | null
    _avg: JobApplicationAvgAggregateOutputType | null
    _sum: JobApplicationSumAggregateOutputType | null
    _min: JobApplicationMinAggregateOutputType | null
    _max: JobApplicationMaxAggregateOutputType | null
  }

  type GetJobApplicationGroupByPayload<T extends JobApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], JobApplicationGroupByOutputType[P]>
        }
      >
    >


  export type JobApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    jobId?: boolean
    resume?: boolean
    expectedSalary?: boolean
    status?: boolean
    isTaken?: boolean
    rejectedReview?: boolean
    selectionTestResult?: boolean
    createdAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobApplication"]>

  export type JobApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    jobId?: boolean
    resume?: boolean
    expectedSalary?: boolean
    status?: boolean
    isTaken?: boolean
    rejectedReview?: boolean
    selectionTestResult?: boolean
    createdAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobApplication"]>

  export type JobApplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    jobId?: boolean
    resume?: boolean
    expectedSalary?: boolean
    status?: boolean
    isTaken?: boolean
    rejectedReview?: boolean
    selectionTestResult?: boolean
    createdAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobApplication"]>

  export type JobApplicationSelectScalar = {
    userId?: boolean
    jobId?: boolean
    resume?: boolean
    expectedSalary?: boolean
    status?: boolean
    isTaken?: boolean
    rejectedReview?: boolean
    selectionTestResult?: boolean
    createdAt?: boolean
  }

  export type JobApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "jobId" | "resume" | "expectedSalary" | "status" | "isTaken" | "rejectedReview" | "selectionTestResult" | "createdAt", ExtArgs["result"]["jobApplication"]>
  export type JobApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JobApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JobApplicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $JobApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobApplication"
    objects: {
      job: Prisma.$JobPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      jobId: string
      resume: string
      expectedSalary: number
      status: $Enums.JobApplicationStatus
      isTaken: boolean
      rejectedReview: string | null
      selectionTestResult: number | null
      createdAt: Date
    }, ExtArgs["result"]["jobApplication"]>
    composites: {}
  }

  type JobApplicationGetPayload<S extends boolean | null | undefined | JobApplicationDefaultArgs> = $Result.GetResult<Prisma.$JobApplicationPayload, S>

  type JobApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobApplicationCountAggregateInputType | true
    }

  export interface JobApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobApplication'], meta: { name: 'JobApplication' } }
    /**
     * Find zero or one JobApplication that matches the filter.
     * @param {JobApplicationFindUniqueArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobApplicationFindUniqueArgs>(args: SelectSubset<T, JobApplicationFindUniqueArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one JobApplication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobApplicationFindUniqueOrThrowArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, JobApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first JobApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationFindFirstArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobApplicationFindFirstArgs>(args?: SelectSubset<T, JobApplicationFindFirstArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first JobApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationFindFirstOrThrowArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, JobApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more JobApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobApplications
     * const jobApplications = await prisma.jobApplication.findMany()
     * 
     * // Get first 10 JobApplications
     * const jobApplications = await prisma.jobApplication.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const jobApplicationWithUserIdOnly = await prisma.jobApplication.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends JobApplicationFindManyArgs>(args?: SelectSubset<T, JobApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a JobApplication.
     * @param {JobApplicationCreateArgs} args - Arguments to create a JobApplication.
     * @example
     * // Create one JobApplication
     * const JobApplication = await prisma.jobApplication.create({
     *   data: {
     *     // ... data to create a JobApplication
     *   }
     * })
     * 
     */
    create<T extends JobApplicationCreateArgs>(args: SelectSubset<T, JobApplicationCreateArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many JobApplications.
     * @param {JobApplicationCreateManyArgs} args - Arguments to create many JobApplications.
     * @example
     * // Create many JobApplications
     * const jobApplication = await prisma.jobApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobApplicationCreateManyArgs>(args?: SelectSubset<T, JobApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobApplications and returns the data saved in the database.
     * @param {JobApplicationCreateManyAndReturnArgs} args - Arguments to create many JobApplications.
     * @example
     * // Create many JobApplications
     * const jobApplication = await prisma.jobApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobApplications and only return the `userId`
     * const jobApplicationWithUserIdOnly = await prisma.jobApplication.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, JobApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a JobApplication.
     * @param {JobApplicationDeleteArgs} args - Arguments to delete one JobApplication.
     * @example
     * // Delete one JobApplication
     * const JobApplication = await prisma.jobApplication.delete({
     *   where: {
     *     // ... filter to delete one JobApplication
     *   }
     * })
     * 
     */
    delete<T extends JobApplicationDeleteArgs>(args: SelectSubset<T, JobApplicationDeleteArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one JobApplication.
     * @param {JobApplicationUpdateArgs} args - Arguments to update one JobApplication.
     * @example
     * // Update one JobApplication
     * const jobApplication = await prisma.jobApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobApplicationUpdateArgs>(args: SelectSubset<T, JobApplicationUpdateArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more JobApplications.
     * @param {JobApplicationDeleteManyArgs} args - Arguments to filter JobApplications to delete.
     * @example
     * // Delete a few JobApplications
     * const { count } = await prisma.jobApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobApplicationDeleteManyArgs>(args?: SelectSubset<T, JobApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobApplications
     * const jobApplication = await prisma.jobApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobApplicationUpdateManyArgs>(args: SelectSubset<T, JobApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobApplications and returns the data updated in the database.
     * @param {JobApplicationUpdateManyAndReturnArgs} args - Arguments to update many JobApplications.
     * @example
     * // Update many JobApplications
     * const jobApplication = await prisma.jobApplication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobApplications and only return the `userId`
     * const jobApplicationWithUserIdOnly = await prisma.jobApplication.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, JobApplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one JobApplication.
     * @param {JobApplicationUpsertArgs} args - Arguments to update or create a JobApplication.
     * @example
     * // Update or create a JobApplication
     * const jobApplication = await prisma.jobApplication.upsert({
     *   create: {
     *     // ... data to create a JobApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobApplication we want to update
     *   }
     * })
     */
    upsert<T extends JobApplicationUpsertArgs>(args: SelectSubset<T, JobApplicationUpsertArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of JobApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationCountArgs} args - Arguments to filter JobApplications to count.
     * @example
     * // Count the number of JobApplications
     * const count = await prisma.jobApplication.count({
     *   where: {
     *     // ... the filter for the JobApplications we want to count
     *   }
     * })
    **/
    count<T extends JobApplicationCountArgs>(
      args?: Subset<T, JobApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobApplicationAggregateArgs>(args: Subset<T, JobApplicationAggregateArgs>): Prisma.PrismaPromise<GetJobApplicationAggregateType<T>>

    /**
     * Group by JobApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobApplicationGroupByArgs['orderBy'] }
        : { orderBy?: JobApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobApplication model
   */
  readonly fields: JobApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobApplication model
   */ 
  interface JobApplicationFieldRefs {
    readonly userId: FieldRef<"JobApplication", 'Int'>
    readonly jobId: FieldRef<"JobApplication", 'String'>
    readonly resume: FieldRef<"JobApplication", 'String'>
    readonly expectedSalary: FieldRef<"JobApplication", 'Int'>
    readonly status: FieldRef<"JobApplication", 'JobApplicationStatus'>
    readonly isTaken: FieldRef<"JobApplication", 'Boolean'>
    readonly rejectedReview: FieldRef<"JobApplication", 'String'>
    readonly selectionTestResult: FieldRef<"JobApplication", 'Int'>
    readonly createdAt: FieldRef<"JobApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobApplication findUnique
   */
  export type JobApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where: JobApplicationWhereUniqueInput
  }

  /**
   * JobApplication findUniqueOrThrow
   */
  export type JobApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where: JobApplicationWhereUniqueInput
  }

  /**
   * JobApplication findFirst
   */
  export type JobApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobApplications.
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobApplications.
     */
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }

  /**
   * JobApplication findFirstOrThrow
   */
  export type JobApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobApplications.
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobApplications.
     */
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }

  /**
   * JobApplication findMany
   */
  export type JobApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplications to fetch.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobApplications.
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }

  /**
   * JobApplication create
   */
  export type JobApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a JobApplication.
     */
    data: XOR<JobApplicationCreateInput, JobApplicationUncheckedCreateInput>
  }

  /**
   * JobApplication createMany
   */
  export type JobApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobApplications.
     */
    data: JobApplicationCreateManyInput | JobApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobApplication createManyAndReturn
   */
  export type JobApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * The data used to create many JobApplications.
     */
    data: JobApplicationCreateManyInput | JobApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobApplication update
   */
  export type JobApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a JobApplication.
     */
    data: XOR<JobApplicationUpdateInput, JobApplicationUncheckedUpdateInput>
    /**
     * Choose, which JobApplication to update.
     */
    where: JobApplicationWhereUniqueInput
  }

  /**
   * JobApplication updateMany
   */
  export type JobApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobApplications.
     */
    data: XOR<JobApplicationUpdateManyMutationInput, JobApplicationUncheckedUpdateManyInput>
    /**
     * Filter which JobApplications to update
     */
    where?: JobApplicationWhereInput
  }

  /**
   * JobApplication updateManyAndReturn
   */
  export type JobApplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * The data used to update JobApplications.
     */
    data: XOR<JobApplicationUpdateManyMutationInput, JobApplicationUncheckedUpdateManyInput>
    /**
     * Filter which JobApplications to update
     */
    where?: JobApplicationWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobApplication upsert
   */
  export type JobApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the JobApplication to update in case it exists.
     */
    where: JobApplicationWhereUniqueInput
    /**
     * In case the JobApplication found by the `where` argument doesn't exist, create a new JobApplication with this data.
     */
    create: XOR<JobApplicationCreateInput, JobApplicationUncheckedCreateInput>
    /**
     * In case the JobApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobApplicationUpdateInput, JobApplicationUncheckedUpdateInput>
  }

  /**
   * JobApplication delete
   */
  export type JobApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter which JobApplication to delete.
     */
    where: JobApplicationWhereUniqueInput
  }

  /**
   * JobApplication deleteMany
   */
  export type JobApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobApplications to delete
     */
    where?: JobApplicationWhereInput
  }

  /**
   * JobApplication without action
   */
  export type JobApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
  }


  /**
   * Model Interview
   */

  export type AggregateInterview = {
    _count: InterviewCountAggregateOutputType | null
    _avg: InterviewAvgAggregateOutputType | null
    _sum: InterviewSumAggregateOutputType | null
    _min: InterviewMinAggregateOutputType | null
    _max: InterviewMaxAggregateOutputType | null
  }

  export type InterviewAvgAggregateOutputType = {
    userId: number | null
  }

  export type InterviewSumAggregateOutputType = {
    userId: number | null
  }

  export type InterviewMinAggregateOutputType = {
    userId: number | null
    jobId: string | null
    startTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterviewMaxAggregateOutputType = {
    userId: number | null
    jobId: string | null
    startTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterviewCountAggregateOutputType = {
    userId: number
    jobId: number
    startTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InterviewAvgAggregateInputType = {
    userId?: true
  }

  export type InterviewSumAggregateInputType = {
    userId?: true
  }

  export type InterviewMinAggregateInputType = {
    userId?: true
    jobId?: true
    startTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterviewMaxAggregateInputType = {
    userId?: true
    jobId?: true
    startTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterviewCountAggregateInputType = {
    userId?: true
    jobId?: true
    startTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InterviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interview to aggregate.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interviews
    **/
    _count?: true | InterviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewMaxAggregateInputType
  }

  export type GetInterviewAggregateType<T extends InterviewAggregateArgs> = {
        [P in keyof T & keyof AggregateInterview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterview[P]>
      : GetScalarType<T[P], AggregateInterview[P]>
  }




  export type InterviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewWhereInput
    orderBy?: InterviewOrderByWithAggregationInput | InterviewOrderByWithAggregationInput[]
    by: InterviewScalarFieldEnum[] | InterviewScalarFieldEnum
    having?: InterviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewCountAggregateInputType | true
    _avg?: InterviewAvgAggregateInputType
    _sum?: InterviewSumAggregateInputType
    _min?: InterviewMinAggregateInputType
    _max?: InterviewMaxAggregateInputType
  }

  export type InterviewGroupByOutputType = {
    userId: number
    jobId: string
    startTime: Date
    createdAt: Date
    updatedAt: Date
    _count: InterviewCountAggregateOutputType | null
    _avg: InterviewAvgAggregateOutputType | null
    _sum: InterviewSumAggregateOutputType | null
    _min: InterviewMinAggregateOutputType | null
    _max: InterviewMaxAggregateOutputType | null
  }

  type GetInterviewGroupByPayload<T extends InterviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewGroupByOutputType[P]>
        }
      >
    >


  export type InterviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    jobId?: boolean
    startTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interview"]>

  export type InterviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    jobId?: boolean
    startTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interview"]>

  export type InterviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    jobId?: boolean
    startTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interview"]>

  export type InterviewSelectScalar = {
    userId?: boolean
    jobId?: boolean
    startTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InterviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "jobId" | "startTime" | "createdAt" | "updatedAt", ExtArgs["result"]["interview"]>
  export type InterviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
  }
  export type InterviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
  }
  export type InterviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
  }

  export type $InterviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Interview"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      job: Prisma.$JobPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      jobId: string
      startTime: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["interview"]>
    composites: {}
  }

  type InterviewGetPayload<S extends boolean | null | undefined | InterviewDefaultArgs> = $Result.GetResult<Prisma.$InterviewPayload, S>

  type InterviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterviewCountAggregateInputType | true
    }

  export interface InterviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Interview'], meta: { name: 'Interview' } }
    /**
     * Find zero or one Interview that matches the filter.
     * @param {InterviewFindUniqueArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterviewFindUniqueArgs>(args: SelectSubset<T, InterviewFindUniqueArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Interview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterviewFindUniqueOrThrowArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterviewFindUniqueOrThrowArgs>(args: SelectSubset<T, InterviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Interview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFindFirstArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterviewFindFirstArgs>(args?: SelectSubset<T, InterviewFindFirstArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Interview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFindFirstOrThrowArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterviewFindFirstOrThrowArgs>(args?: SelectSubset<T, InterviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Interviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interviews
     * const interviews = await prisma.interview.findMany()
     * 
     * // Get first 10 Interviews
     * const interviews = await prisma.interview.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const interviewWithUserIdOnly = await prisma.interview.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends InterviewFindManyArgs>(args?: SelectSubset<T, InterviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Interview.
     * @param {InterviewCreateArgs} args - Arguments to create a Interview.
     * @example
     * // Create one Interview
     * const Interview = await prisma.interview.create({
     *   data: {
     *     // ... data to create a Interview
     *   }
     * })
     * 
     */
    create<T extends InterviewCreateArgs>(args: SelectSubset<T, InterviewCreateArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Interviews.
     * @param {InterviewCreateManyArgs} args - Arguments to create many Interviews.
     * @example
     * // Create many Interviews
     * const interview = await prisma.interview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterviewCreateManyArgs>(args?: SelectSubset<T, InterviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interviews and returns the data saved in the database.
     * @param {InterviewCreateManyAndReturnArgs} args - Arguments to create many Interviews.
     * @example
     * // Create many Interviews
     * const interview = await prisma.interview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interviews and only return the `userId`
     * const interviewWithUserIdOnly = await prisma.interview.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterviewCreateManyAndReturnArgs>(args?: SelectSubset<T, InterviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Interview.
     * @param {InterviewDeleteArgs} args - Arguments to delete one Interview.
     * @example
     * // Delete one Interview
     * const Interview = await prisma.interview.delete({
     *   where: {
     *     // ... filter to delete one Interview
     *   }
     * })
     * 
     */
    delete<T extends InterviewDeleteArgs>(args: SelectSubset<T, InterviewDeleteArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Interview.
     * @param {InterviewUpdateArgs} args - Arguments to update one Interview.
     * @example
     * // Update one Interview
     * const interview = await prisma.interview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterviewUpdateArgs>(args: SelectSubset<T, InterviewUpdateArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Interviews.
     * @param {InterviewDeleteManyArgs} args - Arguments to filter Interviews to delete.
     * @example
     * // Delete a few Interviews
     * const { count } = await prisma.interview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterviewDeleteManyArgs>(args?: SelectSubset<T, InterviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interviews
     * const interview = await prisma.interview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterviewUpdateManyArgs>(args: SelectSubset<T, InterviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interviews and returns the data updated in the database.
     * @param {InterviewUpdateManyAndReturnArgs} args - Arguments to update many Interviews.
     * @example
     * // Update many Interviews
     * const interview = await prisma.interview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Interviews and only return the `userId`
     * const interviewWithUserIdOnly = await prisma.interview.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterviewUpdateManyAndReturnArgs>(args: SelectSubset<T, InterviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Interview.
     * @param {InterviewUpsertArgs} args - Arguments to update or create a Interview.
     * @example
     * // Update or create a Interview
     * const interview = await prisma.interview.upsert({
     *   create: {
     *     // ... data to create a Interview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interview we want to update
     *   }
     * })
     */
    upsert<T extends InterviewUpsertArgs>(args: SelectSubset<T, InterviewUpsertArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Interviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewCountArgs} args - Arguments to filter Interviews to count.
     * @example
     * // Count the number of Interviews
     * const count = await prisma.interview.count({
     *   where: {
     *     // ... the filter for the Interviews we want to count
     *   }
     * })
    **/
    count<T extends InterviewCountArgs>(
      args?: Subset<T, InterviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewAggregateArgs>(args: Subset<T, InterviewAggregateArgs>): Prisma.PrismaPromise<GetInterviewAggregateType<T>>

    /**
     * Group by Interview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewGroupByArgs['orderBy'] }
        : { orderBy?: InterviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Interview model
   */
  readonly fields: InterviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Interview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Interview model
   */ 
  interface InterviewFieldRefs {
    readonly userId: FieldRef<"Interview", 'Int'>
    readonly jobId: FieldRef<"Interview", 'String'>
    readonly startTime: FieldRef<"Interview", 'DateTime'>
    readonly createdAt: FieldRef<"Interview", 'DateTime'>
    readonly updatedAt: FieldRef<"Interview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Interview findUnique
   */
  export type InterviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * Filter, which Interview to fetch.
     */
    where: InterviewWhereUniqueInput
  }

  /**
   * Interview findUniqueOrThrow
   */
  export type InterviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * Filter, which Interview to fetch.
     */
    where: InterviewWhereUniqueInput
  }

  /**
   * Interview findFirst
   */
  export type InterviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * Filter, which Interview to fetch.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interviews.
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interviews.
     */
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * Interview findFirstOrThrow
   */
  export type InterviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * Filter, which Interview to fetch.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interviews.
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interviews.
     */
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * Interview findMany
   */
  export type InterviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * Filter, which Interviews to fetch.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interviews.
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * Interview create
   */
  export type InterviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Interview.
     */
    data: XOR<InterviewCreateInput, InterviewUncheckedCreateInput>
  }

  /**
   * Interview createMany
   */
  export type InterviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interviews.
     */
    data: InterviewCreateManyInput | InterviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interview createManyAndReturn
   */
  export type InterviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * The data used to create many Interviews.
     */
    data: InterviewCreateManyInput | InterviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Interview update
   */
  export type InterviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Interview.
     */
    data: XOR<InterviewUpdateInput, InterviewUncheckedUpdateInput>
    /**
     * Choose, which Interview to update.
     */
    where: InterviewWhereUniqueInput
  }

  /**
   * Interview updateMany
   */
  export type InterviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interviews.
     */
    data: XOR<InterviewUpdateManyMutationInput, InterviewUncheckedUpdateManyInput>
    /**
     * Filter which Interviews to update
     */
    where?: InterviewWhereInput
  }

  /**
   * Interview updateManyAndReturn
   */
  export type InterviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * The data used to update Interviews.
     */
    data: XOR<InterviewUpdateManyMutationInput, InterviewUncheckedUpdateManyInput>
    /**
     * Filter which Interviews to update
     */
    where?: InterviewWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Interview upsert
   */
  export type InterviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Interview to update in case it exists.
     */
    where: InterviewWhereUniqueInput
    /**
     * In case the Interview found by the `where` argument doesn't exist, create a new Interview with this data.
     */
    create: XOR<InterviewCreateInput, InterviewUncheckedCreateInput>
    /**
     * In case the Interview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewUpdateInput, InterviewUncheckedUpdateInput>
  }

  /**
   * Interview delete
   */
  export type InterviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * Filter which Interview to delete.
     */
    where: InterviewWhereUniqueInput
  }

  /**
   * Interview deleteMany
   */
  export type InterviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interviews to delete
     */
    where?: InterviewWhereInput
  }

  /**
   * Interview without action
   */
  export type InterviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    userId: number | null
    CultureRating: number | null
    balanceRating: number | null
    facilityRating: number | null
    careerRating: number | null
    salary: number | null
  }

  export type ReviewSumAggregateOutputType = {
    userId: number | null
    CultureRating: number | null
    balanceRating: number | null
    facilityRating: number | null
    careerRating: number | null
    salary: number | null
  }

  export type ReviewMinAggregateOutputType = {
    userId: number | null
    jobId: string | null
    review: string | null
    CultureRating: number | null
    balanceRating: number | null
    facilityRating: number | null
    careerRating: number | null
    salary: number | null
    createdAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    userId: number | null
    jobId: string | null
    review: string | null
    CultureRating: number | null
    balanceRating: number | null
    facilityRating: number | null
    careerRating: number | null
    salary: number | null
    createdAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    userId: number
    jobId: number
    review: number
    CultureRating: number
    balanceRating: number
    facilityRating: number
    careerRating: number
    salary: number
    createdAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    userId?: true
    CultureRating?: true
    balanceRating?: true
    facilityRating?: true
    careerRating?: true
    salary?: true
  }

  export type ReviewSumAggregateInputType = {
    userId?: true
    CultureRating?: true
    balanceRating?: true
    facilityRating?: true
    careerRating?: true
    salary?: true
  }

  export type ReviewMinAggregateInputType = {
    userId?: true
    jobId?: true
    review?: true
    CultureRating?: true
    balanceRating?: true
    facilityRating?: true
    careerRating?: true
    salary?: true
    createdAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    userId?: true
    jobId?: true
    review?: true
    CultureRating?: true
    balanceRating?: true
    facilityRating?: true
    careerRating?: true
    salary?: true
    createdAt?: true
  }

  export type ReviewCountAggregateInputType = {
    userId?: true
    jobId?: true
    review?: true
    CultureRating?: true
    balanceRating?: true
    facilityRating?: true
    careerRating?: true
    salary?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    userId: number
    jobId: string
    review: string
    CultureRating: number
    balanceRating: number
    facilityRating: number
    careerRating: number
    salary: number
    createdAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    jobId?: boolean
    review?: boolean
    CultureRating?: boolean
    balanceRating?: boolean
    facilityRating?: boolean
    careerRating?: boolean
    salary?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    jobId?: boolean
    review?: boolean
    CultureRating?: boolean
    balanceRating?: boolean
    facilityRating?: boolean
    careerRating?: boolean
    salary?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    jobId?: boolean
    review?: boolean
    CultureRating?: boolean
    balanceRating?: boolean
    facilityRating?: boolean
    careerRating?: boolean
    salary?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    userId?: boolean
    jobId?: boolean
    review?: boolean
    CultureRating?: boolean
    balanceRating?: boolean
    facilityRating?: boolean
    careerRating?: boolean
    salary?: boolean
    createdAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "jobId" | "review" | "CultureRating" | "balanceRating" | "facilityRating" | "careerRating" | "salary" | "createdAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    job?: boolean | JobDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      job: Prisma.$JobPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      jobId: string
      review: string
      CultureRating: number
      balanceRating: number
      facilityRating: number
      careerRating: number
      salary: number
      createdAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const reviewWithUserIdOnly = await prisma.review.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `userId`
     * const reviewWithUserIdOnly = await prisma.review.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `userId`
     * const reviewWithUserIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly userId: FieldRef<"Review", 'Int'>
    readonly jobId: FieldRef<"Review", 'String'>
    readonly review: FieldRef<"Review", 'String'>
    readonly CultureRating: FieldRef<"Review", 'Int'>
    readonly balanceRating: FieldRef<"Review", 'Int'>
    readonly facilityRating: FieldRef<"Review", 'Int'>
    readonly careerRating: FieldRef<"Review", 'Int'>
    readonly salary: FieldRef<"Review", 'Int'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    userId: number | null
    subscriptionId: number | null
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    userId: number | null
    subscriptionId: number | null
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    userId: number | null
    subscriptionId: number | null
    amount: number | null
    status: $Enums.TransactionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    subscriptionId: number | null
    amount: number | null
    status: $Enums.TransactionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    userId: number
    subscriptionId: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    userId?: true
    subscriptionId?: true
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    userId?: true
    subscriptionId?: true
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    userId?: true
    subscriptionId?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    userId: number
    subscriptionId: number
    amount: number
    status: $Enums.TransactionStatus
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    subscriptionId?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "subscriptionId" | "amount" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      subscriptionId: number
      amount: number
      status: $Enums.TransactionStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'Int'>
    readonly subscriptionId: FieldRef<"Transaction", 'Int'>
    readonly amount: FieldRef<"Transaction", 'Int'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Assessment
   */

  export type AggregateAssessment = {
    _count: AssessmentCountAggregateOutputType | null
    _avg: AssessmentAvgAggregateOutputType | null
    _sum: AssessmentSumAggregateOutputType | null
    _min: AssessmentMinAggregateOutputType | null
    _max: AssessmentMaxAggregateOutputType | null
  }

  export type AssessmentAvgAggregateOutputType = {
    id: number | null
  }

  export type AssessmentSumAggregateOutputType = {
    id: number | null
  }

  export type AssessmentMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AssessmentMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AssessmentCountAggregateOutputType = {
    id: number
    title: number
    description: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type AssessmentAvgAggregateInputType = {
    id?: true
  }

  export type AssessmentSumAggregateInputType = {
    id?: true
  }

  export type AssessmentMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isActive?: true
    createdAt?: true
  }

  export type AssessmentMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isActive?: true
    createdAt?: true
  }

  export type AssessmentCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type AssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assessment to aggregate.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assessments
    **/
    _count?: true | AssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssessmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssessmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssessmentMaxAggregateInputType
  }

  export type GetAssessmentAggregateType<T extends AssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssessment[P]>
      : GetScalarType<T[P], AggregateAssessment[P]>
  }




  export type AssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentWhereInput
    orderBy?: AssessmentOrderByWithAggregationInput | AssessmentOrderByWithAggregationInput[]
    by: AssessmentScalarFieldEnum[] | AssessmentScalarFieldEnum
    having?: AssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssessmentCountAggregateInputType | true
    _avg?: AssessmentAvgAggregateInputType
    _sum?: AssessmentSumAggregateInputType
    _min?: AssessmentMinAggregateInputType
    _max?: AssessmentMaxAggregateInputType
  }

  export type AssessmentGroupByOutputType = {
    id: number
    title: string
    description: string
    isActive: boolean
    createdAt: Date
    _count: AssessmentCountAggregateOutputType | null
    _avg: AssessmentAvgAggregateOutputType | null
    _sum: AssessmentSumAggregateOutputType | null
    _min: AssessmentMinAggregateOutputType | null
    _max: AssessmentMaxAggregateOutputType | null
  }

  type GetAssessmentGroupByPayload<T extends AssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssessmentGroupByOutputType[P]>
        }
      >
    >


  export type AssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    AssessmentQuestion?: boolean | Assessment$AssessmentQuestionArgs<ExtArgs>
    UserAssessment?: boolean | Assessment$UserAssessmentArgs<ExtArgs>
    _count?: boolean | AssessmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessment"]>

  export type AssessmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["assessment"]>

  export type AssessmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["assessment"]>

  export type AssessmentSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type AssessmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "isActive" | "createdAt", ExtArgs["result"]["assessment"]>
  export type AssessmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AssessmentQuestion?: boolean | Assessment$AssessmentQuestionArgs<ExtArgs>
    UserAssessment?: boolean | Assessment$UserAssessmentArgs<ExtArgs>
    _count?: boolean | AssessmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssessmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AssessmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assessment"
    objects: {
      AssessmentQuestion: Prisma.$AssessmentQuestionPayload<ExtArgs>[]
      UserAssessment: Prisma.$UserAssessmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["assessment"]>
    composites: {}
  }

  type AssessmentGetPayload<S extends boolean | null | undefined | AssessmentDefaultArgs> = $Result.GetResult<Prisma.$AssessmentPayload, S>

  type AssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssessmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssessmentCountAggregateInputType | true
    }

  export interface AssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assessment'], meta: { name: 'Assessment' } }
    /**
     * Find zero or one Assessment that matches the filter.
     * @param {AssessmentFindUniqueArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssessmentFindUniqueArgs>(args: SelectSubset<T, AssessmentFindUniqueArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Assessment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssessmentFindUniqueOrThrowArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Assessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentFindFirstArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssessmentFindFirstArgs>(args?: SelectSubset<T, AssessmentFindFirstArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Assessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentFindFirstOrThrowArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Assessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assessments
     * const assessments = await prisma.assessment.findMany()
     * 
     * // Get first 10 Assessments
     * const assessments = await prisma.assessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assessmentWithIdOnly = await prisma.assessment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssessmentFindManyArgs>(args?: SelectSubset<T, AssessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Assessment.
     * @param {AssessmentCreateArgs} args - Arguments to create a Assessment.
     * @example
     * // Create one Assessment
     * const Assessment = await prisma.assessment.create({
     *   data: {
     *     // ... data to create a Assessment
     *   }
     * })
     * 
     */
    create<T extends AssessmentCreateArgs>(args: SelectSubset<T, AssessmentCreateArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Assessments.
     * @param {AssessmentCreateManyArgs} args - Arguments to create many Assessments.
     * @example
     * // Create many Assessments
     * const assessment = await prisma.assessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssessmentCreateManyArgs>(args?: SelectSubset<T, AssessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assessments and returns the data saved in the database.
     * @param {AssessmentCreateManyAndReturnArgs} args - Arguments to create many Assessments.
     * @example
     * // Create many Assessments
     * const assessment = await prisma.assessment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assessments and only return the `id`
     * const assessmentWithIdOnly = await prisma.assessment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssessmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AssessmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Assessment.
     * @param {AssessmentDeleteArgs} args - Arguments to delete one Assessment.
     * @example
     * // Delete one Assessment
     * const Assessment = await prisma.assessment.delete({
     *   where: {
     *     // ... filter to delete one Assessment
     *   }
     * })
     * 
     */
    delete<T extends AssessmentDeleteArgs>(args: SelectSubset<T, AssessmentDeleteArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Assessment.
     * @param {AssessmentUpdateArgs} args - Arguments to update one Assessment.
     * @example
     * // Update one Assessment
     * const assessment = await prisma.assessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssessmentUpdateArgs>(args: SelectSubset<T, AssessmentUpdateArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Assessments.
     * @param {AssessmentDeleteManyArgs} args - Arguments to filter Assessments to delete.
     * @example
     * // Delete a few Assessments
     * const { count } = await prisma.assessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssessmentDeleteManyArgs>(args?: SelectSubset<T, AssessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assessments
     * const assessment = await prisma.assessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssessmentUpdateManyArgs>(args: SelectSubset<T, AssessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assessments and returns the data updated in the database.
     * @param {AssessmentUpdateManyAndReturnArgs} args - Arguments to update many Assessments.
     * @example
     * // Update many Assessments
     * const assessment = await prisma.assessment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assessments and only return the `id`
     * const assessmentWithIdOnly = await prisma.assessment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssessmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AssessmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Assessment.
     * @param {AssessmentUpsertArgs} args - Arguments to update or create a Assessment.
     * @example
     * // Update or create a Assessment
     * const assessment = await prisma.assessment.upsert({
     *   create: {
     *     // ... data to create a Assessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assessment we want to update
     *   }
     * })
     */
    upsert<T extends AssessmentUpsertArgs>(args: SelectSubset<T, AssessmentUpsertArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentCountArgs} args - Arguments to filter Assessments to count.
     * @example
     * // Count the number of Assessments
     * const count = await prisma.assessment.count({
     *   where: {
     *     // ... the filter for the Assessments we want to count
     *   }
     * })
    **/
    count<T extends AssessmentCountArgs>(
      args?: Subset<T, AssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssessmentAggregateArgs>(args: Subset<T, AssessmentAggregateArgs>): Prisma.PrismaPromise<GetAssessmentAggregateType<T>>

    /**
     * Group by Assessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssessmentGroupByArgs['orderBy'] }
        : { orderBy?: AssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assessment model
   */
  readonly fields: AssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AssessmentQuestion<T extends Assessment$AssessmentQuestionArgs<ExtArgs> = {}>(args?: Subset<T, Assessment$AssessmentQuestionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    UserAssessment<T extends Assessment$UserAssessmentArgs<ExtArgs> = {}>(args?: Subset<T, Assessment$UserAssessmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAssessmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assessment model
   */ 
  interface AssessmentFieldRefs {
    readonly id: FieldRef<"Assessment", 'Int'>
    readonly title: FieldRef<"Assessment", 'String'>
    readonly description: FieldRef<"Assessment", 'String'>
    readonly isActive: FieldRef<"Assessment", 'Boolean'>
    readonly createdAt: FieldRef<"Assessment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Assessment findUnique
   */
  export type AssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment findUniqueOrThrow
   */
  export type AssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment findFirst
   */
  export type AssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assessments.
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assessments.
     */
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Assessment findFirstOrThrow
   */
  export type AssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assessments.
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assessments.
     */
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Assessment findMany
   */
  export type AssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessments to fetch.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assessments.
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Assessment create
   */
  export type AssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Assessment.
     */
    data: XOR<AssessmentCreateInput, AssessmentUncheckedCreateInput>
  }

  /**
   * Assessment createMany
   */
  export type AssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assessments.
     */
    data: AssessmentCreateManyInput | AssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assessment createManyAndReturn
   */
  export type AssessmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * The data used to create many Assessments.
     */
    data: AssessmentCreateManyInput | AssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assessment update
   */
  export type AssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Assessment.
     */
    data: XOR<AssessmentUpdateInput, AssessmentUncheckedUpdateInput>
    /**
     * Choose, which Assessment to update.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment updateMany
   */
  export type AssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assessments.
     */
    data: XOR<AssessmentUpdateManyMutationInput, AssessmentUncheckedUpdateManyInput>
    /**
     * Filter which Assessments to update
     */
    where?: AssessmentWhereInput
  }

  /**
   * Assessment updateManyAndReturn
   */
  export type AssessmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * The data used to update Assessments.
     */
    data: XOR<AssessmentUpdateManyMutationInput, AssessmentUncheckedUpdateManyInput>
    /**
     * Filter which Assessments to update
     */
    where?: AssessmentWhereInput
  }

  /**
   * Assessment upsert
   */
  export type AssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Assessment to update in case it exists.
     */
    where: AssessmentWhereUniqueInput
    /**
     * In case the Assessment found by the `where` argument doesn't exist, create a new Assessment with this data.
     */
    create: XOR<AssessmentCreateInput, AssessmentUncheckedCreateInput>
    /**
     * In case the Assessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssessmentUpdateInput, AssessmentUncheckedUpdateInput>
  }

  /**
   * Assessment delete
   */
  export type AssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter which Assessment to delete.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment deleteMany
   */
  export type AssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assessments to delete
     */
    where?: AssessmentWhereInput
  }

  /**
   * Assessment.AssessmentQuestion
   */
  export type Assessment$AssessmentQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    where?: AssessmentQuestionWhereInput
    orderBy?: AssessmentQuestionOrderByWithRelationInput | AssessmentQuestionOrderByWithRelationInput[]
    cursor?: AssessmentQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentQuestionScalarFieldEnum | AssessmentQuestionScalarFieldEnum[]
  }

  /**
   * Assessment.UserAssessment
   */
  export type Assessment$UserAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessment
     */
    select?: UserAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessment
     */
    omit?: UserAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentInclude<ExtArgs> | null
    where?: UserAssessmentWhereInput
    orderBy?: UserAssessmentOrderByWithRelationInput | UserAssessmentOrderByWithRelationInput[]
    cursor?: UserAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAssessmentScalarFieldEnum | UserAssessmentScalarFieldEnum[]
  }

  /**
   * Assessment without action
   */
  export type AssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assessment
     */
    omit?: AssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
  }


  /**
   * Model UserAssessment
   */

  export type AggregateUserAssessment = {
    _count: UserAssessmentCountAggregateOutputType | null
    _avg: UserAssessmentAvgAggregateOutputType | null
    _sum: UserAssessmentSumAggregateOutputType | null
    _min: UserAssessmentMinAggregateOutputType | null
    _max: UserAssessmentMaxAggregateOutputType | null
  }

  export type UserAssessmentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    assessmentId: number | null
    score: number | null
    certificateId: number | null
  }

  export type UserAssessmentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    assessmentId: number | null
    score: number | null
    certificateId: number | null
  }

  export type UserAssessmentMinAggregateOutputType = {
    id: number | null
    userId: number | null
    assessmentId: number | null
    score: number | null
    certificateId: number | null
    status: $Enums.UserAssessmentStatus | null
    endTime: Date | null
  }

  export type UserAssessmentMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    assessmentId: number | null
    score: number | null
    certificateId: number | null
    status: $Enums.UserAssessmentStatus | null
    endTime: Date | null
  }

  export type UserAssessmentCountAggregateOutputType = {
    id: number
    userId: number
    assessmentId: number
    score: number
    certificateId: number
    status: number
    endTime: number
    _all: number
  }


  export type UserAssessmentAvgAggregateInputType = {
    id?: true
    userId?: true
    assessmentId?: true
    score?: true
    certificateId?: true
  }

  export type UserAssessmentSumAggregateInputType = {
    id?: true
    userId?: true
    assessmentId?: true
    score?: true
    certificateId?: true
  }

  export type UserAssessmentMinAggregateInputType = {
    id?: true
    userId?: true
    assessmentId?: true
    score?: true
    certificateId?: true
    status?: true
    endTime?: true
  }

  export type UserAssessmentMaxAggregateInputType = {
    id?: true
    userId?: true
    assessmentId?: true
    score?: true
    certificateId?: true
    status?: true
    endTime?: true
  }

  export type UserAssessmentCountAggregateInputType = {
    id?: true
    userId?: true
    assessmentId?: true
    score?: true
    certificateId?: true
    status?: true
    endTime?: true
    _all?: true
  }

  export type UserAssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAssessment to aggregate.
     */
    where?: UserAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAssessments to fetch.
     */
    orderBy?: UserAssessmentOrderByWithRelationInput | UserAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAssessments
    **/
    _count?: true | UserAssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAssessmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAssessmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAssessmentMaxAggregateInputType
  }

  export type GetUserAssessmentAggregateType<T extends UserAssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAssessment[P]>
      : GetScalarType<T[P], AggregateUserAssessment[P]>
  }




  export type UserAssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAssessmentWhereInput
    orderBy?: UserAssessmentOrderByWithAggregationInput | UserAssessmentOrderByWithAggregationInput[]
    by: UserAssessmentScalarFieldEnum[] | UserAssessmentScalarFieldEnum
    having?: UserAssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAssessmentCountAggregateInputType | true
    _avg?: UserAssessmentAvgAggregateInputType
    _sum?: UserAssessmentSumAggregateInputType
    _min?: UserAssessmentMinAggregateInputType
    _max?: UserAssessmentMaxAggregateInputType
  }

  export type UserAssessmentGroupByOutputType = {
    id: number
    userId: number
    assessmentId: number
    score: number
    certificateId: number | null
    status: $Enums.UserAssessmentStatus | null
    endTime: Date
    _count: UserAssessmentCountAggregateOutputType | null
    _avg: UserAssessmentAvgAggregateOutputType | null
    _sum: UserAssessmentSumAggregateOutputType | null
    _min: UserAssessmentMinAggregateOutputType | null
    _max: UserAssessmentMaxAggregateOutputType | null
  }

  type GetUserAssessmentGroupByPayload<T extends UserAssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], UserAssessmentGroupByOutputType[P]>
        }
      >
    >


  export type UserAssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assessmentId?: boolean
    score?: boolean
    certificateId?: boolean
    status?: boolean
    endTime?: boolean
    certificate?: boolean | UserAssessment$certificateArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAssessment"]>

  export type UserAssessmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assessmentId?: boolean
    score?: boolean
    certificateId?: boolean
    status?: boolean
    endTime?: boolean
    certificate?: boolean | UserAssessment$certificateArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAssessment"]>

  export type UserAssessmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assessmentId?: boolean
    score?: boolean
    certificateId?: boolean
    status?: boolean
    endTime?: boolean
    certificate?: boolean | UserAssessment$certificateArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAssessment"]>

  export type UserAssessmentSelectScalar = {
    id?: boolean
    userId?: boolean
    assessmentId?: boolean
    score?: boolean
    certificateId?: boolean
    status?: boolean
    endTime?: boolean
  }

  export type UserAssessmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "assessmentId" | "score" | "certificateId" | "status" | "endTime", ExtArgs["result"]["userAssessment"]>
  export type UserAssessmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificate?: boolean | UserAssessment$certificateArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }
  export type UserAssessmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificate?: boolean | UserAssessment$certificateArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }
  export type UserAssessmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificate?: boolean | UserAssessment$certificateArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }

  export type $UserAssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAssessment"
    objects: {
      certificate: Prisma.$CertificatePayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs>
      assessment: Prisma.$AssessmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      assessmentId: number
      score: number
      certificateId: number | null
      status: $Enums.UserAssessmentStatus | null
      endTime: Date
    }, ExtArgs["result"]["userAssessment"]>
    composites: {}
  }

  type UserAssessmentGetPayload<S extends boolean | null | undefined | UserAssessmentDefaultArgs> = $Result.GetResult<Prisma.$UserAssessmentPayload, S>

  type UserAssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAssessmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAssessmentCountAggregateInputType | true
    }

  export interface UserAssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAssessment'], meta: { name: 'UserAssessment' } }
    /**
     * Find zero or one UserAssessment that matches the filter.
     * @param {UserAssessmentFindUniqueArgs} args - Arguments to find a UserAssessment
     * @example
     * // Get one UserAssessment
     * const userAssessment = await prisma.userAssessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAssessmentFindUniqueArgs>(args: SelectSubset<T, UserAssessmentFindUniqueArgs<ExtArgs>>): Prisma__UserAssessmentClient<$Result.GetResult<Prisma.$UserAssessmentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserAssessment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAssessmentFindUniqueOrThrowArgs} args - Arguments to find a UserAssessment
     * @example
     * // Get one UserAssessment
     * const userAssessment = await prisma.userAssessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAssessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAssessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAssessmentClient<$Result.GetResult<Prisma.$UserAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserAssessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssessmentFindFirstArgs} args - Arguments to find a UserAssessment
     * @example
     * // Get one UserAssessment
     * const userAssessment = await prisma.userAssessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAssessmentFindFirstArgs>(args?: SelectSubset<T, UserAssessmentFindFirstArgs<ExtArgs>>): Prisma__UserAssessmentClient<$Result.GetResult<Prisma.$UserAssessmentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserAssessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssessmentFindFirstOrThrowArgs} args - Arguments to find a UserAssessment
     * @example
     * // Get one UserAssessment
     * const userAssessment = await prisma.userAssessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAssessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAssessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAssessmentClient<$Result.GetResult<Prisma.$UserAssessmentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserAssessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAssessments
     * const userAssessments = await prisma.userAssessment.findMany()
     * 
     * // Get first 10 UserAssessments
     * const userAssessments = await prisma.userAssessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAssessmentWithIdOnly = await prisma.userAssessment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAssessmentFindManyArgs>(args?: SelectSubset<T, UserAssessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAssessmentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserAssessment.
     * @param {UserAssessmentCreateArgs} args - Arguments to create a UserAssessment.
     * @example
     * // Create one UserAssessment
     * const UserAssessment = await prisma.userAssessment.create({
     *   data: {
     *     // ... data to create a UserAssessment
     *   }
     * })
     * 
     */
    create<T extends UserAssessmentCreateArgs>(args: SelectSubset<T, UserAssessmentCreateArgs<ExtArgs>>): Prisma__UserAssessmentClient<$Result.GetResult<Prisma.$UserAssessmentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserAssessments.
     * @param {UserAssessmentCreateManyArgs} args - Arguments to create many UserAssessments.
     * @example
     * // Create many UserAssessments
     * const userAssessment = await prisma.userAssessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAssessmentCreateManyArgs>(args?: SelectSubset<T, UserAssessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAssessments and returns the data saved in the database.
     * @param {UserAssessmentCreateManyAndReturnArgs} args - Arguments to create many UserAssessments.
     * @example
     * // Create many UserAssessments
     * const userAssessment = await prisma.userAssessment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAssessments and only return the `id`
     * const userAssessmentWithIdOnly = await prisma.userAssessment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAssessmentCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAssessmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAssessmentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserAssessment.
     * @param {UserAssessmentDeleteArgs} args - Arguments to delete one UserAssessment.
     * @example
     * // Delete one UserAssessment
     * const UserAssessment = await prisma.userAssessment.delete({
     *   where: {
     *     // ... filter to delete one UserAssessment
     *   }
     * })
     * 
     */
    delete<T extends UserAssessmentDeleteArgs>(args: SelectSubset<T, UserAssessmentDeleteArgs<ExtArgs>>): Prisma__UserAssessmentClient<$Result.GetResult<Prisma.$UserAssessmentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserAssessment.
     * @param {UserAssessmentUpdateArgs} args - Arguments to update one UserAssessment.
     * @example
     * // Update one UserAssessment
     * const userAssessment = await prisma.userAssessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAssessmentUpdateArgs>(args: SelectSubset<T, UserAssessmentUpdateArgs<ExtArgs>>): Prisma__UserAssessmentClient<$Result.GetResult<Prisma.$UserAssessmentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserAssessments.
     * @param {UserAssessmentDeleteManyArgs} args - Arguments to filter UserAssessments to delete.
     * @example
     * // Delete a few UserAssessments
     * const { count } = await prisma.userAssessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAssessmentDeleteManyArgs>(args?: SelectSubset<T, UserAssessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAssessments
     * const userAssessment = await prisma.userAssessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAssessmentUpdateManyArgs>(args: SelectSubset<T, UserAssessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAssessments and returns the data updated in the database.
     * @param {UserAssessmentUpdateManyAndReturnArgs} args - Arguments to update many UserAssessments.
     * @example
     * // Update many UserAssessments
     * const userAssessment = await prisma.userAssessment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAssessments and only return the `id`
     * const userAssessmentWithIdOnly = await prisma.userAssessment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAssessmentUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAssessmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAssessmentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserAssessment.
     * @param {UserAssessmentUpsertArgs} args - Arguments to update or create a UserAssessment.
     * @example
     * // Update or create a UserAssessment
     * const userAssessment = await prisma.userAssessment.upsert({
     *   create: {
     *     // ... data to create a UserAssessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAssessment we want to update
     *   }
     * })
     */
    upsert<T extends UserAssessmentUpsertArgs>(args: SelectSubset<T, UserAssessmentUpsertArgs<ExtArgs>>): Prisma__UserAssessmentClient<$Result.GetResult<Prisma.$UserAssessmentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssessmentCountArgs} args - Arguments to filter UserAssessments to count.
     * @example
     * // Count the number of UserAssessments
     * const count = await prisma.userAssessment.count({
     *   where: {
     *     // ... the filter for the UserAssessments we want to count
     *   }
     * })
    **/
    count<T extends UserAssessmentCountArgs>(
      args?: Subset<T, UserAssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAssessmentAggregateArgs>(args: Subset<T, UserAssessmentAggregateArgs>): Prisma.PrismaPromise<GetUserAssessmentAggregateType<T>>

    /**
     * Group by UserAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAssessmentGroupByArgs['orderBy'] }
        : { orderBy?: UserAssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAssessment model
   */
  readonly fields: UserAssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAssessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    certificate<T extends UserAssessment$certificateArgs<ExtArgs> = {}>(args?: Subset<T, UserAssessment$certificateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    assessment<T extends AssessmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentDefaultArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAssessment model
   */ 
  interface UserAssessmentFieldRefs {
    readonly id: FieldRef<"UserAssessment", 'Int'>
    readonly userId: FieldRef<"UserAssessment", 'Int'>
    readonly assessmentId: FieldRef<"UserAssessment", 'Int'>
    readonly score: FieldRef<"UserAssessment", 'Int'>
    readonly certificateId: FieldRef<"UserAssessment", 'Int'>
    readonly status: FieldRef<"UserAssessment", 'UserAssessmentStatus'>
    readonly endTime: FieldRef<"UserAssessment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAssessment findUnique
   */
  export type UserAssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessment
     */
    select?: UserAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessment
     */
    omit?: UserAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which UserAssessment to fetch.
     */
    where: UserAssessmentWhereUniqueInput
  }

  /**
   * UserAssessment findUniqueOrThrow
   */
  export type UserAssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessment
     */
    select?: UserAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessment
     */
    omit?: UserAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which UserAssessment to fetch.
     */
    where: UserAssessmentWhereUniqueInput
  }

  /**
   * UserAssessment findFirst
   */
  export type UserAssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessment
     */
    select?: UserAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessment
     */
    omit?: UserAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which UserAssessment to fetch.
     */
    where?: UserAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAssessments to fetch.
     */
    orderBy?: UserAssessmentOrderByWithRelationInput | UserAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAssessments.
     */
    cursor?: UserAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAssessments.
     */
    distinct?: UserAssessmentScalarFieldEnum | UserAssessmentScalarFieldEnum[]
  }

  /**
   * UserAssessment findFirstOrThrow
   */
  export type UserAssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessment
     */
    select?: UserAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessment
     */
    omit?: UserAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which UserAssessment to fetch.
     */
    where?: UserAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAssessments to fetch.
     */
    orderBy?: UserAssessmentOrderByWithRelationInput | UserAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAssessments.
     */
    cursor?: UserAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAssessments.
     */
    distinct?: UserAssessmentScalarFieldEnum | UserAssessmentScalarFieldEnum[]
  }

  /**
   * UserAssessment findMany
   */
  export type UserAssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessment
     */
    select?: UserAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessment
     */
    omit?: UserAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which UserAssessments to fetch.
     */
    where?: UserAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAssessments to fetch.
     */
    orderBy?: UserAssessmentOrderByWithRelationInput | UserAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAssessments.
     */
    cursor?: UserAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAssessments.
     */
    skip?: number
    distinct?: UserAssessmentScalarFieldEnum | UserAssessmentScalarFieldEnum[]
  }

  /**
   * UserAssessment create
   */
  export type UserAssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessment
     */
    select?: UserAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessment
     */
    omit?: UserAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAssessment.
     */
    data: XOR<UserAssessmentCreateInput, UserAssessmentUncheckedCreateInput>
  }

  /**
   * UserAssessment createMany
   */
  export type UserAssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAssessments.
     */
    data: UserAssessmentCreateManyInput | UserAssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAssessment createManyAndReturn
   */
  export type UserAssessmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessment
     */
    select?: UserAssessmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessment
     */
    omit?: UserAssessmentOmit<ExtArgs> | null
    /**
     * The data used to create many UserAssessments.
     */
    data: UserAssessmentCreateManyInput | UserAssessmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAssessment update
   */
  export type UserAssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessment
     */
    select?: UserAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessment
     */
    omit?: UserAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAssessment.
     */
    data: XOR<UserAssessmentUpdateInput, UserAssessmentUncheckedUpdateInput>
    /**
     * Choose, which UserAssessment to update.
     */
    where: UserAssessmentWhereUniqueInput
  }

  /**
   * UserAssessment updateMany
   */
  export type UserAssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAssessments.
     */
    data: XOR<UserAssessmentUpdateManyMutationInput, UserAssessmentUncheckedUpdateManyInput>
    /**
     * Filter which UserAssessments to update
     */
    where?: UserAssessmentWhereInput
  }

  /**
   * UserAssessment updateManyAndReturn
   */
  export type UserAssessmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessment
     */
    select?: UserAssessmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessment
     */
    omit?: UserAssessmentOmit<ExtArgs> | null
    /**
     * The data used to update UserAssessments.
     */
    data: XOR<UserAssessmentUpdateManyMutationInput, UserAssessmentUncheckedUpdateManyInput>
    /**
     * Filter which UserAssessments to update
     */
    where?: UserAssessmentWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAssessment upsert
   */
  export type UserAssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessment
     */
    select?: UserAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessment
     */
    omit?: UserAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAssessment to update in case it exists.
     */
    where: UserAssessmentWhereUniqueInput
    /**
     * In case the UserAssessment found by the `where` argument doesn't exist, create a new UserAssessment with this data.
     */
    create: XOR<UserAssessmentCreateInput, UserAssessmentUncheckedCreateInput>
    /**
     * In case the UserAssessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAssessmentUpdateInput, UserAssessmentUncheckedUpdateInput>
  }

  /**
   * UserAssessment delete
   */
  export type UserAssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessment
     */
    select?: UserAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessment
     */
    omit?: UserAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentInclude<ExtArgs> | null
    /**
     * Filter which UserAssessment to delete.
     */
    where: UserAssessmentWhereUniqueInput
  }

  /**
   * UserAssessment deleteMany
   */
  export type UserAssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAssessments to delete
     */
    where?: UserAssessmentWhereInput
  }

  /**
   * UserAssessment.certificate
   */
  export type UserAssessment$certificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
  }

  /**
   * UserAssessment without action
   */
  export type UserAssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessment
     */
    select?: UserAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessment
     */
    omit?: UserAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentInclude<ExtArgs> | null
  }


  /**
   * Model AssessmentQuestion
   */

  export type AggregateAssessmentQuestion = {
    _count: AssessmentQuestionCountAggregateOutputType | null
    _avg: AssessmentQuestionAvgAggregateOutputType | null
    _sum: AssessmentQuestionSumAggregateOutputType | null
    _min: AssessmentQuestionMinAggregateOutputType | null
    _max: AssessmentQuestionMaxAggregateOutputType | null
  }

  export type AssessmentQuestionAvgAggregateOutputType = {
    id: number | null
    assessmentId: number | null
    correctAnswer: number | null
  }

  export type AssessmentQuestionSumAggregateOutputType = {
    id: number | null
    assessmentId: number | null
    correctAnswer: number | null
  }

  export type AssessmentQuestionMinAggregateOutputType = {
    id: number | null
    assessmentId: number | null
    question: string | null
    correctAnswer: number | null
  }

  export type AssessmentQuestionMaxAggregateOutputType = {
    id: number | null
    assessmentId: number | null
    question: string | null
    correctAnswer: number | null
  }

  export type AssessmentQuestionCountAggregateOutputType = {
    id: number
    assessmentId: number
    question: number
    options: number
    correctAnswer: number
    _all: number
  }


  export type AssessmentQuestionAvgAggregateInputType = {
    id?: true
    assessmentId?: true
    correctAnswer?: true
  }

  export type AssessmentQuestionSumAggregateInputType = {
    id?: true
    assessmentId?: true
    correctAnswer?: true
  }

  export type AssessmentQuestionMinAggregateInputType = {
    id?: true
    assessmentId?: true
    question?: true
    correctAnswer?: true
  }

  export type AssessmentQuestionMaxAggregateInputType = {
    id?: true
    assessmentId?: true
    question?: true
    correctAnswer?: true
  }

  export type AssessmentQuestionCountAggregateInputType = {
    id?: true
    assessmentId?: true
    question?: true
    options?: true
    correctAnswer?: true
    _all?: true
  }

  export type AssessmentQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentQuestion to aggregate.
     */
    where?: AssessmentQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentQuestions to fetch.
     */
    orderBy?: AssessmentQuestionOrderByWithRelationInput | AssessmentQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssessmentQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssessmentQuestions
    **/
    _count?: true | AssessmentQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssessmentQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssessmentQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssessmentQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssessmentQuestionMaxAggregateInputType
  }

  export type GetAssessmentQuestionAggregateType<T extends AssessmentQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateAssessmentQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssessmentQuestion[P]>
      : GetScalarType<T[P], AggregateAssessmentQuestion[P]>
  }




  export type AssessmentQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentQuestionWhereInput
    orderBy?: AssessmentQuestionOrderByWithAggregationInput | AssessmentQuestionOrderByWithAggregationInput[]
    by: AssessmentQuestionScalarFieldEnum[] | AssessmentQuestionScalarFieldEnum
    having?: AssessmentQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssessmentQuestionCountAggregateInputType | true
    _avg?: AssessmentQuestionAvgAggregateInputType
    _sum?: AssessmentQuestionSumAggregateInputType
    _min?: AssessmentQuestionMinAggregateInputType
    _max?: AssessmentQuestionMaxAggregateInputType
  }

  export type AssessmentQuestionGroupByOutputType = {
    id: number
    assessmentId: number
    question: string
    options: string[]
    correctAnswer: number
    _count: AssessmentQuestionCountAggregateOutputType | null
    _avg: AssessmentQuestionAvgAggregateOutputType | null
    _sum: AssessmentQuestionSumAggregateOutputType | null
    _min: AssessmentQuestionMinAggregateOutputType | null
    _max: AssessmentQuestionMaxAggregateOutputType | null
  }

  type GetAssessmentQuestionGroupByPayload<T extends AssessmentQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssessmentQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssessmentQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssessmentQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], AssessmentQuestionGroupByOutputType[P]>
        }
      >
    >


  export type AssessmentQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assessmentId?: boolean
    question?: boolean
    options?: boolean
    correctAnswer?: boolean
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentQuestion"]>

  export type AssessmentQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assessmentId?: boolean
    question?: boolean
    options?: boolean
    correctAnswer?: boolean
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentQuestion"]>

  export type AssessmentQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assessmentId?: boolean
    question?: boolean
    options?: boolean
    correctAnswer?: boolean
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentQuestion"]>

  export type AssessmentQuestionSelectScalar = {
    id?: boolean
    assessmentId?: boolean
    question?: boolean
    options?: boolean
    correctAnswer?: boolean
  }

  export type AssessmentQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assessmentId" | "question" | "options" | "correctAnswer", ExtArgs["result"]["assessmentQuestion"]>
  export type AssessmentQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }
  export type AssessmentQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }
  export type AssessmentQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
  }

  export type $AssessmentQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssessmentQuestion"
    objects: {
      assessment: Prisma.$AssessmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      assessmentId: number
      question: string
      options: string[]
      correctAnswer: number
    }, ExtArgs["result"]["assessmentQuestion"]>
    composites: {}
  }

  type AssessmentQuestionGetPayload<S extends boolean | null | undefined | AssessmentQuestionDefaultArgs> = $Result.GetResult<Prisma.$AssessmentQuestionPayload, S>

  type AssessmentQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssessmentQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssessmentQuestionCountAggregateInputType | true
    }

  export interface AssessmentQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssessmentQuestion'], meta: { name: 'AssessmentQuestion' } }
    /**
     * Find zero or one AssessmentQuestion that matches the filter.
     * @param {AssessmentQuestionFindUniqueArgs} args - Arguments to find a AssessmentQuestion
     * @example
     * // Get one AssessmentQuestion
     * const assessmentQuestion = await prisma.assessmentQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssessmentQuestionFindUniqueArgs>(args: SelectSubset<T, AssessmentQuestionFindUniqueArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AssessmentQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssessmentQuestionFindUniqueOrThrowArgs} args - Arguments to find a AssessmentQuestion
     * @example
     * // Get one AssessmentQuestion
     * const assessmentQuestion = await prisma.assessmentQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssessmentQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, AssessmentQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AssessmentQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionFindFirstArgs} args - Arguments to find a AssessmentQuestion
     * @example
     * // Get one AssessmentQuestion
     * const assessmentQuestion = await prisma.assessmentQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssessmentQuestionFindFirstArgs>(args?: SelectSubset<T, AssessmentQuestionFindFirstArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AssessmentQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionFindFirstOrThrowArgs} args - Arguments to find a AssessmentQuestion
     * @example
     * // Get one AssessmentQuestion
     * const assessmentQuestion = await prisma.assessmentQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssessmentQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, AssessmentQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AssessmentQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssessmentQuestions
     * const assessmentQuestions = await prisma.assessmentQuestion.findMany()
     * 
     * // Get first 10 AssessmentQuestions
     * const assessmentQuestions = await prisma.assessmentQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assessmentQuestionWithIdOnly = await prisma.assessmentQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssessmentQuestionFindManyArgs>(args?: SelectSubset<T, AssessmentQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AssessmentQuestion.
     * @param {AssessmentQuestionCreateArgs} args - Arguments to create a AssessmentQuestion.
     * @example
     * // Create one AssessmentQuestion
     * const AssessmentQuestion = await prisma.assessmentQuestion.create({
     *   data: {
     *     // ... data to create a AssessmentQuestion
     *   }
     * })
     * 
     */
    create<T extends AssessmentQuestionCreateArgs>(args: SelectSubset<T, AssessmentQuestionCreateArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AssessmentQuestions.
     * @param {AssessmentQuestionCreateManyArgs} args - Arguments to create many AssessmentQuestions.
     * @example
     * // Create many AssessmentQuestions
     * const assessmentQuestion = await prisma.assessmentQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssessmentQuestionCreateManyArgs>(args?: SelectSubset<T, AssessmentQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssessmentQuestions and returns the data saved in the database.
     * @param {AssessmentQuestionCreateManyAndReturnArgs} args - Arguments to create many AssessmentQuestions.
     * @example
     * // Create many AssessmentQuestions
     * const assessmentQuestion = await prisma.assessmentQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssessmentQuestions and only return the `id`
     * const assessmentQuestionWithIdOnly = await prisma.assessmentQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssessmentQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, AssessmentQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AssessmentQuestion.
     * @param {AssessmentQuestionDeleteArgs} args - Arguments to delete one AssessmentQuestion.
     * @example
     * // Delete one AssessmentQuestion
     * const AssessmentQuestion = await prisma.assessmentQuestion.delete({
     *   where: {
     *     // ... filter to delete one AssessmentQuestion
     *   }
     * })
     * 
     */
    delete<T extends AssessmentQuestionDeleteArgs>(args: SelectSubset<T, AssessmentQuestionDeleteArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AssessmentQuestion.
     * @param {AssessmentQuestionUpdateArgs} args - Arguments to update one AssessmentQuestion.
     * @example
     * // Update one AssessmentQuestion
     * const assessmentQuestion = await prisma.assessmentQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssessmentQuestionUpdateArgs>(args: SelectSubset<T, AssessmentQuestionUpdateArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AssessmentQuestions.
     * @param {AssessmentQuestionDeleteManyArgs} args - Arguments to filter AssessmentQuestions to delete.
     * @example
     * // Delete a few AssessmentQuestions
     * const { count } = await prisma.assessmentQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssessmentQuestionDeleteManyArgs>(args?: SelectSubset<T, AssessmentQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssessmentQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssessmentQuestions
     * const assessmentQuestion = await prisma.assessmentQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssessmentQuestionUpdateManyArgs>(args: SelectSubset<T, AssessmentQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssessmentQuestions and returns the data updated in the database.
     * @param {AssessmentQuestionUpdateManyAndReturnArgs} args - Arguments to update many AssessmentQuestions.
     * @example
     * // Update many AssessmentQuestions
     * const assessmentQuestion = await prisma.assessmentQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssessmentQuestions and only return the `id`
     * const assessmentQuestionWithIdOnly = await prisma.assessmentQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssessmentQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, AssessmentQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AssessmentQuestion.
     * @param {AssessmentQuestionUpsertArgs} args - Arguments to update or create a AssessmentQuestion.
     * @example
     * // Update or create a AssessmentQuestion
     * const assessmentQuestion = await prisma.assessmentQuestion.upsert({
     *   create: {
     *     // ... data to create a AssessmentQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssessmentQuestion we want to update
     *   }
     * })
     */
    upsert<T extends AssessmentQuestionUpsertArgs>(args: SelectSubset<T, AssessmentQuestionUpsertArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AssessmentQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionCountArgs} args - Arguments to filter AssessmentQuestions to count.
     * @example
     * // Count the number of AssessmentQuestions
     * const count = await prisma.assessmentQuestion.count({
     *   where: {
     *     // ... the filter for the AssessmentQuestions we want to count
     *   }
     * })
    **/
    count<T extends AssessmentQuestionCountArgs>(
      args?: Subset<T, AssessmentQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssessmentQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssessmentQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssessmentQuestionAggregateArgs>(args: Subset<T, AssessmentQuestionAggregateArgs>): Prisma.PrismaPromise<GetAssessmentQuestionAggregateType<T>>

    /**
     * Group by AssessmentQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssessmentQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssessmentQuestionGroupByArgs['orderBy'] }
        : { orderBy?: AssessmentQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssessmentQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssessmentQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssessmentQuestion model
   */
  readonly fields: AssessmentQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssessmentQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssessmentQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assessment<T extends AssessmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentDefaultArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssessmentQuestion model
   */ 
  interface AssessmentQuestionFieldRefs {
    readonly id: FieldRef<"AssessmentQuestion", 'Int'>
    readonly assessmentId: FieldRef<"AssessmentQuestion", 'Int'>
    readonly question: FieldRef<"AssessmentQuestion", 'String'>
    readonly options: FieldRef<"AssessmentQuestion", 'String[]'>
    readonly correctAnswer: FieldRef<"AssessmentQuestion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AssessmentQuestion findUnique
   */
  export type AssessmentQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestion to fetch.
     */
    where: AssessmentQuestionWhereUniqueInput
  }

  /**
   * AssessmentQuestion findUniqueOrThrow
   */
  export type AssessmentQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestion to fetch.
     */
    where: AssessmentQuestionWhereUniqueInput
  }

  /**
   * AssessmentQuestion findFirst
   */
  export type AssessmentQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestion to fetch.
     */
    where?: AssessmentQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentQuestions to fetch.
     */
    orderBy?: AssessmentQuestionOrderByWithRelationInput | AssessmentQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentQuestions.
     */
    cursor?: AssessmentQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentQuestions.
     */
    distinct?: AssessmentQuestionScalarFieldEnum | AssessmentQuestionScalarFieldEnum[]
  }

  /**
   * AssessmentQuestion findFirstOrThrow
   */
  export type AssessmentQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestion to fetch.
     */
    where?: AssessmentQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentQuestions to fetch.
     */
    orderBy?: AssessmentQuestionOrderByWithRelationInput | AssessmentQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentQuestions.
     */
    cursor?: AssessmentQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentQuestions.
     */
    distinct?: AssessmentQuestionScalarFieldEnum | AssessmentQuestionScalarFieldEnum[]
  }

  /**
   * AssessmentQuestion findMany
   */
  export type AssessmentQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestions to fetch.
     */
    where?: AssessmentQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentQuestions to fetch.
     */
    orderBy?: AssessmentQuestionOrderByWithRelationInput | AssessmentQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssessmentQuestions.
     */
    cursor?: AssessmentQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentQuestions.
     */
    skip?: number
    distinct?: AssessmentQuestionScalarFieldEnum | AssessmentQuestionScalarFieldEnum[]
  }

  /**
   * AssessmentQuestion create
   */
  export type AssessmentQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a AssessmentQuestion.
     */
    data: XOR<AssessmentQuestionCreateInput, AssessmentQuestionUncheckedCreateInput>
  }

  /**
   * AssessmentQuestion createMany
   */
  export type AssessmentQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssessmentQuestions.
     */
    data: AssessmentQuestionCreateManyInput | AssessmentQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssessmentQuestion createManyAndReturn
   */
  export type AssessmentQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many AssessmentQuestions.
     */
    data: AssessmentQuestionCreateManyInput | AssessmentQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssessmentQuestion update
   */
  export type AssessmentQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a AssessmentQuestion.
     */
    data: XOR<AssessmentQuestionUpdateInput, AssessmentQuestionUncheckedUpdateInput>
    /**
     * Choose, which AssessmentQuestion to update.
     */
    where: AssessmentQuestionWhereUniqueInput
  }

  /**
   * AssessmentQuestion updateMany
   */
  export type AssessmentQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssessmentQuestions.
     */
    data: XOR<AssessmentQuestionUpdateManyMutationInput, AssessmentQuestionUncheckedUpdateManyInput>
    /**
     * Filter which AssessmentQuestions to update
     */
    where?: AssessmentQuestionWhereInput
  }

  /**
   * AssessmentQuestion updateManyAndReturn
   */
  export type AssessmentQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * The data used to update AssessmentQuestions.
     */
    data: XOR<AssessmentQuestionUpdateManyMutationInput, AssessmentQuestionUncheckedUpdateManyInput>
    /**
     * Filter which AssessmentQuestions to update
     */
    where?: AssessmentQuestionWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssessmentQuestion upsert
   */
  export type AssessmentQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the AssessmentQuestion to update in case it exists.
     */
    where: AssessmentQuestionWhereUniqueInput
    /**
     * In case the AssessmentQuestion found by the `where` argument doesn't exist, create a new AssessmentQuestion with this data.
     */
    create: XOR<AssessmentQuestionCreateInput, AssessmentQuestionUncheckedCreateInput>
    /**
     * In case the AssessmentQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssessmentQuestionUpdateInput, AssessmentQuestionUncheckedUpdateInput>
  }

  /**
   * AssessmentQuestion delete
   */
  export type AssessmentQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * Filter which AssessmentQuestion to delete.
     */
    where: AssessmentQuestionWhereUniqueInput
  }

  /**
   * AssessmentQuestion deleteMany
   */
  export type AssessmentQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentQuestions to delete
     */
    where?: AssessmentQuestionWhereInput
  }

  /**
   * AssessmentQuestion without action
   */
  export type AssessmentQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssessmentQuestion
     */
    omit?: AssessmentQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
  }


  /**
   * Model Certificate
   */

  export type AggregateCertificate = {
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  export type CertificateAvgAggregateOutputType = {
    id: number | null
  }

  export type CertificateSumAggregateOutputType = {
    id: number | null
  }

  export type CertificateMinAggregateOutputType = {
    id: number | null
    CertificateUrl: string | null
    badgeName: string | null
    badgeIcon: string | null
    createdAt: Date | null
  }

  export type CertificateMaxAggregateOutputType = {
    id: number | null
    CertificateUrl: string | null
    badgeName: string | null
    badgeIcon: string | null
    createdAt: Date | null
  }

  export type CertificateCountAggregateOutputType = {
    id: number
    CertificateUrl: number
    badgeName: number
    badgeIcon: number
    createdAt: number
    _all: number
  }


  export type CertificateAvgAggregateInputType = {
    id?: true
  }

  export type CertificateSumAggregateInputType = {
    id?: true
  }

  export type CertificateMinAggregateInputType = {
    id?: true
    CertificateUrl?: true
    badgeName?: true
    badgeIcon?: true
    createdAt?: true
  }

  export type CertificateMaxAggregateInputType = {
    id?: true
    CertificateUrl?: true
    badgeName?: true
    badgeIcon?: true
    createdAt?: true
  }

  export type CertificateCountAggregateInputType = {
    id?: true
    CertificateUrl?: true
    badgeName?: true
    badgeIcon?: true
    createdAt?: true
    _all?: true
  }

  export type CertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificate to aggregate.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certificates
    **/
    _count?: true | CertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateMaxAggregateInputType
  }

  export type GetCertificateAggregateType<T extends CertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificate[P]>
      : GetScalarType<T[P], AggregateCertificate[P]>
  }




  export type CertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithAggregationInput | CertificateOrderByWithAggregationInput[]
    by: CertificateScalarFieldEnum[] | CertificateScalarFieldEnum
    having?: CertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateCountAggregateInputType | true
    _avg?: CertificateAvgAggregateInputType
    _sum?: CertificateSumAggregateInputType
    _min?: CertificateMinAggregateInputType
    _max?: CertificateMaxAggregateInputType
  }

  export type CertificateGroupByOutputType = {
    id: number
    CertificateUrl: string
    badgeName: string
    badgeIcon: string
    createdAt: Date
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  type GetCertificateGroupByPayload<T extends CertificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateGroupByOutputType[P]>
        }
      >
    >


  export type CertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    CertificateUrl?: boolean
    badgeName?: boolean
    badgeIcon?: boolean
    createdAt?: boolean
    UserAssessment?: boolean | Certificate$UserAssessmentArgs<ExtArgs>
    _count?: boolean | CertificateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    CertificateUrl?: boolean
    badgeName?: boolean
    badgeIcon?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    CertificateUrl?: boolean
    badgeName?: boolean
    badgeIcon?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectScalar = {
    id?: boolean
    CertificateUrl?: boolean
    badgeName?: boolean
    badgeIcon?: boolean
    createdAt?: boolean
  }

  export type CertificateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "CertificateUrl" | "badgeName" | "badgeIcon" | "createdAt", ExtArgs["result"]["certificate"]>
  export type CertificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserAssessment?: boolean | Certificate$UserAssessmentArgs<ExtArgs>
    _count?: boolean | CertificateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CertificateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CertificateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certificate"
    objects: {
      UserAssessment: Prisma.$UserAssessmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      CertificateUrl: string
      badgeName: string
      badgeIcon: string
      createdAt: Date
    }, ExtArgs["result"]["certificate"]>
    composites: {}
  }

  type CertificateGetPayload<S extends boolean | null | undefined | CertificateDefaultArgs> = $Result.GetResult<Prisma.$CertificatePayload, S>

  type CertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CertificateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificateCountAggregateInputType | true
    }

  export interface CertificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certificate'], meta: { name: 'Certificate' } }
    /**
     * Find zero or one Certificate that matches the filter.
     * @param {CertificateFindUniqueArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateFindUniqueArgs>(args: SelectSubset<T, CertificateFindUniqueArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Certificate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CertificateFindUniqueOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Certificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateFindFirstArgs>(args?: SelectSubset<T, CertificateFindFirstArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Certificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificate.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificateWithIdOnly = await prisma.certificate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificateFindManyArgs>(args?: SelectSubset<T, CertificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Certificate.
     * @param {CertificateCreateArgs} args - Arguments to create a Certificate.
     * @example
     * // Create one Certificate
     * const Certificate = await prisma.certificate.create({
     *   data: {
     *     // ... data to create a Certificate
     *   }
     * })
     * 
     */
    create<T extends CertificateCreateArgs>(args: SelectSubset<T, CertificateCreateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Certificates.
     * @param {CertificateCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificateCreateManyArgs>(args?: SelectSubset<T, CertificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificates and returns the data saved in the database.
     * @param {CertificateCreateManyAndReturnArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificateCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Certificate.
     * @param {CertificateDeleteArgs} args - Arguments to delete one Certificate.
     * @example
     * // Delete one Certificate
     * const Certificate = await prisma.certificate.delete({
     *   where: {
     *     // ... filter to delete one Certificate
     *   }
     * })
     * 
     */
    delete<T extends CertificateDeleteArgs>(args: SelectSubset<T, CertificateDeleteArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Certificate.
     * @param {CertificateUpdateArgs} args - Arguments to update one Certificate.
     * @example
     * // Update one Certificate
     * const certificate = await prisma.certificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificateUpdateArgs>(args: SelectSubset<T, CertificateUpdateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Certificates.
     * @param {CertificateDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificateDeleteManyArgs>(args?: SelectSubset<T, CertificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificateUpdateManyArgs>(args: SelectSubset<T, CertificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates and returns the data updated in the database.
     * @param {CertificateUpdateManyAndReturnArgs} args - Arguments to update many Certificates.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CertificateUpdateManyAndReturnArgs>(args: SelectSubset<T, CertificateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Certificate.
     * @param {CertificateUpsertArgs} args - Arguments to update or create a Certificate.
     * @example
     * // Update or create a Certificate
     * const certificate = await prisma.certificate.upsert({
     *   create: {
     *     // ... data to create a Certificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificate we want to update
     *   }
     * })
     */
    upsert<T extends CertificateUpsertArgs>(args: SelectSubset<T, CertificateUpsertArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificate.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends CertificateCountArgs>(
      args?: Subset<T, CertificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateAggregateArgs>(args: Subset<T, CertificateAggregateArgs>): Prisma.PrismaPromise<GetCertificateAggregateType<T>>

    /**
     * Group by Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateGroupByArgs['orderBy'] }
        : { orderBy?: CertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certificate model
   */
  readonly fields: CertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UserAssessment<T extends Certificate$UserAssessmentArgs<ExtArgs> = {}>(args?: Subset<T, Certificate$UserAssessmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAssessmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certificate model
   */ 
  interface CertificateFieldRefs {
    readonly id: FieldRef<"Certificate", 'Int'>
    readonly CertificateUrl: FieldRef<"Certificate", 'String'>
    readonly badgeName: FieldRef<"Certificate", 'String'>
    readonly badgeIcon: FieldRef<"Certificate", 'String'>
    readonly createdAt: FieldRef<"Certificate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Certificate findUnique
   */
  export type CertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findUniqueOrThrow
   */
  export type CertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findFirst
   */
  export type CertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findFirstOrThrow
   */
  export type CertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findMany
   */
  export type CertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate create
   */
  export type CertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to create a Certificate.
     */
    data: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
  }

  /**
   * Certificate createMany
   */
  export type CertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certificate createManyAndReturn
   */
  export type CertificateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certificate update
   */
  export type CertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to update a Certificate.
     */
    data: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
    /**
     * Choose, which Certificate to update.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate updateMany
   */
  export type CertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate updateManyAndReturn
   */
  export type CertificateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate upsert
   */
  export type CertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The filter to search for the Certificate to update in case it exists.
     */
    where: CertificateWhereUniqueInput
    /**
     * In case the Certificate found by the `where` argument doesn't exist, create a new Certificate with this data.
     */
    create: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
    /**
     * In case the Certificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
  }

  /**
   * Certificate delete
   */
  export type CertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter which Certificate to delete.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate deleteMany
   */
  export type CertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificates to delete
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate.UserAssessment
   */
  export type Certificate$UserAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAssessment
     */
    select?: UserAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAssessment
     */
    omit?: UserAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAssessmentInclude<ExtArgs> | null
    where?: UserAssessmentWhereInput
    orderBy?: UserAssessmentOrderByWithRelationInput | UserAssessmentOrderByWithRelationInput[]
    cursor?: UserAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAssessmentScalarFieldEnum | UserAssessmentScalarFieldEnum[]
  }

  /**
   * Certificate without action
   */
  export type CertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
  }


  /**
   * Model UserSubscription
   */

  export type AggregateUserSubscription = {
    _count: UserSubscriptionCountAggregateOutputType | null
    _avg: UserSubscriptionAvgAggregateOutputType | null
    _sum: UserSubscriptionSumAggregateOutputType | null
    _min: UserSubscriptionMinAggregateOutputType | null
    _max: UserSubscriptionMaxAggregateOutputType | null
  }

  export type UserSubscriptionAvgAggregateOutputType = {
    userId: number | null
    subscriptionId: number | null
    assessmentCount: number | null
  }

  export type UserSubscriptionSumAggregateOutputType = {
    userId: number | null
    subscriptionId: number | null
    assessmentCount: number | null
  }

  export type UserSubscriptionMinAggregateOutputType = {
    userId: number | null
    subscriptionId: number | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    assessmentCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSubscriptionMaxAggregateOutputType = {
    userId: number | null
    subscriptionId: number | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    assessmentCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSubscriptionCountAggregateOutputType = {
    userId: number
    subscriptionId: number
    startDate: number
    endDate: number
    isActive: number
    assessmentCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSubscriptionAvgAggregateInputType = {
    userId?: true
    subscriptionId?: true
    assessmentCount?: true
  }

  export type UserSubscriptionSumAggregateInputType = {
    userId?: true
    subscriptionId?: true
    assessmentCount?: true
  }

  export type UserSubscriptionMinAggregateInputType = {
    userId?: true
    subscriptionId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    assessmentCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSubscriptionMaxAggregateInputType = {
    userId?: true
    subscriptionId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    assessmentCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSubscriptionCountAggregateInputType = {
    userId?: true
    subscriptionId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    assessmentCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubscription to aggregate.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSubscriptions
    **/
    _count?: true | UserSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSubscriptionMaxAggregateInputType
  }

  export type GetUserSubscriptionAggregateType<T extends UserSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSubscription[P]>
      : GetScalarType<T[P], AggregateUserSubscription[P]>
  }




  export type UserSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubscriptionWhereInput
    orderBy?: UserSubscriptionOrderByWithAggregationInput | UserSubscriptionOrderByWithAggregationInput[]
    by: UserSubscriptionScalarFieldEnum[] | UserSubscriptionScalarFieldEnum
    having?: UserSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSubscriptionCountAggregateInputType | true
    _avg?: UserSubscriptionAvgAggregateInputType
    _sum?: UserSubscriptionSumAggregateInputType
    _min?: UserSubscriptionMinAggregateInputType
    _max?: UserSubscriptionMaxAggregateInputType
  }

  export type UserSubscriptionGroupByOutputType = {
    userId: number
    subscriptionId: number
    startDate: Date
    endDate: Date
    isActive: boolean
    assessmentCount: number
    createdAt: Date
    updatedAt: Date
    _count: UserSubscriptionCountAggregateOutputType | null
    _avg: UserSubscriptionAvgAggregateOutputType | null
    _sum: UserSubscriptionSumAggregateOutputType | null
    _min: UserSubscriptionMinAggregateOutputType | null
    _max: UserSubscriptionMaxAggregateOutputType | null
  }

  type GetUserSubscriptionGroupByPayload<T extends UserSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type UserSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    subscriptionId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    assessmentCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    subscriptionId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    assessmentCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    subscriptionId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    assessmentCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectScalar = {
    userId?: boolean
    subscriptionId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    assessmentCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "subscriptionId" | "startDate" | "endDate" | "isActive" | "assessmentCount" | "createdAt" | "updatedAt", ExtArgs["result"]["userSubscription"]>
  export type UserSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSubscription"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      subscriptionId: number
      startDate: Date
      endDate: Date
      isActive: boolean
      assessmentCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSubscription"]>
    composites: {}
  }

  type UserSubscriptionGetPayload<S extends boolean | null | undefined | UserSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$UserSubscriptionPayload, S>

  type UserSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSubscriptionCountAggregateInputType | true
    }

  export interface UserSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSubscription'], meta: { name: 'UserSubscription' } }
    /**
     * Find zero or one UserSubscription that matches the filter.
     * @param {UserSubscriptionFindUniqueArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSubscriptionFindUniqueArgs>(args: SelectSubset<T, UserSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindFirstArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSubscriptionFindFirstArgs>(args?: SelectSubset<T, UserSubscriptionFindFirstArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindFirstOrThrowArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSubscriptions
     * const userSubscriptions = await prisma.userSubscription.findMany()
     * 
     * // Get first 10 UserSubscriptions
     * const userSubscriptions = await prisma.userSubscription.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userSubscriptionWithUserIdOnly = await prisma.userSubscription.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserSubscriptionFindManyArgs>(args?: SelectSubset<T, UserSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserSubscription.
     * @param {UserSubscriptionCreateArgs} args - Arguments to create a UserSubscription.
     * @example
     * // Create one UserSubscription
     * const UserSubscription = await prisma.userSubscription.create({
     *   data: {
     *     // ... data to create a UserSubscription
     *   }
     * })
     * 
     */
    create<T extends UserSubscriptionCreateArgs>(args: SelectSubset<T, UserSubscriptionCreateArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserSubscriptions.
     * @param {UserSubscriptionCreateManyArgs} args - Arguments to create many UserSubscriptions.
     * @example
     * // Create many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSubscriptionCreateManyArgs>(args?: SelectSubset<T, UserSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSubscriptions and returns the data saved in the database.
     * @param {UserSubscriptionCreateManyAndReturnArgs} args - Arguments to create many UserSubscriptions.
     * @example
     * // Create many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSubscriptions and only return the `userId`
     * const userSubscriptionWithUserIdOnly = await prisma.userSubscription.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserSubscription.
     * @param {UserSubscriptionDeleteArgs} args - Arguments to delete one UserSubscription.
     * @example
     * // Delete one UserSubscription
     * const UserSubscription = await prisma.userSubscription.delete({
     *   where: {
     *     // ... filter to delete one UserSubscription
     *   }
     * })
     * 
     */
    delete<T extends UserSubscriptionDeleteArgs>(args: SelectSubset<T, UserSubscriptionDeleteArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserSubscription.
     * @param {UserSubscriptionUpdateArgs} args - Arguments to update one UserSubscription.
     * @example
     * // Update one UserSubscription
     * const userSubscription = await prisma.userSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSubscriptionUpdateArgs>(args: SelectSubset<T, UserSubscriptionUpdateArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserSubscriptions.
     * @param {UserSubscriptionDeleteManyArgs} args - Arguments to filter UserSubscriptions to delete.
     * @example
     * // Delete a few UserSubscriptions
     * const { count } = await prisma.userSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSubscriptionDeleteManyArgs>(args?: SelectSubset<T, UserSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSubscriptionUpdateManyArgs>(args: SelectSubset<T, UserSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSubscriptions and returns the data updated in the database.
     * @param {UserSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many UserSubscriptions.
     * @example
     * // Update many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSubscriptions and only return the `userId`
     * const userSubscriptionWithUserIdOnly = await prisma.userSubscription.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserSubscription.
     * @param {UserSubscriptionUpsertArgs} args - Arguments to update or create a UserSubscription.
     * @example
     * // Update or create a UserSubscription
     * const userSubscription = await prisma.userSubscription.upsert({
     *   create: {
     *     // ... data to create a UserSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSubscription we want to update
     *   }
     * })
     */
    upsert<T extends UserSubscriptionUpsertArgs>(args: SelectSubset<T, UserSubscriptionUpsertArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionCountArgs} args - Arguments to filter UserSubscriptions to count.
     * @example
     * // Count the number of UserSubscriptions
     * const count = await prisma.userSubscription.count({
     *   where: {
     *     // ... the filter for the UserSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends UserSubscriptionCountArgs>(
      args?: Subset<T, UserSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSubscriptionAggregateArgs>(args: Subset<T, UserSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetUserSubscriptionAggregateType<T>>

    /**
     * Group by UserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: UserSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSubscription model
   */
  readonly fields: UserSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSubscription model
   */ 
  interface UserSubscriptionFieldRefs {
    readonly userId: FieldRef<"UserSubscription", 'Int'>
    readonly subscriptionId: FieldRef<"UserSubscription", 'Int'>
    readonly startDate: FieldRef<"UserSubscription", 'DateTime'>
    readonly endDate: FieldRef<"UserSubscription", 'DateTime'>
    readonly isActive: FieldRef<"UserSubscription", 'Boolean'>
    readonly assessmentCount: FieldRef<"UserSubscription", 'Int'>
    readonly createdAt: FieldRef<"UserSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSubscription findUnique
   */
  export type UserSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription findUniqueOrThrow
   */
  export type UserSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription findFirst
   */
  export type UserSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubscriptions.
     */
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription findFirstOrThrow
   */
  export type UserSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubscriptions.
     */
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription findMany
   */
  export type UserSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which UserSubscriptions to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription create
   */
  export type UserSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSubscription.
     */
    data: XOR<UserSubscriptionCreateInput, UserSubscriptionUncheckedCreateInput>
  }

  /**
   * UserSubscription createMany
   */
  export type UserSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSubscriptions.
     */
    data: UserSubscriptionCreateManyInput | UserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSubscription createManyAndReturn
   */
  export type UserSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSubscriptions.
     */
    data: UserSubscriptionCreateManyInput | UserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSubscription update
   */
  export type UserSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSubscription.
     */
    data: XOR<UserSubscriptionUpdateInput, UserSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which UserSubscription to update.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription updateMany
   */
  export type UserSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSubscriptions.
     */
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which UserSubscriptions to update
     */
    where?: UserSubscriptionWhereInput
  }

  /**
   * UserSubscription updateManyAndReturn
   */
  export type UserSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update UserSubscriptions.
     */
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which UserSubscriptions to update
     */
    where?: UserSubscriptionWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSubscription upsert
   */
  export type UserSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSubscription to update in case it exists.
     */
    where: UserSubscriptionWhereUniqueInput
    /**
     * In case the UserSubscription found by the `where` argument doesn't exist, create a new UserSubscription with this data.
     */
    create: XOR<UserSubscriptionCreateInput, UserSubscriptionUncheckedCreateInput>
    /**
     * In case the UserSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSubscriptionUpdateInput, UserSubscriptionUncheckedUpdateInput>
  }

  /**
   * UserSubscription delete
   */
  export type UserSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which UserSubscription to delete.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription deleteMany
   */
  export type UserSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubscriptions to delete
     */
    where?: UserSubscriptionWhereInput
  }

  /**
   * UserSubscription without action
   */
  export type UserSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubscription
     */
    omit?: UserSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    fullname: 'fullname',
    email: 'email',
    password: 'password',
    isVerified: 'isVerified',
    avatar: 'avatar',
    gender: 'gender',
    dob: 'dob',
    lastEdu: 'lastEdu',
    domicileId: 'domicileId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    companyName: 'companyName',
    email: 'email',
    password: 'password',
    description: 'description',
    isVerified: 'isVerified',
    logo: 'logo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    noHandphone: 'noHandphone'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const DeveloperScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password'
  };

  export type DeveloperScalarFieldEnum = (typeof DeveloperScalarFieldEnum)[keyof typeof DeveloperScalarFieldEnum]


  export const JobScalarFieldEnum: {
    id: 'id',
    title: 'title',
    adminId: 'adminId',
    banner: 'banner',
    category: 'category',
    role: 'role',
    salary: 'salary',
    description: 'description',
    endDate: 'endDate',
    isPublished: 'isPublished',
    isTestActive: 'isTestActive',
    tags: 'tags',
    locationId: 'locationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isActive: 'isActive'
  };

  export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]


  export const CurriculumVitaeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    summary: 'summary',
    experience: 'experience',
    skill: 'skill',
    education: 'education',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CurriculumVitaeScalarFieldEnum = (typeof CurriculumVitaeScalarFieldEnum)[keyof typeof CurriculumVitaeScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    city: 'city',
    province: 'province',
    latitude: 'latitude',
    longitude: 'longitude'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    category: 'category',
    price: 'price',
    feature: 'feature',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const PreSelectionTestScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    jobId: 'jobId',
    createdAt: 'createdAt'
  };

  export type PreSelectionTestScalarFieldEnum = (typeof PreSelectionTestScalarFieldEnum)[keyof typeof PreSelectionTestScalarFieldEnum]


  export const SelectionTestQuestionScalarFieldEnum: {
    id: 'id',
    preSelectionTestId: 'preSelectionTestId',
    question: 'question',
    options: 'options',
    correctAnswer: 'correctAnswer'
  };

  export type SelectionTestQuestionScalarFieldEnum = (typeof SelectionTestQuestionScalarFieldEnum)[keyof typeof SelectionTestQuestionScalarFieldEnum]


  export const JobApplicationScalarFieldEnum: {
    userId: 'userId',
    jobId: 'jobId',
    resume: 'resume',
    expectedSalary: 'expectedSalary',
    status: 'status',
    isTaken: 'isTaken',
    rejectedReview: 'rejectedReview',
    selectionTestResult: 'selectionTestResult',
    createdAt: 'createdAt'
  };

  export type JobApplicationScalarFieldEnum = (typeof JobApplicationScalarFieldEnum)[keyof typeof JobApplicationScalarFieldEnum]


  export const InterviewScalarFieldEnum: {
    userId: 'userId',
    jobId: 'jobId',
    startTime: 'startTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InterviewScalarFieldEnum = (typeof InterviewScalarFieldEnum)[keyof typeof InterviewScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    userId: 'userId',
    jobId: 'jobId',
    review: 'review',
    CultureRating: 'CultureRating',
    balanceRating: 'balanceRating',
    facilityRating: 'facilityRating',
    careerRating: 'careerRating',
    salary: 'salary',
    createdAt: 'createdAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    subscriptionId: 'subscriptionId',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const AssessmentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type AssessmentScalarFieldEnum = (typeof AssessmentScalarFieldEnum)[keyof typeof AssessmentScalarFieldEnum]


  export const UserAssessmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    assessmentId: 'assessmentId',
    score: 'score',
    certificateId: 'certificateId',
    status: 'status',
    endTime: 'endTime'
  };

  export type UserAssessmentScalarFieldEnum = (typeof UserAssessmentScalarFieldEnum)[keyof typeof UserAssessmentScalarFieldEnum]


  export const AssessmentQuestionScalarFieldEnum: {
    id: 'id',
    assessmentId: 'assessmentId',
    question: 'question',
    options: 'options',
    correctAnswer: 'correctAnswer'
  };

  export type AssessmentQuestionScalarFieldEnum = (typeof AssessmentQuestionScalarFieldEnum)[keyof typeof AssessmentQuestionScalarFieldEnum]


  export const CertificateScalarFieldEnum: {
    id: 'id',
    CertificateUrl: 'CertificateUrl',
    badgeName: 'badgeName',
    badgeIcon: 'badgeIcon',
    createdAt: 'createdAt'
  };

  export type CertificateScalarFieldEnum = (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum]


  export const UserSubscriptionScalarFieldEnum: {
    userId: 'userId',
    subscriptionId: 'subscriptionId',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    assessmentCount: 'assessmentCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSubscriptionScalarFieldEnum = (typeof UserSubscriptionScalarFieldEnum)[keyof typeof UserSubscriptionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'LastEdu'
   */
  export type EnumLastEduFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LastEdu'>
    


  /**
   * Reference to a field of type 'LastEdu[]'
   */
  export type ListEnumLastEduFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LastEdu[]'>
    


  /**
   * Reference to a field of type 'JobCategory'
   */
  export type EnumJobCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobCategory'>
    


  /**
   * Reference to a field of type 'JobCategory[]'
   */
  export type ListEnumJobCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobCategory[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'SubscriptionCategory'
   */
  export type EnumSubscriptionCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionCategory'>
    


  /**
   * Reference to a field of type 'SubscriptionCategory[]'
   */
  export type ListEnumSubscriptionCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionCategory[]'>
    


  /**
   * Reference to a field of type 'JobApplicationStatus'
   */
  export type EnumJobApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobApplicationStatus'>
    


  /**
   * Reference to a field of type 'JobApplicationStatus[]'
   */
  export type ListEnumJobApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobApplicationStatus[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'UserAssessmentStatus'
   */
  export type EnumUserAssessmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserAssessmentStatus'>
    


  /**
   * Reference to a field of type 'UserAssessmentStatus[]'
   */
  export type ListEnumUserAssessmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserAssessmentStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    fullname?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    isVerified?: BoolFilter<"User"> | boolean
    avatar?: StringFilter<"User"> | string
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    dob?: DateTimeNullableFilter<"User"> | Date | string | null
    lastEdu?: EnumLastEduNullableFilter<"User"> | $Enums.LastEdu | null
    domicileId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    CurriculumVitae?: CurriculumVitaeListRelationFilter
    JobApplication?: JobApplicationListRelationFilter
    Review?: ReviewListRelationFilter
    Transaction?: TransactionListRelationFilter
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    UserAssessment?: UserAssessmentListRelationFilter
    UserSubscription?: UserSubscriptionListRelationFilter
    Interview?: InterviewListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    fullname?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    isVerified?: SortOrder
    avatar?: SortOrder
    gender?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    lastEdu?: SortOrderInput | SortOrder
    domicileId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    CurriculumVitae?: CurriculumVitaeOrderByRelationAggregateInput
    JobApplication?: JobApplicationOrderByRelationAggregateInput
    Review?: ReviewOrderByRelationAggregateInput
    Transaction?: TransactionOrderByRelationAggregateInput
    location?: LocationOrderByWithRelationInput
    UserAssessment?: UserAssessmentOrderByRelationAggregateInput
    UserSubscription?: UserSubscriptionOrderByRelationAggregateInput
    Interview?: InterviewOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    fullname?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    isVerified?: BoolFilter<"User"> | boolean
    avatar?: StringFilter<"User"> | string
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    dob?: DateTimeNullableFilter<"User"> | Date | string | null
    lastEdu?: EnumLastEduNullableFilter<"User"> | $Enums.LastEdu | null
    domicileId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    CurriculumVitae?: CurriculumVitaeListRelationFilter
    JobApplication?: JobApplicationListRelationFilter
    Review?: ReviewListRelationFilter
    Transaction?: TransactionListRelationFilter
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    UserAssessment?: UserAssessmentListRelationFilter
    UserSubscription?: UserSubscriptionListRelationFilter
    Interview?: InterviewListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    fullname?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    isVerified?: SortOrder
    avatar?: SortOrder
    gender?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    lastEdu?: SortOrderInput | SortOrder
    domicileId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    fullname?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    avatar?: StringWithAggregatesFilter<"User"> | string
    gender?: EnumGenderNullableWithAggregatesFilter<"User"> | $Enums.Gender | null
    dob?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastEdu?: EnumLastEduNullableWithAggregatesFilter<"User"> | $Enums.LastEdu | null
    domicileId?: IntNullableWithAggregatesFilter<"User"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    companyName?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    description?: StringFilter<"Admin"> | string
    isVerified?: BoolFilter<"Admin"> | boolean
    logo?: StringNullableFilter<"Admin"> | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    noHandphone?: StringFilter<"Admin"> | string
    Job?: JobListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    companyName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    description?: SortOrder
    isVerified?: SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    noHandphone?: SortOrder
    Job?: JobOrderByRelationAggregateInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    companyName?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    description?: StringFilter<"Admin"> | string
    isVerified?: BoolFilter<"Admin"> | boolean
    logo?: StringNullableFilter<"Admin"> | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    noHandphone?: StringFilter<"Admin"> | string
    Job?: JobListRelationFilter
  }, "id" | "email">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    companyName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    description?: SortOrder
    isVerified?: SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    noHandphone?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    companyName?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    password?: StringWithAggregatesFilter<"Admin"> | string
    description?: StringWithAggregatesFilter<"Admin"> | string
    isVerified?: BoolWithAggregatesFilter<"Admin"> | boolean
    logo?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    noHandphone?: StringWithAggregatesFilter<"Admin"> | string
  }

  export type DeveloperWhereInput = {
    AND?: DeveloperWhereInput | DeveloperWhereInput[]
    OR?: DeveloperWhereInput[]
    NOT?: DeveloperWhereInput | DeveloperWhereInput[]
    id?: IntFilter<"Developer"> | number
    email?: StringFilter<"Developer"> | string
    password?: StringFilter<"Developer"> | string
  }

  export type DeveloperOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type DeveloperWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: DeveloperWhereInput | DeveloperWhereInput[]
    OR?: DeveloperWhereInput[]
    NOT?: DeveloperWhereInput | DeveloperWhereInput[]
    password?: StringFilter<"Developer"> | string
  }, "id" | "email">

  export type DeveloperOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    _count?: DeveloperCountOrderByAggregateInput
    _avg?: DeveloperAvgOrderByAggregateInput
    _max?: DeveloperMaxOrderByAggregateInput
    _min?: DeveloperMinOrderByAggregateInput
    _sum?: DeveloperSumOrderByAggregateInput
  }

  export type DeveloperScalarWhereWithAggregatesInput = {
    AND?: DeveloperScalarWhereWithAggregatesInput | DeveloperScalarWhereWithAggregatesInput[]
    OR?: DeveloperScalarWhereWithAggregatesInput[]
    NOT?: DeveloperScalarWhereWithAggregatesInput | DeveloperScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Developer"> | number
    email?: StringWithAggregatesFilter<"Developer"> | string
    password?: StringWithAggregatesFilter<"Developer"> | string
  }

  export type JobWhereInput = {
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    id?: StringFilter<"Job"> | string
    title?: StringFilter<"Job"> | string
    adminId?: IntFilter<"Job"> | number
    banner?: StringNullableFilter<"Job"> | string | null
    category?: EnumJobCategoryFilter<"Job"> | $Enums.JobCategory
    role?: StringFilter<"Job"> | string
    salary?: IntNullableFilter<"Job"> | number | null
    description?: StringFilter<"Job"> | string
    endDate?: DateTimeFilter<"Job"> | Date | string
    isPublished?: BoolFilter<"Job"> | boolean
    isTestActive?: BoolFilter<"Job"> | boolean
    tags?: StringNullableListFilter<"Job">
    locationId?: IntFilter<"Job"> | number
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    isActive?: BoolFilter<"Job"> | boolean
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    JobApplication?: JobApplicationListRelationFilter
    PreSelectionTest?: PreSelectionTestListRelationFilter
    Review?: ReviewListRelationFilter
    Interview?: InterviewListRelationFilter
  }

  export type JobOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    adminId?: SortOrder
    banner?: SortOrderInput | SortOrder
    category?: SortOrder
    role?: SortOrder
    salary?: SortOrderInput | SortOrder
    description?: SortOrder
    endDate?: SortOrder
    isPublished?: SortOrder
    isTestActive?: SortOrder
    tags?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    admin?: AdminOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    JobApplication?: JobApplicationOrderByRelationAggregateInput
    PreSelectionTest?: PreSelectionTestOrderByRelationAggregateInput
    Review?: ReviewOrderByRelationAggregateInput
    Interview?: InterviewOrderByRelationAggregateInput
  }

  export type JobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    title?: StringFilter<"Job"> | string
    adminId?: IntFilter<"Job"> | number
    banner?: StringNullableFilter<"Job"> | string | null
    category?: EnumJobCategoryFilter<"Job"> | $Enums.JobCategory
    role?: StringFilter<"Job"> | string
    salary?: IntNullableFilter<"Job"> | number | null
    description?: StringFilter<"Job"> | string
    endDate?: DateTimeFilter<"Job"> | Date | string
    isPublished?: BoolFilter<"Job"> | boolean
    isTestActive?: BoolFilter<"Job"> | boolean
    tags?: StringNullableListFilter<"Job">
    locationId?: IntFilter<"Job"> | number
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    isActive?: BoolFilter<"Job"> | boolean
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    JobApplication?: JobApplicationListRelationFilter
    PreSelectionTest?: PreSelectionTestListRelationFilter
    Review?: ReviewListRelationFilter
    Interview?: InterviewListRelationFilter
  }, "id">

  export type JobOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    adminId?: SortOrder
    banner?: SortOrderInput | SortOrder
    category?: SortOrder
    role?: SortOrder
    salary?: SortOrderInput | SortOrder
    description?: SortOrder
    endDate?: SortOrder
    isPublished?: SortOrder
    isTestActive?: SortOrder
    tags?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    _count?: JobCountOrderByAggregateInput
    _avg?: JobAvgOrderByAggregateInput
    _max?: JobMaxOrderByAggregateInput
    _min?: JobMinOrderByAggregateInput
    _sum?: JobSumOrderByAggregateInput
  }

  export type JobScalarWhereWithAggregatesInput = {
    AND?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    OR?: JobScalarWhereWithAggregatesInput[]
    NOT?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Job"> | string
    title?: StringWithAggregatesFilter<"Job"> | string
    adminId?: IntWithAggregatesFilter<"Job"> | number
    banner?: StringNullableWithAggregatesFilter<"Job"> | string | null
    category?: EnumJobCategoryWithAggregatesFilter<"Job"> | $Enums.JobCategory
    role?: StringWithAggregatesFilter<"Job"> | string
    salary?: IntNullableWithAggregatesFilter<"Job"> | number | null
    description?: StringWithAggregatesFilter<"Job"> | string
    endDate?: DateTimeWithAggregatesFilter<"Job"> | Date | string
    isPublished?: BoolWithAggregatesFilter<"Job"> | boolean
    isTestActive?: BoolWithAggregatesFilter<"Job"> | boolean
    tags?: StringNullableListFilter<"Job">
    locationId?: IntWithAggregatesFilter<"Job"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Job"> | boolean
  }

  export type CurriculumVitaeWhereInput = {
    AND?: CurriculumVitaeWhereInput | CurriculumVitaeWhereInput[]
    OR?: CurriculumVitaeWhereInput[]
    NOT?: CurriculumVitaeWhereInput | CurriculumVitaeWhereInput[]
    id?: IntFilter<"CurriculumVitae"> | number
    userId?: IntFilter<"CurriculumVitae"> | number
    summary?: StringFilter<"CurriculumVitae"> | string
    experience?: StringFilter<"CurriculumVitae"> | string
    skill?: StringFilter<"CurriculumVitae"> | string
    education?: StringFilter<"CurriculumVitae"> | string
    createdAt?: DateTimeFilter<"CurriculumVitae"> | Date | string
    updatedAt?: DateTimeFilter<"CurriculumVitae"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CurriculumVitaeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    summary?: SortOrder
    experience?: SortOrder
    skill?: SortOrder
    education?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CurriculumVitaeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CurriculumVitaeWhereInput | CurriculumVitaeWhereInput[]
    OR?: CurriculumVitaeWhereInput[]
    NOT?: CurriculumVitaeWhereInput | CurriculumVitaeWhereInput[]
    userId?: IntFilter<"CurriculumVitae"> | number
    summary?: StringFilter<"CurriculumVitae"> | string
    experience?: StringFilter<"CurriculumVitae"> | string
    skill?: StringFilter<"CurriculumVitae"> | string
    education?: StringFilter<"CurriculumVitae"> | string
    createdAt?: DateTimeFilter<"CurriculumVitae"> | Date | string
    updatedAt?: DateTimeFilter<"CurriculumVitae"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CurriculumVitaeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    summary?: SortOrder
    experience?: SortOrder
    skill?: SortOrder
    education?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CurriculumVitaeCountOrderByAggregateInput
    _avg?: CurriculumVitaeAvgOrderByAggregateInput
    _max?: CurriculumVitaeMaxOrderByAggregateInput
    _min?: CurriculumVitaeMinOrderByAggregateInput
    _sum?: CurriculumVitaeSumOrderByAggregateInput
  }

  export type CurriculumVitaeScalarWhereWithAggregatesInput = {
    AND?: CurriculumVitaeScalarWhereWithAggregatesInput | CurriculumVitaeScalarWhereWithAggregatesInput[]
    OR?: CurriculumVitaeScalarWhereWithAggregatesInput[]
    NOT?: CurriculumVitaeScalarWhereWithAggregatesInput | CurriculumVitaeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CurriculumVitae"> | number
    userId?: IntWithAggregatesFilter<"CurriculumVitae"> | number
    summary?: StringWithAggregatesFilter<"CurriculumVitae"> | string
    experience?: StringWithAggregatesFilter<"CurriculumVitae"> | string
    skill?: StringWithAggregatesFilter<"CurriculumVitae"> | string
    education?: StringWithAggregatesFilter<"CurriculumVitae"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CurriculumVitae"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CurriculumVitae"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: IntFilter<"Location"> | number
    city?: StringFilter<"Location"> | string
    province?: StringFilter<"Location"> | string
    latitude?: FloatFilter<"Location"> | number
    longitude?: FloatFilter<"Location"> | number
    Job?: JobListRelationFilter
    User?: UserListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    city?: SortOrder
    province?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    Job?: JobOrderByRelationAggregateInput
    User?: UserOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    city?: StringFilter<"Location"> | string
    province?: StringFilter<"Location"> | string
    latitude?: FloatFilter<"Location"> | number
    longitude?: FloatFilter<"Location"> | number
    Job?: JobListRelationFilter
    User?: UserListRelationFilter
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    city?: SortOrder
    province?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Location"> | number
    city?: StringWithAggregatesFilter<"Location"> | string
    province?: StringWithAggregatesFilter<"Location"> | string
    latitude?: FloatWithAggregatesFilter<"Location"> | number
    longitude?: FloatWithAggregatesFilter<"Location"> | number
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: IntFilter<"Subscription"> | number
    category?: EnumSubscriptionCategoryFilter<"Subscription"> | $Enums.SubscriptionCategory
    price?: IntFilter<"Subscription"> | number
    feature?: StringFilter<"Subscription"> | string
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    Transaction?: TransactionListRelationFilter
    UserSubscription?: UserSubscriptionListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    price?: SortOrder
    feature?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Transaction?: TransactionOrderByRelationAggregateInput
    UserSubscription?: UserSubscriptionOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    category?: EnumSubscriptionCategoryFilter<"Subscription"> | $Enums.SubscriptionCategory
    price?: IntFilter<"Subscription"> | number
    feature?: StringFilter<"Subscription"> | string
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    Transaction?: TransactionListRelationFilter
    UserSubscription?: UserSubscriptionListRelationFilter
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    price?: SortOrder
    feature?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subscription"> | number
    category?: EnumSubscriptionCategoryWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionCategory
    price?: IntWithAggregatesFilter<"Subscription"> | number
    feature?: StringWithAggregatesFilter<"Subscription"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type PreSelectionTestWhereInput = {
    AND?: PreSelectionTestWhereInput | PreSelectionTestWhereInput[]
    OR?: PreSelectionTestWhereInput[]
    NOT?: PreSelectionTestWhereInput | PreSelectionTestWhereInput[]
    id?: IntFilter<"PreSelectionTest"> | number
    title?: StringFilter<"PreSelectionTest"> | string
    description?: StringFilter<"PreSelectionTest"> | string
    jobId?: StringFilter<"PreSelectionTest"> | string
    createdAt?: DateTimeFilter<"PreSelectionTest"> | Date | string
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
    SelectionTestQuestion?: SelectionTestQuestionListRelationFilter
  }

  export type PreSelectionTestOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    job?: JobOrderByWithRelationInput
    SelectionTestQuestion?: SelectionTestQuestionOrderByRelationAggregateInput
  }

  export type PreSelectionTestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PreSelectionTestWhereInput | PreSelectionTestWhereInput[]
    OR?: PreSelectionTestWhereInput[]
    NOT?: PreSelectionTestWhereInput | PreSelectionTestWhereInput[]
    title?: StringFilter<"PreSelectionTest"> | string
    description?: StringFilter<"PreSelectionTest"> | string
    jobId?: StringFilter<"PreSelectionTest"> | string
    createdAt?: DateTimeFilter<"PreSelectionTest"> | Date | string
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
    SelectionTestQuestion?: SelectionTestQuestionListRelationFilter
  }, "id">

  export type PreSelectionTestOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
    _count?: PreSelectionTestCountOrderByAggregateInput
    _avg?: PreSelectionTestAvgOrderByAggregateInput
    _max?: PreSelectionTestMaxOrderByAggregateInput
    _min?: PreSelectionTestMinOrderByAggregateInput
    _sum?: PreSelectionTestSumOrderByAggregateInput
  }

  export type PreSelectionTestScalarWhereWithAggregatesInput = {
    AND?: PreSelectionTestScalarWhereWithAggregatesInput | PreSelectionTestScalarWhereWithAggregatesInput[]
    OR?: PreSelectionTestScalarWhereWithAggregatesInput[]
    NOT?: PreSelectionTestScalarWhereWithAggregatesInput | PreSelectionTestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PreSelectionTest"> | number
    title?: StringWithAggregatesFilter<"PreSelectionTest"> | string
    description?: StringWithAggregatesFilter<"PreSelectionTest"> | string
    jobId?: StringWithAggregatesFilter<"PreSelectionTest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PreSelectionTest"> | Date | string
  }

  export type SelectionTestQuestionWhereInput = {
    AND?: SelectionTestQuestionWhereInput | SelectionTestQuestionWhereInput[]
    OR?: SelectionTestQuestionWhereInput[]
    NOT?: SelectionTestQuestionWhereInput | SelectionTestQuestionWhereInput[]
    id?: IntFilter<"SelectionTestQuestion"> | number
    preSelectionTestId?: IntFilter<"SelectionTestQuestion"> | number
    question?: StringFilter<"SelectionTestQuestion"> | string
    options?: StringNullableListFilter<"SelectionTestQuestion">
    correctAnswer?: IntFilter<"SelectionTestQuestion"> | number
    preSelectionTest?: XOR<PreSelectionTestScalarRelationFilter, PreSelectionTestWhereInput>
  }

  export type SelectionTestQuestionOrderByWithRelationInput = {
    id?: SortOrder
    preSelectionTestId?: SortOrder
    question?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    preSelectionTest?: PreSelectionTestOrderByWithRelationInput
  }

  export type SelectionTestQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SelectionTestQuestionWhereInput | SelectionTestQuestionWhereInput[]
    OR?: SelectionTestQuestionWhereInput[]
    NOT?: SelectionTestQuestionWhereInput | SelectionTestQuestionWhereInput[]
    preSelectionTestId?: IntFilter<"SelectionTestQuestion"> | number
    question?: StringFilter<"SelectionTestQuestion"> | string
    options?: StringNullableListFilter<"SelectionTestQuestion">
    correctAnswer?: IntFilter<"SelectionTestQuestion"> | number
    preSelectionTest?: XOR<PreSelectionTestScalarRelationFilter, PreSelectionTestWhereInput>
  }, "id">

  export type SelectionTestQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    preSelectionTestId?: SortOrder
    question?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    _count?: SelectionTestQuestionCountOrderByAggregateInput
    _avg?: SelectionTestQuestionAvgOrderByAggregateInput
    _max?: SelectionTestQuestionMaxOrderByAggregateInput
    _min?: SelectionTestQuestionMinOrderByAggregateInput
    _sum?: SelectionTestQuestionSumOrderByAggregateInput
  }

  export type SelectionTestQuestionScalarWhereWithAggregatesInput = {
    AND?: SelectionTestQuestionScalarWhereWithAggregatesInput | SelectionTestQuestionScalarWhereWithAggregatesInput[]
    OR?: SelectionTestQuestionScalarWhereWithAggregatesInput[]
    NOT?: SelectionTestQuestionScalarWhereWithAggregatesInput | SelectionTestQuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SelectionTestQuestion"> | number
    preSelectionTestId?: IntWithAggregatesFilter<"SelectionTestQuestion"> | number
    question?: StringWithAggregatesFilter<"SelectionTestQuestion"> | string
    options?: StringNullableListFilter<"SelectionTestQuestion">
    correctAnswer?: IntWithAggregatesFilter<"SelectionTestQuestion"> | number
  }

  export type JobApplicationWhereInput = {
    AND?: JobApplicationWhereInput | JobApplicationWhereInput[]
    OR?: JobApplicationWhereInput[]
    NOT?: JobApplicationWhereInput | JobApplicationWhereInput[]
    userId?: IntFilter<"JobApplication"> | number
    jobId?: StringFilter<"JobApplication"> | string
    resume?: StringFilter<"JobApplication"> | string
    expectedSalary?: IntFilter<"JobApplication"> | number
    status?: EnumJobApplicationStatusFilter<"JobApplication"> | $Enums.JobApplicationStatus
    isTaken?: BoolFilter<"JobApplication"> | boolean
    rejectedReview?: StringNullableFilter<"JobApplication"> | string | null
    selectionTestResult?: IntNullableFilter<"JobApplication"> | number | null
    createdAt?: DateTimeFilter<"JobApplication"> | Date | string
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type JobApplicationOrderByWithRelationInput = {
    userId?: SortOrder
    jobId?: SortOrder
    resume?: SortOrder
    expectedSalary?: SortOrder
    status?: SortOrder
    isTaken?: SortOrder
    rejectedReview?: SortOrderInput | SortOrder
    selectionTestResult?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    job?: JobOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type JobApplicationWhereUniqueInput = Prisma.AtLeast<{
    userId_jobId?: JobApplicationUserIdJobIdCompoundUniqueInput
    AND?: JobApplicationWhereInput | JobApplicationWhereInput[]
    OR?: JobApplicationWhereInput[]
    NOT?: JobApplicationWhereInput | JobApplicationWhereInput[]
    userId?: IntFilter<"JobApplication"> | number
    jobId?: StringFilter<"JobApplication"> | string
    resume?: StringFilter<"JobApplication"> | string
    expectedSalary?: IntFilter<"JobApplication"> | number
    status?: EnumJobApplicationStatusFilter<"JobApplication"> | $Enums.JobApplicationStatus
    isTaken?: BoolFilter<"JobApplication"> | boolean
    rejectedReview?: StringNullableFilter<"JobApplication"> | string | null
    selectionTestResult?: IntNullableFilter<"JobApplication"> | number | null
    createdAt?: DateTimeFilter<"JobApplication"> | Date | string
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId_jobId">

  export type JobApplicationOrderByWithAggregationInput = {
    userId?: SortOrder
    jobId?: SortOrder
    resume?: SortOrder
    expectedSalary?: SortOrder
    status?: SortOrder
    isTaken?: SortOrder
    rejectedReview?: SortOrderInput | SortOrder
    selectionTestResult?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: JobApplicationCountOrderByAggregateInput
    _avg?: JobApplicationAvgOrderByAggregateInput
    _max?: JobApplicationMaxOrderByAggregateInput
    _min?: JobApplicationMinOrderByAggregateInput
    _sum?: JobApplicationSumOrderByAggregateInput
  }

  export type JobApplicationScalarWhereWithAggregatesInput = {
    AND?: JobApplicationScalarWhereWithAggregatesInput | JobApplicationScalarWhereWithAggregatesInput[]
    OR?: JobApplicationScalarWhereWithAggregatesInput[]
    NOT?: JobApplicationScalarWhereWithAggregatesInput | JobApplicationScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"JobApplication"> | number
    jobId?: StringWithAggregatesFilter<"JobApplication"> | string
    resume?: StringWithAggregatesFilter<"JobApplication"> | string
    expectedSalary?: IntWithAggregatesFilter<"JobApplication"> | number
    status?: EnumJobApplicationStatusWithAggregatesFilter<"JobApplication"> | $Enums.JobApplicationStatus
    isTaken?: BoolWithAggregatesFilter<"JobApplication"> | boolean
    rejectedReview?: StringNullableWithAggregatesFilter<"JobApplication"> | string | null
    selectionTestResult?: IntNullableWithAggregatesFilter<"JobApplication"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"JobApplication"> | Date | string
  }

  export type InterviewWhereInput = {
    AND?: InterviewWhereInput | InterviewWhereInput[]
    OR?: InterviewWhereInput[]
    NOT?: InterviewWhereInput | InterviewWhereInput[]
    userId?: IntFilter<"Interview"> | number
    jobId?: StringFilter<"Interview"> | string
    startTime?: DateTimeFilter<"Interview"> | Date | string
    createdAt?: DateTimeFilter<"Interview"> | Date | string
    updatedAt?: DateTimeFilter<"Interview"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
  }

  export type InterviewOrderByWithRelationInput = {
    userId?: SortOrder
    jobId?: SortOrder
    startTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    job?: JobOrderByWithRelationInput
  }

  export type InterviewWhereUniqueInput = Prisma.AtLeast<{
    userId_jobId?: InterviewUserIdJobIdCompoundUniqueInput
    AND?: InterviewWhereInput | InterviewWhereInput[]
    OR?: InterviewWhereInput[]
    NOT?: InterviewWhereInput | InterviewWhereInput[]
    userId?: IntFilter<"Interview"> | number
    jobId?: StringFilter<"Interview"> | string
    startTime?: DateTimeFilter<"Interview"> | Date | string
    createdAt?: DateTimeFilter<"Interview"> | Date | string
    updatedAt?: DateTimeFilter<"Interview"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
  }, "userId_jobId">

  export type InterviewOrderByWithAggregationInput = {
    userId?: SortOrder
    jobId?: SortOrder
    startTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InterviewCountOrderByAggregateInput
    _avg?: InterviewAvgOrderByAggregateInput
    _max?: InterviewMaxOrderByAggregateInput
    _min?: InterviewMinOrderByAggregateInput
    _sum?: InterviewSumOrderByAggregateInput
  }

  export type InterviewScalarWhereWithAggregatesInput = {
    AND?: InterviewScalarWhereWithAggregatesInput | InterviewScalarWhereWithAggregatesInput[]
    OR?: InterviewScalarWhereWithAggregatesInput[]
    NOT?: InterviewScalarWhereWithAggregatesInput | InterviewScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"Interview"> | number
    jobId?: StringWithAggregatesFilter<"Interview"> | string
    startTime?: DateTimeWithAggregatesFilter<"Interview"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Interview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Interview"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    userId?: IntFilter<"Review"> | number
    jobId?: StringFilter<"Review"> | string
    review?: StringFilter<"Review"> | string
    CultureRating?: IntFilter<"Review"> | number
    balanceRating?: IntFilter<"Review"> | number
    facilityRating?: IntFilter<"Review"> | number
    careerRating?: IntFilter<"Review"> | number
    salary?: IntFilter<"Review"> | number
    createdAt?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    userId?: SortOrder
    jobId?: SortOrder
    review?: SortOrder
    CultureRating?: SortOrder
    balanceRating?: SortOrder
    facilityRating?: SortOrder
    careerRating?: SortOrder
    salary?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    job?: JobOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    userId_jobId?: ReviewUserIdJobIdCompoundUniqueInput
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    userId?: IntFilter<"Review"> | number
    jobId?: StringFilter<"Review"> | string
    review?: StringFilter<"Review"> | string
    CultureRating?: IntFilter<"Review"> | number
    balanceRating?: IntFilter<"Review"> | number
    facilityRating?: IntFilter<"Review"> | number
    careerRating?: IntFilter<"Review"> | number
    salary?: IntFilter<"Review"> | number
    createdAt?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
  }, "userId_jobId">

  export type ReviewOrderByWithAggregationInput = {
    userId?: SortOrder
    jobId?: SortOrder
    review?: SortOrder
    CultureRating?: SortOrder
    balanceRating?: SortOrder
    facilityRating?: SortOrder
    careerRating?: SortOrder
    salary?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"Review"> | number
    jobId?: StringWithAggregatesFilter<"Review"> | string
    review?: StringWithAggregatesFilter<"Review"> | string
    CultureRating?: IntWithAggregatesFilter<"Review"> | number
    balanceRating?: IntWithAggregatesFilter<"Review"> | number
    facilityRating?: IntWithAggregatesFilter<"Review"> | number
    careerRating?: IntWithAggregatesFilter<"Review"> | number
    salary?: IntWithAggregatesFilter<"Review"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: IntFilter<"Transaction"> | number
    subscriptionId?: IntFilter<"Transaction"> | number
    amount?: IntFilter<"Transaction"> | number
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    userId?: IntFilter<"Transaction"> | number
    subscriptionId?: IntFilter<"Transaction"> | number
    amount?: IntFilter<"Transaction"> | number
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    userId?: IntWithAggregatesFilter<"Transaction"> | number
    subscriptionId?: IntWithAggregatesFilter<"Transaction"> | number
    amount?: IntWithAggregatesFilter<"Transaction"> | number
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type AssessmentWhereInput = {
    AND?: AssessmentWhereInput | AssessmentWhereInput[]
    OR?: AssessmentWhereInput[]
    NOT?: AssessmentWhereInput | AssessmentWhereInput[]
    id?: IntFilter<"Assessment"> | number
    title?: StringFilter<"Assessment"> | string
    description?: StringFilter<"Assessment"> | string
    isActive?: BoolFilter<"Assessment"> | boolean
    createdAt?: DateTimeFilter<"Assessment"> | Date | string
    AssessmentQuestion?: AssessmentQuestionListRelationFilter
    UserAssessment?: UserAssessmentListRelationFilter
  }

  export type AssessmentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    AssessmentQuestion?: AssessmentQuestionOrderByRelationAggregateInput
    UserAssessment?: UserAssessmentOrderByRelationAggregateInput
  }

  export type AssessmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssessmentWhereInput | AssessmentWhereInput[]
    OR?: AssessmentWhereInput[]
    NOT?: AssessmentWhereInput | AssessmentWhereInput[]
    title?: StringFilter<"Assessment"> | string
    description?: StringFilter<"Assessment"> | string
    isActive?: BoolFilter<"Assessment"> | boolean
    createdAt?: DateTimeFilter<"Assessment"> | Date | string
    AssessmentQuestion?: AssessmentQuestionListRelationFilter
    UserAssessment?: UserAssessmentListRelationFilter
  }, "id">

  export type AssessmentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: AssessmentCountOrderByAggregateInput
    _avg?: AssessmentAvgOrderByAggregateInput
    _max?: AssessmentMaxOrderByAggregateInput
    _min?: AssessmentMinOrderByAggregateInput
    _sum?: AssessmentSumOrderByAggregateInput
  }

  export type AssessmentScalarWhereWithAggregatesInput = {
    AND?: AssessmentScalarWhereWithAggregatesInput | AssessmentScalarWhereWithAggregatesInput[]
    OR?: AssessmentScalarWhereWithAggregatesInput[]
    NOT?: AssessmentScalarWhereWithAggregatesInput | AssessmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Assessment"> | number
    title?: StringWithAggregatesFilter<"Assessment"> | string
    description?: StringWithAggregatesFilter<"Assessment"> | string
    isActive?: BoolWithAggregatesFilter<"Assessment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Assessment"> | Date | string
  }

  export type UserAssessmentWhereInput = {
    AND?: UserAssessmentWhereInput | UserAssessmentWhereInput[]
    OR?: UserAssessmentWhereInput[]
    NOT?: UserAssessmentWhereInput | UserAssessmentWhereInput[]
    id?: IntFilter<"UserAssessment"> | number
    userId?: IntFilter<"UserAssessment"> | number
    assessmentId?: IntFilter<"UserAssessment"> | number
    score?: IntFilter<"UserAssessment"> | number
    certificateId?: IntNullableFilter<"UserAssessment"> | number | null
    status?: EnumUserAssessmentStatusNullableFilter<"UserAssessment"> | $Enums.UserAssessmentStatus | null
    endTime?: DateTimeFilter<"UserAssessment"> | Date | string
    certificate?: XOR<CertificateNullableScalarRelationFilter, CertificateWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    assessment?: XOR<AssessmentScalarRelationFilter, AssessmentWhereInput>
  }

  export type UserAssessmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentId?: SortOrder
    score?: SortOrder
    certificateId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    endTime?: SortOrder
    certificate?: CertificateOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    assessment?: AssessmentOrderByWithRelationInput
  }

  export type UserAssessmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserAssessmentWhereInput | UserAssessmentWhereInput[]
    OR?: UserAssessmentWhereInput[]
    NOT?: UserAssessmentWhereInput | UserAssessmentWhereInput[]
    userId?: IntFilter<"UserAssessment"> | number
    assessmentId?: IntFilter<"UserAssessment"> | number
    score?: IntFilter<"UserAssessment"> | number
    certificateId?: IntNullableFilter<"UserAssessment"> | number | null
    status?: EnumUserAssessmentStatusNullableFilter<"UserAssessment"> | $Enums.UserAssessmentStatus | null
    endTime?: DateTimeFilter<"UserAssessment"> | Date | string
    certificate?: XOR<CertificateNullableScalarRelationFilter, CertificateWhereInput> | null
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    assessment?: XOR<AssessmentScalarRelationFilter, AssessmentWhereInput>
  }, "id">

  export type UserAssessmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentId?: SortOrder
    score?: SortOrder
    certificateId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    endTime?: SortOrder
    _count?: UserAssessmentCountOrderByAggregateInput
    _avg?: UserAssessmentAvgOrderByAggregateInput
    _max?: UserAssessmentMaxOrderByAggregateInput
    _min?: UserAssessmentMinOrderByAggregateInput
    _sum?: UserAssessmentSumOrderByAggregateInput
  }

  export type UserAssessmentScalarWhereWithAggregatesInput = {
    AND?: UserAssessmentScalarWhereWithAggregatesInput | UserAssessmentScalarWhereWithAggregatesInput[]
    OR?: UserAssessmentScalarWhereWithAggregatesInput[]
    NOT?: UserAssessmentScalarWhereWithAggregatesInput | UserAssessmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserAssessment"> | number
    userId?: IntWithAggregatesFilter<"UserAssessment"> | number
    assessmentId?: IntWithAggregatesFilter<"UserAssessment"> | number
    score?: IntWithAggregatesFilter<"UserAssessment"> | number
    certificateId?: IntNullableWithAggregatesFilter<"UserAssessment"> | number | null
    status?: EnumUserAssessmentStatusNullableWithAggregatesFilter<"UserAssessment"> | $Enums.UserAssessmentStatus | null
    endTime?: DateTimeWithAggregatesFilter<"UserAssessment"> | Date | string
  }

  export type AssessmentQuestionWhereInput = {
    AND?: AssessmentQuestionWhereInput | AssessmentQuestionWhereInput[]
    OR?: AssessmentQuestionWhereInput[]
    NOT?: AssessmentQuestionWhereInput | AssessmentQuestionWhereInput[]
    id?: IntFilter<"AssessmentQuestion"> | number
    assessmentId?: IntFilter<"AssessmentQuestion"> | number
    question?: StringFilter<"AssessmentQuestion"> | string
    options?: StringNullableListFilter<"AssessmentQuestion">
    correctAnswer?: IntFilter<"AssessmentQuestion"> | number
    assessment?: XOR<AssessmentScalarRelationFilter, AssessmentWhereInput>
  }

  export type AssessmentQuestionOrderByWithRelationInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    question?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    assessment?: AssessmentOrderByWithRelationInput
  }

  export type AssessmentQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssessmentQuestionWhereInput | AssessmentQuestionWhereInput[]
    OR?: AssessmentQuestionWhereInput[]
    NOT?: AssessmentQuestionWhereInput | AssessmentQuestionWhereInput[]
    assessmentId?: IntFilter<"AssessmentQuestion"> | number
    question?: StringFilter<"AssessmentQuestion"> | string
    options?: StringNullableListFilter<"AssessmentQuestion">
    correctAnswer?: IntFilter<"AssessmentQuestion"> | number
    assessment?: XOR<AssessmentScalarRelationFilter, AssessmentWhereInput>
  }, "id">

  export type AssessmentQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    question?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    _count?: AssessmentQuestionCountOrderByAggregateInput
    _avg?: AssessmentQuestionAvgOrderByAggregateInput
    _max?: AssessmentQuestionMaxOrderByAggregateInput
    _min?: AssessmentQuestionMinOrderByAggregateInput
    _sum?: AssessmentQuestionSumOrderByAggregateInput
  }

  export type AssessmentQuestionScalarWhereWithAggregatesInput = {
    AND?: AssessmentQuestionScalarWhereWithAggregatesInput | AssessmentQuestionScalarWhereWithAggregatesInput[]
    OR?: AssessmentQuestionScalarWhereWithAggregatesInput[]
    NOT?: AssessmentQuestionScalarWhereWithAggregatesInput | AssessmentQuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AssessmentQuestion"> | number
    assessmentId?: IntWithAggregatesFilter<"AssessmentQuestion"> | number
    question?: StringWithAggregatesFilter<"AssessmentQuestion"> | string
    options?: StringNullableListFilter<"AssessmentQuestion">
    correctAnswer?: IntWithAggregatesFilter<"AssessmentQuestion"> | number
  }

  export type CertificateWhereInput = {
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    id?: IntFilter<"Certificate"> | number
    CertificateUrl?: StringFilter<"Certificate"> | string
    badgeName?: StringFilter<"Certificate"> | string
    badgeIcon?: StringFilter<"Certificate"> | string
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
    UserAssessment?: UserAssessmentListRelationFilter
  }

  export type CertificateOrderByWithRelationInput = {
    id?: SortOrder
    CertificateUrl?: SortOrder
    badgeName?: SortOrder
    badgeIcon?: SortOrder
    createdAt?: SortOrder
    UserAssessment?: UserAssessmentOrderByRelationAggregateInput
  }

  export type CertificateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    CertificateUrl?: StringFilter<"Certificate"> | string
    badgeName?: StringFilter<"Certificate"> | string
    badgeIcon?: StringFilter<"Certificate"> | string
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
    UserAssessment?: UserAssessmentListRelationFilter
  }, "id">

  export type CertificateOrderByWithAggregationInput = {
    id?: SortOrder
    CertificateUrl?: SortOrder
    badgeName?: SortOrder
    badgeIcon?: SortOrder
    createdAt?: SortOrder
    _count?: CertificateCountOrderByAggregateInput
    _avg?: CertificateAvgOrderByAggregateInput
    _max?: CertificateMaxOrderByAggregateInput
    _min?: CertificateMinOrderByAggregateInput
    _sum?: CertificateSumOrderByAggregateInput
  }

  export type CertificateScalarWhereWithAggregatesInput = {
    AND?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    OR?: CertificateScalarWhereWithAggregatesInput[]
    NOT?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Certificate"> | number
    CertificateUrl?: StringWithAggregatesFilter<"Certificate"> | string
    badgeName?: StringWithAggregatesFilter<"Certificate"> | string
    badgeIcon?: StringWithAggregatesFilter<"Certificate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
  }

  export type UserSubscriptionWhereInput = {
    AND?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    OR?: UserSubscriptionWhereInput[]
    NOT?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    userId?: IntFilter<"UserSubscription"> | number
    subscriptionId?: IntFilter<"UserSubscription"> | number
    startDate?: DateTimeFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeFilter<"UserSubscription"> | Date | string
    isActive?: BoolFilter<"UserSubscription"> | boolean
    assessmentCount?: IntFilter<"UserSubscription"> | number
    createdAt?: DateTimeFilter<"UserSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"UserSubscription"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSubscriptionOrderByWithRelationInput = {
    userId?: SortOrder
    subscriptionId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    assessmentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    userId_subscriptionId?: UserSubscriptionUserIdSubscriptionIdCompoundUniqueInput
    AND?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    OR?: UserSubscriptionWhereInput[]
    NOT?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    userId?: IntFilter<"UserSubscription"> | number
    subscriptionId?: IntFilter<"UserSubscription"> | number
    startDate?: DateTimeFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeFilter<"UserSubscription"> | Date | string
    isActive?: BoolFilter<"UserSubscription"> | boolean
    assessmentCount?: IntFilter<"UserSubscription"> | number
    createdAt?: DateTimeFilter<"UserSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"UserSubscription"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId_subscriptionId">

  export type UserSubscriptionOrderByWithAggregationInput = {
    userId?: SortOrder
    subscriptionId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    assessmentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSubscriptionCountOrderByAggregateInput
    _avg?: UserSubscriptionAvgOrderByAggregateInput
    _max?: UserSubscriptionMaxOrderByAggregateInput
    _min?: UserSubscriptionMinOrderByAggregateInput
    _sum?: UserSubscriptionSumOrderByAggregateInput
  }

  export type UserSubscriptionScalarWhereWithAggregatesInput = {
    AND?: UserSubscriptionScalarWhereWithAggregatesInput | UserSubscriptionScalarWhereWithAggregatesInput[]
    OR?: UserSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: UserSubscriptionScalarWhereWithAggregatesInput | UserSubscriptionScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserSubscription"> | number
    subscriptionId?: IntWithAggregatesFilter<"UserSubscription"> | number
    startDate?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    isActive?: BoolWithAggregatesFilter<"UserSubscription"> | boolean
    assessmentCount?: IntWithAggregatesFilter<"UserSubscription"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
  }

  export type UserCreateInput = {
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CurriculumVitae?: CurriculumVitaeCreateNestedManyWithoutUserInput
    JobApplication?: JobApplicationCreateNestedManyWithoutUserInput
    Review?: ReviewCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    UserAssessment?: UserAssessmentCreateNestedManyWithoutUserInput
    UserSubscription?: UserSubscriptionCreateNestedManyWithoutUserInput
    Interview?: InterviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    domicileId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CurriculumVitae?: CurriculumVitaeUncheckedCreateNestedManyWithoutUserInput
    JobApplication?: JobApplicationUncheckedCreateNestedManyWithoutUserInput
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    UserAssessment?: UserAssessmentUncheckedCreateNestedManyWithoutUserInput
    UserSubscription?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    Interview?: InterviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CurriculumVitae?: CurriculumVitaeUpdateManyWithoutUserNestedInput
    JobApplication?: JobApplicationUpdateManyWithoutUserNestedInput
    Review?: ReviewUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    UserAssessment?: UserAssessmentUpdateManyWithoutUserNestedInput
    UserSubscription?: UserSubscriptionUpdateManyWithoutUserNestedInput
    Interview?: InterviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    domicileId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CurriculumVitae?: CurriculumVitaeUncheckedUpdateManyWithoutUserNestedInput
    JobApplication?: JobApplicationUncheckedUpdateManyWithoutUserNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    UserAssessment?: UserAssessmentUncheckedUpdateManyWithoutUserNestedInput
    UserSubscription?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Interview?: InterviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    domicileId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    domicileId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    companyName: string
    email: string
    password: string
    description: string
    isVerified?: boolean
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    noHandphone: string
    Job?: JobCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    companyName: string
    email: string
    password: string
    description: string
    isVerified?: boolean
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    noHandphone: string
    Job?: JobUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminUpdateInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    noHandphone?: StringFieldUpdateOperationsInput | string
    Job?: JobUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    noHandphone?: StringFieldUpdateOperationsInput | string
    Job?: JobUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateManyInput = {
    id?: number
    companyName: string
    email: string
    password: string
    description: string
    isVerified?: boolean
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    noHandphone: string
  }

  export type AdminUpdateManyMutationInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    noHandphone?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    noHandphone?: StringFieldUpdateOperationsInput | string
  }

  export type DeveloperCreateInput = {
    email: string
    password: string
  }

  export type DeveloperUncheckedCreateInput = {
    id?: number
    email: string
    password: string
  }

  export type DeveloperUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type DeveloperUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type DeveloperCreateManyInput = {
    id?: number
    email: string
    password: string
  }

  export type DeveloperUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type DeveloperUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type JobCreateInput = {
    id?: string
    title: string
    banner?: string | null
    category: $Enums.JobCategory
    role: string
    salary?: number | null
    description: string
    endDate: Date | string
    isPublished?: boolean
    isTestActive?: boolean
    tags?: JobCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    admin: AdminCreateNestedOneWithoutJobInput
    location: LocationCreateNestedOneWithoutJobInput
    JobApplication?: JobApplicationCreateNestedManyWithoutJobInput
    PreSelectionTest?: PreSelectionTestCreateNestedManyWithoutJobInput
    Review?: ReviewCreateNestedManyWithoutJobInput
    Interview?: InterviewCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateInput = {
    id?: string
    title: string
    adminId: number
    banner?: string | null
    category: $Enums.JobCategory
    role: string
    salary?: number | null
    description: string
    endDate: Date | string
    isPublished?: boolean
    isTestActive?: boolean
    tags?: JobCreatetagsInput | string[]
    locationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    JobApplication?: JobApplicationUncheckedCreateNestedManyWithoutJobInput
    PreSelectionTest?: PreSelectionTestUncheckedCreateNestedManyWithoutJobInput
    Review?: ReviewUncheckedCreateNestedManyWithoutJobInput
    Interview?: InterviewUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumJobCategoryFieldUpdateOperationsInput | $Enums.JobCategory
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isTestActive?: BoolFieldUpdateOperationsInput | boolean
    tags?: JobUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    admin?: AdminUpdateOneRequiredWithoutJobNestedInput
    location?: LocationUpdateOneRequiredWithoutJobNestedInput
    JobApplication?: JobApplicationUpdateManyWithoutJobNestedInput
    PreSelectionTest?: PreSelectionTestUpdateManyWithoutJobNestedInput
    Review?: ReviewUpdateManyWithoutJobNestedInput
    Interview?: InterviewUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    adminId?: IntFieldUpdateOperationsInput | number
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumJobCategoryFieldUpdateOperationsInput | $Enums.JobCategory
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isTestActive?: BoolFieldUpdateOperationsInput | boolean
    tags?: JobUpdatetagsInput | string[]
    locationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    JobApplication?: JobApplicationUncheckedUpdateManyWithoutJobNestedInput
    PreSelectionTest?: PreSelectionTestUncheckedUpdateManyWithoutJobNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutJobNestedInput
    Interview?: InterviewUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobCreateManyInput = {
    id?: string
    title: string
    adminId: number
    banner?: string | null
    category: $Enums.JobCategory
    role: string
    salary?: number | null
    description: string
    endDate: Date | string
    isPublished?: boolean
    isTestActive?: boolean
    tags?: JobCreatetagsInput | string[]
    locationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type JobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumJobCategoryFieldUpdateOperationsInput | $Enums.JobCategory
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isTestActive?: BoolFieldUpdateOperationsInput | boolean
    tags?: JobUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    adminId?: IntFieldUpdateOperationsInput | number
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumJobCategoryFieldUpdateOperationsInput | $Enums.JobCategory
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isTestActive?: BoolFieldUpdateOperationsInput | boolean
    tags?: JobUpdatetagsInput | string[]
    locationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CurriculumVitaeCreateInput = {
    summary: string
    experience: string
    skill: string
    education: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCurriculumVitaeInput
  }

  export type CurriculumVitaeUncheckedCreateInput = {
    id?: number
    userId: number
    summary: string
    experience: string
    skill: string
    education: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurriculumVitaeUpdateInput = {
    summary?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCurriculumVitaeNestedInput
  }

  export type CurriculumVitaeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    summary?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurriculumVitaeCreateManyInput = {
    id?: number
    userId: number
    summary: string
    experience: string
    skill: string
    education: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurriculumVitaeUpdateManyMutationInput = {
    summary?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurriculumVitaeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    summary?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    city: string
    province: string
    latitude: number
    longitude: number
    Job?: JobCreateNestedManyWithoutLocationInput
    User?: UserCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: number
    city: string
    province: string
    latitude: number
    longitude: number
    Job?: JobUncheckedCreateNestedManyWithoutLocationInput
    User?: UserUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    Job?: JobUpdateManyWithoutLocationNestedInput
    User?: UserUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    Job?: JobUncheckedUpdateManyWithoutLocationNestedInput
    User?: UserUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: number
    city: string
    province: string
    latitude: number
    longitude: number
  }

  export type LocationUpdateManyMutationInput = {
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type SubscriptionCreateInput = {
    category: $Enums.SubscriptionCategory
    price: number
    feature: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Transaction?: TransactionCreateNestedManyWithoutSubscriptionInput
    UserSubscription?: UserSubscriptionCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: number
    category: $Enums.SubscriptionCategory
    price: number
    feature: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Transaction?: TransactionUncheckedCreateNestedManyWithoutSubscriptionInput
    UserSubscription?: UserSubscriptionUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    category?: EnumSubscriptionCategoryFieldUpdateOperationsInput | $Enums.SubscriptionCategory
    price?: IntFieldUpdateOperationsInput | number
    feature?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Transaction?: TransactionUpdateManyWithoutSubscriptionNestedInput
    UserSubscription?: UserSubscriptionUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: EnumSubscriptionCategoryFieldUpdateOperationsInput | $Enums.SubscriptionCategory
    price?: IntFieldUpdateOperationsInput | number
    feature?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Transaction?: TransactionUncheckedUpdateManyWithoutSubscriptionNestedInput
    UserSubscription?: UserSubscriptionUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: number
    category: $Enums.SubscriptionCategory
    price: number
    feature: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    category?: EnumSubscriptionCategoryFieldUpdateOperationsInput | $Enums.SubscriptionCategory
    price?: IntFieldUpdateOperationsInput | number
    feature?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: EnumSubscriptionCategoryFieldUpdateOperationsInput | $Enums.SubscriptionCategory
    price?: IntFieldUpdateOperationsInput | number
    feature?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreSelectionTestCreateInput = {
    title: string
    description: string
    createdAt?: Date | string
    job: JobCreateNestedOneWithoutPreSelectionTestInput
    SelectionTestQuestion?: SelectionTestQuestionCreateNestedManyWithoutPreSelectionTestInput
  }

  export type PreSelectionTestUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    jobId: string
    createdAt?: Date | string
    SelectionTestQuestion?: SelectionTestQuestionUncheckedCreateNestedManyWithoutPreSelectionTestInput
  }

  export type PreSelectionTestUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutPreSelectionTestNestedInput
    SelectionTestQuestion?: SelectionTestQuestionUpdateManyWithoutPreSelectionTestNestedInput
  }

  export type PreSelectionTestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SelectionTestQuestion?: SelectionTestQuestionUncheckedUpdateManyWithoutPreSelectionTestNestedInput
  }

  export type PreSelectionTestCreateManyInput = {
    id?: number
    title: string
    description: string
    jobId: string
    createdAt?: Date | string
  }

  export type PreSelectionTestUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreSelectionTestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SelectionTestQuestionCreateInput = {
    question: string
    options?: SelectionTestQuestionCreateoptionsInput | string[]
    correctAnswer: number
    preSelectionTest: PreSelectionTestCreateNestedOneWithoutSelectionTestQuestionInput
  }

  export type SelectionTestQuestionUncheckedCreateInput = {
    id?: number
    preSelectionTestId: number
    question: string
    options?: SelectionTestQuestionCreateoptionsInput | string[]
    correctAnswer: number
  }

  export type SelectionTestQuestionUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: SelectionTestQuestionUpdateoptionsInput | string[]
    correctAnswer?: IntFieldUpdateOperationsInput | number
    preSelectionTest?: PreSelectionTestUpdateOneRequiredWithoutSelectionTestQuestionNestedInput
  }

  export type SelectionTestQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    preSelectionTestId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    options?: SelectionTestQuestionUpdateoptionsInput | string[]
    correctAnswer?: IntFieldUpdateOperationsInput | number
  }

  export type SelectionTestQuestionCreateManyInput = {
    id?: number
    preSelectionTestId: number
    question: string
    options?: SelectionTestQuestionCreateoptionsInput | string[]
    correctAnswer: number
  }

  export type SelectionTestQuestionUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: SelectionTestQuestionUpdateoptionsInput | string[]
    correctAnswer?: IntFieldUpdateOperationsInput | number
  }

  export type SelectionTestQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    preSelectionTestId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    options?: SelectionTestQuestionUpdateoptionsInput | string[]
    correctAnswer?: IntFieldUpdateOperationsInput | number
  }

  export type JobApplicationCreateInput = {
    resume: string
    expectedSalary: number
    status?: $Enums.JobApplicationStatus
    isTaken: boolean
    rejectedReview?: string | null
    selectionTestResult?: number | null
    createdAt?: Date | string
    job: JobCreateNestedOneWithoutJobApplicationInput
    user: UserCreateNestedOneWithoutJobApplicationInput
  }

  export type JobApplicationUncheckedCreateInput = {
    userId: number
    jobId: string
    resume: string
    expectedSalary: number
    status?: $Enums.JobApplicationStatus
    isTaken: boolean
    rejectedReview?: string | null
    selectionTestResult?: number | null
    createdAt?: Date | string
  }

  export type JobApplicationUpdateInput = {
    resume?: StringFieldUpdateOperationsInput | string
    expectedSalary?: IntFieldUpdateOperationsInput | number
    status?: EnumJobApplicationStatusFieldUpdateOperationsInput | $Enums.JobApplicationStatus
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    rejectedReview?: NullableStringFieldUpdateOperationsInput | string | null
    selectionTestResult?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutJobApplicationNestedInput
    user?: UserUpdateOneRequiredWithoutJobApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    jobId?: StringFieldUpdateOperationsInput | string
    resume?: StringFieldUpdateOperationsInput | string
    expectedSalary?: IntFieldUpdateOperationsInput | number
    status?: EnumJobApplicationStatusFieldUpdateOperationsInput | $Enums.JobApplicationStatus
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    rejectedReview?: NullableStringFieldUpdateOperationsInput | string | null
    selectionTestResult?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationCreateManyInput = {
    userId: number
    jobId: string
    resume: string
    expectedSalary: number
    status?: $Enums.JobApplicationStatus
    isTaken: boolean
    rejectedReview?: string | null
    selectionTestResult?: number | null
    createdAt?: Date | string
  }

  export type JobApplicationUpdateManyMutationInput = {
    resume?: StringFieldUpdateOperationsInput | string
    expectedSalary?: IntFieldUpdateOperationsInput | number
    status?: EnumJobApplicationStatusFieldUpdateOperationsInput | $Enums.JobApplicationStatus
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    rejectedReview?: NullableStringFieldUpdateOperationsInput | string | null
    selectionTestResult?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    jobId?: StringFieldUpdateOperationsInput | string
    resume?: StringFieldUpdateOperationsInput | string
    expectedSalary?: IntFieldUpdateOperationsInput | number
    status?: EnumJobApplicationStatusFieldUpdateOperationsInput | $Enums.JobApplicationStatus
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    rejectedReview?: NullableStringFieldUpdateOperationsInput | string | null
    selectionTestResult?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewCreateInput = {
    startTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInterviewInput
    job: JobCreateNestedOneWithoutInterviewInput
  }

  export type InterviewUncheckedCreateInput = {
    userId: number
    jobId: string
    startTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewUpdateInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInterviewNestedInput
    job?: JobUpdateOneRequiredWithoutInterviewNestedInput
  }

  export type InterviewUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    jobId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewCreateManyInput = {
    userId: number
    jobId: string
    startTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewUpdateManyMutationInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    jobId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    review: string
    CultureRating: number
    balanceRating: number
    facilityRating: number
    careerRating: number
    salary: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReviewInput
    job: JobCreateNestedOneWithoutReviewInput
  }

  export type ReviewUncheckedCreateInput = {
    userId: number
    jobId: string
    review: string
    CultureRating: number
    balanceRating: number
    facilityRating: number
    careerRating: number
    salary: number
    createdAt?: Date | string
  }

  export type ReviewUpdateInput = {
    review?: StringFieldUpdateOperationsInput | string
    CultureRating?: IntFieldUpdateOperationsInput | number
    balanceRating?: IntFieldUpdateOperationsInput | number
    facilityRating?: IntFieldUpdateOperationsInput | number
    careerRating?: IntFieldUpdateOperationsInput | number
    salary?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewNestedInput
    job?: JobUpdateOneRequiredWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    jobId?: StringFieldUpdateOperationsInput | string
    review?: StringFieldUpdateOperationsInput | string
    CultureRating?: IntFieldUpdateOperationsInput | number
    balanceRating?: IntFieldUpdateOperationsInput | number
    facilityRating?: IntFieldUpdateOperationsInput | number
    careerRating?: IntFieldUpdateOperationsInput | number
    salary?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    userId: number
    jobId: string
    review: string
    CultureRating: number
    balanceRating: number
    facilityRating: number
    careerRating: number
    salary: number
    createdAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    review?: StringFieldUpdateOperationsInput | string
    CultureRating?: IntFieldUpdateOperationsInput | number
    balanceRating?: IntFieldUpdateOperationsInput | number
    facilityRating?: IntFieldUpdateOperationsInput | number
    careerRating?: IntFieldUpdateOperationsInput | number
    salary?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    jobId?: StringFieldUpdateOperationsInput | string
    review?: StringFieldUpdateOperationsInput | string
    CultureRating?: IntFieldUpdateOperationsInput | number
    balanceRating?: IntFieldUpdateOperationsInput | number
    facilityRating?: IntFieldUpdateOperationsInput | number
    careerRating?: IntFieldUpdateOperationsInput | number
    salary?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    amount: number
    status: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutTransactionInput
    user: UserCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    userId: number
    subscriptionId: number
    amount: number
    status: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutTransactionNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    subscriptionId?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    userId: number
    subscriptionId: number
    amount: number
    status: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    subscriptionId?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentCreateInput = {
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    AssessmentQuestion?: AssessmentQuestionCreateNestedManyWithoutAssessmentInput
    UserAssessment?: UserAssessmentCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    AssessmentQuestion?: AssessmentQuestionUncheckedCreateNestedManyWithoutAssessmentInput
    UserAssessment?: UserAssessmentUncheckedCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AssessmentQuestion?: AssessmentQuestionUpdateManyWithoutAssessmentNestedInput
    UserAssessment?: UserAssessmentUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AssessmentQuestion?: AssessmentQuestionUncheckedUpdateManyWithoutAssessmentNestedInput
    UserAssessment?: UserAssessmentUncheckedUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentCreateManyInput = {
    id?: number
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AssessmentUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAssessmentCreateInput = {
    score?: number
    status?: $Enums.UserAssessmentStatus | null
    endTime: Date | string
    certificate?: CertificateCreateNestedOneWithoutUserAssessmentInput
    User: UserCreateNestedOneWithoutUserAssessmentInput
    assessment: AssessmentCreateNestedOneWithoutUserAssessmentInput
  }

  export type UserAssessmentUncheckedCreateInput = {
    id?: number
    userId: number
    assessmentId: number
    score?: number
    certificateId?: number | null
    status?: $Enums.UserAssessmentStatus | null
    endTime: Date | string
  }

  export type UserAssessmentUpdateInput = {
    score?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumUserAssessmentStatusFieldUpdateOperationsInput | $Enums.UserAssessmentStatus | null
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: CertificateUpdateOneWithoutUserAssessmentNestedInput
    User?: UserUpdateOneRequiredWithoutUserAssessmentNestedInput
    assessment?: AssessmentUpdateOneRequiredWithoutUserAssessmentNestedInput
  }

  export type UserAssessmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    certificateId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumUserAssessmentStatusFieldUpdateOperationsInput | $Enums.UserAssessmentStatus | null
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAssessmentCreateManyInput = {
    id?: number
    userId: number
    assessmentId: number
    score?: number
    certificateId?: number | null
    status?: $Enums.UserAssessmentStatus | null
    endTime: Date | string
  }

  export type UserAssessmentUpdateManyMutationInput = {
    score?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumUserAssessmentStatusFieldUpdateOperationsInput | $Enums.UserAssessmentStatus | null
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAssessmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    certificateId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumUserAssessmentStatusFieldUpdateOperationsInput | $Enums.UserAssessmentStatus | null
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentQuestionCreateInput = {
    question: string
    options?: AssessmentQuestionCreateoptionsInput | string[]
    correctAnswer: number
    assessment: AssessmentCreateNestedOneWithoutAssessmentQuestionInput
  }

  export type AssessmentQuestionUncheckedCreateInput = {
    id?: number
    assessmentId: number
    question: string
    options?: AssessmentQuestionCreateoptionsInput | string[]
    correctAnswer: number
  }

  export type AssessmentQuestionUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: AssessmentQuestionUpdateoptionsInput | string[]
    correctAnswer?: IntFieldUpdateOperationsInput | number
    assessment?: AssessmentUpdateOneRequiredWithoutAssessmentQuestionNestedInput
  }

  export type AssessmentQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    options?: AssessmentQuestionUpdateoptionsInput | string[]
    correctAnswer?: IntFieldUpdateOperationsInput | number
  }

  export type AssessmentQuestionCreateManyInput = {
    id?: number
    assessmentId: number
    question: string
    options?: AssessmentQuestionCreateoptionsInput | string[]
    correctAnswer: number
  }

  export type AssessmentQuestionUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: AssessmentQuestionUpdateoptionsInput | string[]
    correctAnswer?: IntFieldUpdateOperationsInput | number
  }

  export type AssessmentQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    options?: AssessmentQuestionUpdateoptionsInput | string[]
    correctAnswer?: IntFieldUpdateOperationsInput | number
  }

  export type CertificateCreateInput = {
    CertificateUrl: string
    badgeName: string
    badgeIcon: string
    createdAt?: Date | string
    UserAssessment?: UserAssessmentCreateNestedManyWithoutCertificateInput
  }

  export type CertificateUncheckedCreateInput = {
    id?: number
    CertificateUrl: string
    badgeName: string
    badgeIcon: string
    createdAt?: Date | string
    UserAssessment?: UserAssessmentUncheckedCreateNestedManyWithoutCertificateInput
  }

  export type CertificateUpdateInput = {
    CertificateUrl?: StringFieldUpdateOperationsInput | string
    badgeName?: StringFieldUpdateOperationsInput | string
    badgeIcon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserAssessment?: UserAssessmentUpdateManyWithoutCertificateNestedInput
  }

  export type CertificateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    CertificateUrl?: StringFieldUpdateOperationsInput | string
    badgeName?: StringFieldUpdateOperationsInput | string
    badgeIcon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserAssessment?: UserAssessmentUncheckedUpdateManyWithoutCertificateNestedInput
  }

  export type CertificateCreateManyInput = {
    id?: number
    CertificateUrl: string
    badgeName: string
    badgeIcon: string
    createdAt?: Date | string
  }

  export type CertificateUpdateManyMutationInput = {
    CertificateUrl?: StringFieldUpdateOperationsInput | string
    badgeName?: StringFieldUpdateOperationsInput | string
    badgeIcon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    CertificateUrl?: StringFieldUpdateOperationsInput | string
    badgeName?: StringFieldUpdateOperationsInput | string
    badgeIcon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionCreateInput = {
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    assessmentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutUserSubscriptionInput
    user: UserCreateNestedOneWithoutUserSubscriptionInput
  }

  export type UserSubscriptionUncheckedCreateInput = {
    userId: number
    subscriptionId: number
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    assessmentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSubscriptionUpdateInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assessmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutUserSubscriptionNestedInput
    user?: UserUpdateOneRequiredWithoutUserSubscriptionNestedInput
  }

  export type UserSubscriptionUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    subscriptionId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assessmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionCreateManyInput = {
    userId: number
    subscriptionId: number
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    assessmentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSubscriptionUpdateManyMutationInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assessmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    subscriptionId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assessmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumLastEduNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LastEdu | EnumLastEduFieldRefInput<$PrismaModel> | null
    in?: $Enums.LastEdu[] | ListEnumLastEduFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LastEdu[] | ListEnumLastEduFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLastEduNullableFilter<$PrismaModel> | $Enums.LastEdu | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CurriculumVitaeListRelationFilter = {
    every?: CurriculumVitaeWhereInput
    some?: CurriculumVitaeWhereInput
    none?: CurriculumVitaeWhereInput
  }

  export type JobApplicationListRelationFilter = {
    every?: JobApplicationWhereInput
    some?: JobApplicationWhereInput
    none?: JobApplicationWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type LocationNullableScalarRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type UserAssessmentListRelationFilter = {
    every?: UserAssessmentWhereInput
    some?: UserAssessmentWhereInput
    none?: UserAssessmentWhereInput
  }

  export type UserSubscriptionListRelationFilter = {
    every?: UserSubscriptionWhereInput
    some?: UserSubscriptionWhereInput
    none?: UserSubscriptionWhereInput
  }

  export type InterviewListRelationFilter = {
    every?: InterviewWhereInput
    some?: InterviewWhereInput
    none?: InterviewWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CurriculumVitaeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAssessmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isVerified?: SortOrder
    avatar?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    lastEdu?: SortOrder
    domicileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    domicileId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isVerified?: SortOrder
    avatar?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    lastEdu?: SortOrder
    domicileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isVerified?: SortOrder
    avatar?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    lastEdu?: SortOrder
    domicileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    domicileId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumLastEduNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LastEdu | EnumLastEduFieldRefInput<$PrismaModel> | null
    in?: $Enums.LastEdu[] | ListEnumLastEduFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LastEdu[] | ListEnumLastEduFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLastEduNullableWithAggregatesFilter<$PrismaModel> | $Enums.LastEdu | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLastEduNullableFilter<$PrismaModel>
    _max?: NestedEnumLastEduNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type JobListRelationFilter = {
    every?: JobWhereInput
    some?: JobWhereInput
    none?: JobWhereInput
  }

  export type JobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    description?: SortOrder
    isVerified?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    noHandphone?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    description?: SortOrder
    isVerified?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    noHandphone?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    companyName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    description?: SortOrder
    isVerified?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    noHandphone?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeveloperCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type DeveloperAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeveloperMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type DeveloperMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type DeveloperSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumJobCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.JobCategory | EnumJobCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.JobCategory[] | ListEnumJobCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobCategory[] | ListEnumJobCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumJobCategoryFilter<$PrismaModel> | $Enums.JobCategory
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AdminScalarRelationFilter = {
    is?: AdminWhereInput
    isNot?: AdminWhereInput
  }

  export type LocationScalarRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type PreSelectionTestListRelationFilter = {
    every?: PreSelectionTestWhereInput
    some?: PreSelectionTestWhereInput
    none?: PreSelectionTestWhereInput
  }

  export type PreSelectionTestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    adminId?: SortOrder
    banner?: SortOrder
    category?: SortOrder
    role?: SortOrder
    salary?: SortOrder
    description?: SortOrder
    endDate?: SortOrder
    isPublished?: SortOrder
    isTestActive?: SortOrder
    tags?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type JobAvgOrderByAggregateInput = {
    adminId?: SortOrder
    salary?: SortOrder
    locationId?: SortOrder
  }

  export type JobMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    adminId?: SortOrder
    banner?: SortOrder
    category?: SortOrder
    role?: SortOrder
    salary?: SortOrder
    description?: SortOrder
    endDate?: SortOrder
    isPublished?: SortOrder
    isTestActive?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type JobMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    adminId?: SortOrder
    banner?: SortOrder
    category?: SortOrder
    role?: SortOrder
    salary?: SortOrder
    description?: SortOrder
    endDate?: SortOrder
    isPublished?: SortOrder
    isTestActive?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
  }

  export type JobSumOrderByAggregateInput = {
    adminId?: SortOrder
    salary?: SortOrder
    locationId?: SortOrder
  }

  export type EnumJobCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobCategory | EnumJobCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.JobCategory[] | ListEnumJobCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobCategory[] | ListEnumJobCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumJobCategoryWithAggregatesFilter<$PrismaModel> | $Enums.JobCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobCategoryFilter<$PrismaModel>
    _max?: NestedEnumJobCategoryFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CurriculumVitaeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    summary?: SortOrder
    experience?: SortOrder
    skill?: SortOrder
    education?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurriculumVitaeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CurriculumVitaeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    summary?: SortOrder
    experience?: SortOrder
    skill?: SortOrder
    education?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurriculumVitaeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    summary?: SortOrder
    experience?: SortOrder
    skill?: SortOrder
    education?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurriculumVitaeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    city?: SortOrder
    province?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    city?: SortOrder
    province?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    city?: SortOrder
    province?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumSubscriptionCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionCategory | EnumSubscriptionCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionCategory[] | ListEnumSubscriptionCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionCategory[] | ListEnumSubscriptionCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionCategoryFilter<$PrismaModel> | $Enums.SubscriptionCategory
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    price?: SortOrder
    feature?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    price?: SortOrder
    feature?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    price?: SortOrder
    feature?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type EnumSubscriptionCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionCategory | EnumSubscriptionCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionCategory[] | ListEnumSubscriptionCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionCategory[] | ListEnumSubscriptionCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionCategoryWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionCategoryFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionCategoryFilter<$PrismaModel>
  }

  export type JobScalarRelationFilter = {
    is?: JobWhereInput
    isNot?: JobWhereInput
  }

  export type SelectionTestQuestionListRelationFilter = {
    every?: SelectionTestQuestionWhereInput
    some?: SelectionTestQuestionWhereInput
    none?: SelectionTestQuestionWhereInput
  }

  export type SelectionTestQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PreSelectionTestCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
  }

  export type PreSelectionTestAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PreSelectionTestMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
  }

  export type PreSelectionTestMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    jobId?: SortOrder
    createdAt?: SortOrder
  }

  export type PreSelectionTestSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PreSelectionTestScalarRelationFilter = {
    is?: PreSelectionTestWhereInput
    isNot?: PreSelectionTestWhereInput
  }

  export type SelectionTestQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    preSelectionTestId?: SortOrder
    question?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
  }

  export type SelectionTestQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    preSelectionTestId?: SortOrder
    correctAnswer?: SortOrder
  }

  export type SelectionTestQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    preSelectionTestId?: SortOrder
    question?: SortOrder
    correctAnswer?: SortOrder
  }

  export type SelectionTestQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    preSelectionTestId?: SortOrder
    question?: SortOrder
    correctAnswer?: SortOrder
  }

  export type SelectionTestQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    preSelectionTestId?: SortOrder
    correctAnswer?: SortOrder
  }

  export type EnumJobApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobApplicationStatus | EnumJobApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobApplicationStatus[] | ListEnumJobApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobApplicationStatus[] | ListEnumJobApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobApplicationStatusFilter<$PrismaModel> | $Enums.JobApplicationStatus
  }

  export type JobApplicationUserIdJobIdCompoundUniqueInput = {
    userId: number
    jobId: string
  }

  export type JobApplicationCountOrderByAggregateInput = {
    userId?: SortOrder
    jobId?: SortOrder
    resume?: SortOrder
    expectedSalary?: SortOrder
    status?: SortOrder
    isTaken?: SortOrder
    rejectedReview?: SortOrder
    selectionTestResult?: SortOrder
    createdAt?: SortOrder
  }

  export type JobApplicationAvgOrderByAggregateInput = {
    userId?: SortOrder
    expectedSalary?: SortOrder
    selectionTestResult?: SortOrder
  }

  export type JobApplicationMaxOrderByAggregateInput = {
    userId?: SortOrder
    jobId?: SortOrder
    resume?: SortOrder
    expectedSalary?: SortOrder
    status?: SortOrder
    isTaken?: SortOrder
    rejectedReview?: SortOrder
    selectionTestResult?: SortOrder
    createdAt?: SortOrder
  }

  export type JobApplicationMinOrderByAggregateInput = {
    userId?: SortOrder
    jobId?: SortOrder
    resume?: SortOrder
    expectedSalary?: SortOrder
    status?: SortOrder
    isTaken?: SortOrder
    rejectedReview?: SortOrder
    selectionTestResult?: SortOrder
    createdAt?: SortOrder
  }

  export type JobApplicationSumOrderByAggregateInput = {
    userId?: SortOrder
    expectedSalary?: SortOrder
    selectionTestResult?: SortOrder
  }

  export type EnumJobApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobApplicationStatus | EnumJobApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobApplicationStatus[] | ListEnumJobApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobApplicationStatus[] | ListEnumJobApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumJobApplicationStatusFilter<$PrismaModel>
  }

  export type InterviewUserIdJobIdCompoundUniqueInput = {
    userId: number
    jobId: string
  }

  export type InterviewCountOrderByAggregateInput = {
    userId?: SortOrder
    jobId?: SortOrder
    startTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterviewAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type InterviewMaxOrderByAggregateInput = {
    userId?: SortOrder
    jobId?: SortOrder
    startTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterviewMinOrderByAggregateInput = {
    userId?: SortOrder
    jobId?: SortOrder
    startTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterviewSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type ReviewUserIdJobIdCompoundUniqueInput = {
    userId: number
    jobId: string
  }

  export type ReviewCountOrderByAggregateInput = {
    userId?: SortOrder
    jobId?: SortOrder
    review?: SortOrder
    CultureRating?: SortOrder
    balanceRating?: SortOrder
    facilityRating?: SortOrder
    careerRating?: SortOrder
    salary?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    userId?: SortOrder
    CultureRating?: SortOrder
    balanceRating?: SortOrder
    facilityRating?: SortOrder
    careerRating?: SortOrder
    salary?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    userId?: SortOrder
    jobId?: SortOrder
    review?: SortOrder
    CultureRating?: SortOrder
    balanceRating?: SortOrder
    facilityRating?: SortOrder
    careerRating?: SortOrder
    salary?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    userId?: SortOrder
    jobId?: SortOrder
    review?: SortOrder
    CultureRating?: SortOrder
    balanceRating?: SortOrder
    facilityRating?: SortOrder
    careerRating?: SortOrder
    salary?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    userId?: SortOrder
    CultureRating?: SortOrder
    balanceRating?: SortOrder
    facilityRating?: SortOrder
    careerRating?: SortOrder
    salary?: SortOrder
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type SubscriptionScalarRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    userId?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    userId?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type AssessmentQuestionListRelationFilter = {
    every?: AssessmentQuestionWhereInput
    some?: AssessmentQuestionWhereInput
    none?: AssessmentQuestionWhereInput
  }

  export type AssessmentQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssessmentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AssessmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AssessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AssessmentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AssessmentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumUserAssessmentStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserAssessmentStatus | EnumUserAssessmentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserAssessmentStatus[] | ListEnumUserAssessmentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserAssessmentStatus[] | ListEnumUserAssessmentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserAssessmentStatusNullableFilter<$PrismaModel> | $Enums.UserAssessmentStatus | null
  }

  export type CertificateNullableScalarRelationFilter = {
    is?: CertificateWhereInput | null
    isNot?: CertificateWhereInput | null
  }

  export type AssessmentScalarRelationFilter = {
    is?: AssessmentWhereInput
    isNot?: AssessmentWhereInput
  }

  export type UserAssessmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentId?: SortOrder
    score?: SortOrder
    certificateId?: SortOrder
    status?: SortOrder
    endTime?: SortOrder
  }

  export type UserAssessmentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentId?: SortOrder
    score?: SortOrder
    certificateId?: SortOrder
  }

  export type UserAssessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentId?: SortOrder
    score?: SortOrder
    certificateId?: SortOrder
    status?: SortOrder
    endTime?: SortOrder
  }

  export type UserAssessmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentId?: SortOrder
    score?: SortOrder
    certificateId?: SortOrder
    status?: SortOrder
    endTime?: SortOrder
  }

  export type UserAssessmentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentId?: SortOrder
    score?: SortOrder
    certificateId?: SortOrder
  }

  export type EnumUserAssessmentStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserAssessmentStatus | EnumUserAssessmentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserAssessmentStatus[] | ListEnumUserAssessmentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserAssessmentStatus[] | ListEnumUserAssessmentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserAssessmentStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserAssessmentStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserAssessmentStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumUserAssessmentStatusNullableFilter<$PrismaModel>
  }

  export type AssessmentQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    question?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
  }

  export type AssessmentQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    correctAnswer?: SortOrder
  }

  export type AssessmentQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    question?: SortOrder
    correctAnswer?: SortOrder
  }

  export type AssessmentQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    question?: SortOrder
    correctAnswer?: SortOrder
  }

  export type AssessmentQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    correctAnswer?: SortOrder
  }

  export type CertificateCountOrderByAggregateInput = {
    id?: SortOrder
    CertificateUrl?: SortOrder
    badgeName?: SortOrder
    badgeIcon?: SortOrder
    createdAt?: SortOrder
  }

  export type CertificateAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CertificateMaxOrderByAggregateInput = {
    id?: SortOrder
    CertificateUrl?: SortOrder
    badgeName?: SortOrder
    badgeIcon?: SortOrder
    createdAt?: SortOrder
  }

  export type CertificateMinOrderByAggregateInput = {
    id?: SortOrder
    CertificateUrl?: SortOrder
    badgeName?: SortOrder
    badgeIcon?: SortOrder
    createdAt?: SortOrder
  }

  export type CertificateSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserSubscriptionUserIdSubscriptionIdCompoundUniqueInput = {
    userId: number
    subscriptionId: number
  }

  export type UserSubscriptionCountOrderByAggregateInput = {
    userId?: SortOrder
    subscriptionId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    assessmentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSubscriptionAvgOrderByAggregateInput = {
    userId?: SortOrder
    subscriptionId?: SortOrder
    assessmentCount?: SortOrder
  }

  export type UserSubscriptionMaxOrderByAggregateInput = {
    userId?: SortOrder
    subscriptionId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    assessmentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSubscriptionMinOrderByAggregateInput = {
    userId?: SortOrder
    subscriptionId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    assessmentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSubscriptionSumOrderByAggregateInput = {
    userId?: SortOrder
    subscriptionId?: SortOrder
    assessmentCount?: SortOrder
  }

  export type CurriculumVitaeCreateNestedManyWithoutUserInput = {
    create?: XOR<CurriculumVitaeCreateWithoutUserInput, CurriculumVitaeUncheckedCreateWithoutUserInput> | CurriculumVitaeCreateWithoutUserInput[] | CurriculumVitaeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CurriculumVitaeCreateOrConnectWithoutUserInput | CurriculumVitaeCreateOrConnectWithoutUserInput[]
    createMany?: CurriculumVitaeCreateManyUserInputEnvelope
    connect?: CurriculumVitaeWhereUniqueInput | CurriculumVitaeWhereUniqueInput[]
  }

  export type JobApplicationCreateNestedManyWithoutUserInput = {
    create?: XOR<JobApplicationCreateWithoutUserInput, JobApplicationUncheckedCreateWithoutUserInput> | JobApplicationCreateWithoutUserInput[] | JobApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutUserInput | JobApplicationCreateOrConnectWithoutUserInput[]
    createMany?: JobApplicationCreateManyUserInputEnvelope
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type LocationCreateNestedOneWithoutUserInput = {
    create?: XOR<LocationCreateWithoutUserInput, LocationUncheckedCreateWithoutUserInput>
    connectOrCreate?: LocationCreateOrConnectWithoutUserInput
    connect?: LocationWhereUniqueInput
  }

  export type UserAssessmentCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAssessmentCreateWithoutUserInput, UserAssessmentUncheckedCreateWithoutUserInput> | UserAssessmentCreateWithoutUserInput[] | UserAssessmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAssessmentCreateOrConnectWithoutUserInput | UserAssessmentCreateOrConnectWithoutUserInput[]
    createMany?: UserAssessmentCreateManyUserInputEnvelope
    connect?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
  }

  export type UserSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput> | UserSubscriptionCreateWithoutUserInput[] | UserSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput | UserSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: UserSubscriptionCreateManyUserInputEnvelope
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
  }

  export type InterviewCreateNestedManyWithoutUserInput = {
    create?: XOR<InterviewCreateWithoutUserInput, InterviewUncheckedCreateWithoutUserInput> | InterviewCreateWithoutUserInput[] | InterviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutUserInput | InterviewCreateOrConnectWithoutUserInput[]
    createMany?: InterviewCreateManyUserInputEnvelope
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
  }

  export type CurriculumVitaeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CurriculumVitaeCreateWithoutUserInput, CurriculumVitaeUncheckedCreateWithoutUserInput> | CurriculumVitaeCreateWithoutUserInput[] | CurriculumVitaeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CurriculumVitaeCreateOrConnectWithoutUserInput | CurriculumVitaeCreateOrConnectWithoutUserInput[]
    createMany?: CurriculumVitaeCreateManyUserInputEnvelope
    connect?: CurriculumVitaeWhereUniqueInput | CurriculumVitaeWhereUniqueInput[]
  }

  export type JobApplicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<JobApplicationCreateWithoutUserInput, JobApplicationUncheckedCreateWithoutUserInput> | JobApplicationCreateWithoutUserInput[] | JobApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutUserInput | JobApplicationCreateOrConnectWithoutUserInput[]
    createMany?: JobApplicationCreateManyUserInputEnvelope
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserAssessmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAssessmentCreateWithoutUserInput, UserAssessmentUncheckedCreateWithoutUserInput> | UserAssessmentCreateWithoutUserInput[] | UserAssessmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAssessmentCreateOrConnectWithoutUserInput | UserAssessmentCreateOrConnectWithoutUserInput[]
    createMany?: UserAssessmentCreateManyUserInputEnvelope
    connect?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
  }

  export type UserSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput> | UserSubscriptionCreateWithoutUserInput[] | UserSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput | UserSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: UserSubscriptionCreateManyUserInputEnvelope
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
  }

  export type InterviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InterviewCreateWithoutUserInput, InterviewUncheckedCreateWithoutUserInput> | InterviewCreateWithoutUserInput[] | InterviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutUserInput | InterviewCreateOrConnectWithoutUserInput[]
    createMany?: InterviewCreateManyUserInputEnvelope
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumLastEduFieldUpdateOperationsInput = {
    set?: $Enums.LastEdu | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CurriculumVitaeUpdateManyWithoutUserNestedInput = {
    create?: XOR<CurriculumVitaeCreateWithoutUserInput, CurriculumVitaeUncheckedCreateWithoutUserInput> | CurriculumVitaeCreateWithoutUserInput[] | CurriculumVitaeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CurriculumVitaeCreateOrConnectWithoutUserInput | CurriculumVitaeCreateOrConnectWithoutUserInput[]
    upsert?: CurriculumVitaeUpsertWithWhereUniqueWithoutUserInput | CurriculumVitaeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CurriculumVitaeCreateManyUserInputEnvelope
    set?: CurriculumVitaeWhereUniqueInput | CurriculumVitaeWhereUniqueInput[]
    disconnect?: CurriculumVitaeWhereUniqueInput | CurriculumVitaeWhereUniqueInput[]
    delete?: CurriculumVitaeWhereUniqueInput | CurriculumVitaeWhereUniqueInput[]
    connect?: CurriculumVitaeWhereUniqueInput | CurriculumVitaeWhereUniqueInput[]
    update?: CurriculumVitaeUpdateWithWhereUniqueWithoutUserInput | CurriculumVitaeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CurriculumVitaeUpdateManyWithWhereWithoutUserInput | CurriculumVitaeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CurriculumVitaeScalarWhereInput | CurriculumVitaeScalarWhereInput[]
  }

  export type JobApplicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<JobApplicationCreateWithoutUserInput, JobApplicationUncheckedCreateWithoutUserInput> | JobApplicationCreateWithoutUserInput[] | JobApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutUserInput | JobApplicationCreateOrConnectWithoutUserInput[]
    upsert?: JobApplicationUpsertWithWhereUniqueWithoutUserInput | JobApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JobApplicationCreateManyUserInputEnvelope
    set?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    disconnect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    delete?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    update?: JobApplicationUpdateWithWhereUniqueWithoutUserInput | JobApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JobApplicationUpdateManyWithWhereWithoutUserInput | JobApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type LocationUpdateOneWithoutUserNestedInput = {
    create?: XOR<LocationCreateWithoutUserInput, LocationUncheckedCreateWithoutUserInput>
    connectOrCreate?: LocationCreateOrConnectWithoutUserInput
    upsert?: LocationUpsertWithoutUserInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutUserInput, LocationUpdateWithoutUserInput>, LocationUncheckedUpdateWithoutUserInput>
  }

  export type UserAssessmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAssessmentCreateWithoutUserInput, UserAssessmentUncheckedCreateWithoutUserInput> | UserAssessmentCreateWithoutUserInput[] | UserAssessmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAssessmentCreateOrConnectWithoutUserInput | UserAssessmentCreateOrConnectWithoutUserInput[]
    upsert?: UserAssessmentUpsertWithWhereUniqueWithoutUserInput | UserAssessmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAssessmentCreateManyUserInputEnvelope
    set?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    disconnect?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    delete?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    connect?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    update?: UserAssessmentUpdateWithWhereUniqueWithoutUserInput | UserAssessmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAssessmentUpdateManyWithWhereWithoutUserInput | UserAssessmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAssessmentScalarWhereInput | UserAssessmentScalarWhereInput[]
  }

  export type UserSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput> | UserSubscriptionCreateWithoutUserInput[] | UserSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput | UserSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: UserSubscriptionUpsertWithWhereUniqueWithoutUserInput | UserSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSubscriptionCreateManyUserInputEnvelope
    set?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    disconnect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    delete?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    update?: UserSubscriptionUpdateWithWhereUniqueWithoutUserInput | UserSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSubscriptionUpdateManyWithWhereWithoutUserInput | UserSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
  }

  export type InterviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<InterviewCreateWithoutUserInput, InterviewUncheckedCreateWithoutUserInput> | InterviewCreateWithoutUserInput[] | InterviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutUserInput | InterviewCreateOrConnectWithoutUserInput[]
    upsert?: InterviewUpsertWithWhereUniqueWithoutUserInput | InterviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InterviewCreateManyUserInputEnvelope
    set?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    disconnect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    delete?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    update?: InterviewUpdateWithWhereUniqueWithoutUserInput | InterviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InterviewUpdateManyWithWhereWithoutUserInput | InterviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InterviewScalarWhereInput | InterviewScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CurriculumVitaeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CurriculumVitaeCreateWithoutUserInput, CurriculumVitaeUncheckedCreateWithoutUserInput> | CurriculumVitaeCreateWithoutUserInput[] | CurriculumVitaeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CurriculumVitaeCreateOrConnectWithoutUserInput | CurriculumVitaeCreateOrConnectWithoutUserInput[]
    upsert?: CurriculumVitaeUpsertWithWhereUniqueWithoutUserInput | CurriculumVitaeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CurriculumVitaeCreateManyUserInputEnvelope
    set?: CurriculumVitaeWhereUniqueInput | CurriculumVitaeWhereUniqueInput[]
    disconnect?: CurriculumVitaeWhereUniqueInput | CurriculumVitaeWhereUniqueInput[]
    delete?: CurriculumVitaeWhereUniqueInput | CurriculumVitaeWhereUniqueInput[]
    connect?: CurriculumVitaeWhereUniqueInput | CurriculumVitaeWhereUniqueInput[]
    update?: CurriculumVitaeUpdateWithWhereUniqueWithoutUserInput | CurriculumVitaeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CurriculumVitaeUpdateManyWithWhereWithoutUserInput | CurriculumVitaeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CurriculumVitaeScalarWhereInput | CurriculumVitaeScalarWhereInput[]
  }

  export type JobApplicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<JobApplicationCreateWithoutUserInput, JobApplicationUncheckedCreateWithoutUserInput> | JobApplicationCreateWithoutUserInput[] | JobApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutUserInput | JobApplicationCreateOrConnectWithoutUserInput[]
    upsert?: JobApplicationUpsertWithWhereUniqueWithoutUserInput | JobApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JobApplicationCreateManyUserInputEnvelope
    set?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    disconnect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    delete?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    update?: JobApplicationUpdateWithWhereUniqueWithoutUserInput | JobApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JobApplicationUpdateManyWithWhereWithoutUserInput | JobApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserAssessmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAssessmentCreateWithoutUserInput, UserAssessmentUncheckedCreateWithoutUserInput> | UserAssessmentCreateWithoutUserInput[] | UserAssessmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAssessmentCreateOrConnectWithoutUserInput | UserAssessmentCreateOrConnectWithoutUserInput[]
    upsert?: UserAssessmentUpsertWithWhereUniqueWithoutUserInput | UserAssessmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAssessmentCreateManyUserInputEnvelope
    set?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    disconnect?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    delete?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    connect?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    update?: UserAssessmentUpdateWithWhereUniqueWithoutUserInput | UserAssessmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAssessmentUpdateManyWithWhereWithoutUserInput | UserAssessmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAssessmentScalarWhereInput | UserAssessmentScalarWhereInput[]
  }

  export type UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput> | UserSubscriptionCreateWithoutUserInput[] | UserSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutUserInput | UserSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: UserSubscriptionUpsertWithWhereUniqueWithoutUserInput | UserSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSubscriptionCreateManyUserInputEnvelope
    set?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    disconnect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    delete?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    update?: UserSubscriptionUpdateWithWhereUniqueWithoutUserInput | UserSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSubscriptionUpdateManyWithWhereWithoutUserInput | UserSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
  }

  export type InterviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InterviewCreateWithoutUserInput, InterviewUncheckedCreateWithoutUserInput> | InterviewCreateWithoutUserInput[] | InterviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutUserInput | InterviewCreateOrConnectWithoutUserInput[]
    upsert?: InterviewUpsertWithWhereUniqueWithoutUserInput | InterviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InterviewCreateManyUserInputEnvelope
    set?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    disconnect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    delete?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    update?: InterviewUpdateWithWhereUniqueWithoutUserInput | InterviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InterviewUpdateManyWithWhereWithoutUserInput | InterviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InterviewScalarWhereInput | InterviewScalarWhereInput[]
  }

  export type JobCreateNestedManyWithoutAdminInput = {
    create?: XOR<JobCreateWithoutAdminInput, JobUncheckedCreateWithoutAdminInput> | JobCreateWithoutAdminInput[] | JobUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: JobCreateOrConnectWithoutAdminInput | JobCreateOrConnectWithoutAdminInput[]
    createMany?: JobCreateManyAdminInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<JobCreateWithoutAdminInput, JobUncheckedCreateWithoutAdminInput> | JobCreateWithoutAdminInput[] | JobUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: JobCreateOrConnectWithoutAdminInput | JobCreateOrConnectWithoutAdminInput[]
    createMany?: JobCreateManyAdminInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type JobUpdateManyWithoutAdminNestedInput = {
    create?: XOR<JobCreateWithoutAdminInput, JobUncheckedCreateWithoutAdminInput> | JobCreateWithoutAdminInput[] | JobUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: JobCreateOrConnectWithoutAdminInput | JobCreateOrConnectWithoutAdminInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutAdminInput | JobUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: JobCreateManyAdminInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutAdminInput | JobUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: JobUpdateManyWithWhereWithoutAdminInput | JobUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<JobCreateWithoutAdminInput, JobUncheckedCreateWithoutAdminInput> | JobCreateWithoutAdminInput[] | JobUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: JobCreateOrConnectWithoutAdminInput | JobCreateOrConnectWithoutAdminInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutAdminInput | JobUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: JobCreateManyAdminInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutAdminInput | JobUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: JobUpdateManyWithWhereWithoutAdminInput | JobUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type JobCreatetagsInput = {
    set: string[]
  }

  export type AdminCreateNestedOneWithoutJobInput = {
    create?: XOR<AdminCreateWithoutJobInput, AdminUncheckedCreateWithoutJobInput>
    connectOrCreate?: AdminCreateOrConnectWithoutJobInput
    connect?: AdminWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutJobInput = {
    create?: XOR<LocationCreateWithoutJobInput, LocationUncheckedCreateWithoutJobInput>
    connectOrCreate?: LocationCreateOrConnectWithoutJobInput
    connect?: LocationWhereUniqueInput
  }

  export type JobApplicationCreateNestedManyWithoutJobInput = {
    create?: XOR<JobApplicationCreateWithoutJobInput, JobApplicationUncheckedCreateWithoutJobInput> | JobApplicationCreateWithoutJobInput[] | JobApplicationUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobInput | JobApplicationCreateOrConnectWithoutJobInput[]
    createMany?: JobApplicationCreateManyJobInputEnvelope
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
  }

  export type PreSelectionTestCreateNestedManyWithoutJobInput = {
    create?: XOR<PreSelectionTestCreateWithoutJobInput, PreSelectionTestUncheckedCreateWithoutJobInput> | PreSelectionTestCreateWithoutJobInput[] | PreSelectionTestUncheckedCreateWithoutJobInput[]
    connectOrCreate?: PreSelectionTestCreateOrConnectWithoutJobInput | PreSelectionTestCreateOrConnectWithoutJobInput[]
    createMany?: PreSelectionTestCreateManyJobInputEnvelope
    connect?: PreSelectionTestWhereUniqueInput | PreSelectionTestWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutJobInput = {
    create?: XOR<ReviewCreateWithoutJobInput, ReviewUncheckedCreateWithoutJobInput> | ReviewCreateWithoutJobInput[] | ReviewUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutJobInput | ReviewCreateOrConnectWithoutJobInput[]
    createMany?: ReviewCreateManyJobInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type InterviewCreateNestedManyWithoutJobInput = {
    create?: XOR<InterviewCreateWithoutJobInput, InterviewUncheckedCreateWithoutJobInput> | InterviewCreateWithoutJobInput[] | InterviewUncheckedCreateWithoutJobInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutJobInput | InterviewCreateOrConnectWithoutJobInput[]
    createMany?: InterviewCreateManyJobInputEnvelope
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
  }

  export type JobApplicationUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<JobApplicationCreateWithoutJobInput, JobApplicationUncheckedCreateWithoutJobInput> | JobApplicationCreateWithoutJobInput[] | JobApplicationUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobInput | JobApplicationCreateOrConnectWithoutJobInput[]
    createMany?: JobApplicationCreateManyJobInputEnvelope
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
  }

  export type PreSelectionTestUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<PreSelectionTestCreateWithoutJobInput, PreSelectionTestUncheckedCreateWithoutJobInput> | PreSelectionTestCreateWithoutJobInput[] | PreSelectionTestUncheckedCreateWithoutJobInput[]
    connectOrCreate?: PreSelectionTestCreateOrConnectWithoutJobInput | PreSelectionTestCreateOrConnectWithoutJobInput[]
    createMany?: PreSelectionTestCreateManyJobInputEnvelope
    connect?: PreSelectionTestWhereUniqueInput | PreSelectionTestWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<ReviewCreateWithoutJobInput, ReviewUncheckedCreateWithoutJobInput> | ReviewCreateWithoutJobInput[] | ReviewUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutJobInput | ReviewCreateOrConnectWithoutJobInput[]
    createMany?: ReviewCreateManyJobInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type InterviewUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<InterviewCreateWithoutJobInput, InterviewUncheckedCreateWithoutJobInput> | InterviewCreateWithoutJobInput[] | InterviewUncheckedCreateWithoutJobInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutJobInput | InterviewCreateOrConnectWithoutJobInput[]
    createMany?: InterviewCreateManyJobInputEnvelope
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
  }

  export type EnumJobCategoryFieldUpdateOperationsInput = {
    set?: $Enums.JobCategory
  }

  export type JobUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdminUpdateOneRequiredWithoutJobNestedInput = {
    create?: XOR<AdminCreateWithoutJobInput, AdminUncheckedCreateWithoutJobInput>
    connectOrCreate?: AdminCreateOrConnectWithoutJobInput
    upsert?: AdminUpsertWithoutJobInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutJobInput, AdminUpdateWithoutJobInput>, AdminUncheckedUpdateWithoutJobInput>
  }

  export type LocationUpdateOneRequiredWithoutJobNestedInput = {
    create?: XOR<LocationCreateWithoutJobInput, LocationUncheckedCreateWithoutJobInput>
    connectOrCreate?: LocationCreateOrConnectWithoutJobInput
    upsert?: LocationUpsertWithoutJobInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutJobInput, LocationUpdateWithoutJobInput>, LocationUncheckedUpdateWithoutJobInput>
  }

  export type JobApplicationUpdateManyWithoutJobNestedInput = {
    create?: XOR<JobApplicationCreateWithoutJobInput, JobApplicationUncheckedCreateWithoutJobInput> | JobApplicationCreateWithoutJobInput[] | JobApplicationUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobInput | JobApplicationCreateOrConnectWithoutJobInput[]
    upsert?: JobApplicationUpsertWithWhereUniqueWithoutJobInput | JobApplicationUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: JobApplicationCreateManyJobInputEnvelope
    set?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    disconnect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    delete?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    update?: JobApplicationUpdateWithWhereUniqueWithoutJobInput | JobApplicationUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: JobApplicationUpdateManyWithWhereWithoutJobInput | JobApplicationUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
  }

  export type PreSelectionTestUpdateManyWithoutJobNestedInput = {
    create?: XOR<PreSelectionTestCreateWithoutJobInput, PreSelectionTestUncheckedCreateWithoutJobInput> | PreSelectionTestCreateWithoutJobInput[] | PreSelectionTestUncheckedCreateWithoutJobInput[]
    connectOrCreate?: PreSelectionTestCreateOrConnectWithoutJobInput | PreSelectionTestCreateOrConnectWithoutJobInput[]
    upsert?: PreSelectionTestUpsertWithWhereUniqueWithoutJobInput | PreSelectionTestUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: PreSelectionTestCreateManyJobInputEnvelope
    set?: PreSelectionTestWhereUniqueInput | PreSelectionTestWhereUniqueInput[]
    disconnect?: PreSelectionTestWhereUniqueInput | PreSelectionTestWhereUniqueInput[]
    delete?: PreSelectionTestWhereUniqueInput | PreSelectionTestWhereUniqueInput[]
    connect?: PreSelectionTestWhereUniqueInput | PreSelectionTestWhereUniqueInput[]
    update?: PreSelectionTestUpdateWithWhereUniqueWithoutJobInput | PreSelectionTestUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: PreSelectionTestUpdateManyWithWhereWithoutJobInput | PreSelectionTestUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: PreSelectionTestScalarWhereInput | PreSelectionTestScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutJobNestedInput = {
    create?: XOR<ReviewCreateWithoutJobInput, ReviewUncheckedCreateWithoutJobInput> | ReviewCreateWithoutJobInput[] | ReviewUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutJobInput | ReviewCreateOrConnectWithoutJobInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutJobInput | ReviewUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: ReviewCreateManyJobInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutJobInput | ReviewUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutJobInput | ReviewUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type InterviewUpdateManyWithoutJobNestedInput = {
    create?: XOR<InterviewCreateWithoutJobInput, InterviewUncheckedCreateWithoutJobInput> | InterviewCreateWithoutJobInput[] | InterviewUncheckedCreateWithoutJobInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutJobInput | InterviewCreateOrConnectWithoutJobInput[]
    upsert?: InterviewUpsertWithWhereUniqueWithoutJobInput | InterviewUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: InterviewCreateManyJobInputEnvelope
    set?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    disconnect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    delete?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    update?: InterviewUpdateWithWhereUniqueWithoutJobInput | InterviewUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: InterviewUpdateManyWithWhereWithoutJobInput | InterviewUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: InterviewScalarWhereInput | InterviewScalarWhereInput[]
  }

  export type JobApplicationUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<JobApplicationCreateWithoutJobInput, JobApplicationUncheckedCreateWithoutJobInput> | JobApplicationCreateWithoutJobInput[] | JobApplicationUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobInput | JobApplicationCreateOrConnectWithoutJobInput[]
    upsert?: JobApplicationUpsertWithWhereUniqueWithoutJobInput | JobApplicationUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: JobApplicationCreateManyJobInputEnvelope
    set?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    disconnect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    delete?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    update?: JobApplicationUpdateWithWhereUniqueWithoutJobInput | JobApplicationUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: JobApplicationUpdateManyWithWhereWithoutJobInput | JobApplicationUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
  }

  export type PreSelectionTestUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<PreSelectionTestCreateWithoutJobInput, PreSelectionTestUncheckedCreateWithoutJobInput> | PreSelectionTestCreateWithoutJobInput[] | PreSelectionTestUncheckedCreateWithoutJobInput[]
    connectOrCreate?: PreSelectionTestCreateOrConnectWithoutJobInput | PreSelectionTestCreateOrConnectWithoutJobInput[]
    upsert?: PreSelectionTestUpsertWithWhereUniqueWithoutJobInput | PreSelectionTestUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: PreSelectionTestCreateManyJobInputEnvelope
    set?: PreSelectionTestWhereUniqueInput | PreSelectionTestWhereUniqueInput[]
    disconnect?: PreSelectionTestWhereUniqueInput | PreSelectionTestWhereUniqueInput[]
    delete?: PreSelectionTestWhereUniqueInput | PreSelectionTestWhereUniqueInput[]
    connect?: PreSelectionTestWhereUniqueInput | PreSelectionTestWhereUniqueInput[]
    update?: PreSelectionTestUpdateWithWhereUniqueWithoutJobInput | PreSelectionTestUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: PreSelectionTestUpdateManyWithWhereWithoutJobInput | PreSelectionTestUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: PreSelectionTestScalarWhereInput | PreSelectionTestScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<ReviewCreateWithoutJobInput, ReviewUncheckedCreateWithoutJobInput> | ReviewCreateWithoutJobInput[] | ReviewUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutJobInput | ReviewCreateOrConnectWithoutJobInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutJobInput | ReviewUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: ReviewCreateManyJobInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutJobInput | ReviewUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutJobInput | ReviewUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type InterviewUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<InterviewCreateWithoutJobInput, InterviewUncheckedCreateWithoutJobInput> | InterviewCreateWithoutJobInput[] | InterviewUncheckedCreateWithoutJobInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutJobInput | InterviewCreateOrConnectWithoutJobInput[]
    upsert?: InterviewUpsertWithWhereUniqueWithoutJobInput | InterviewUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: InterviewCreateManyJobInputEnvelope
    set?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    disconnect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    delete?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    update?: InterviewUpdateWithWhereUniqueWithoutJobInput | InterviewUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: InterviewUpdateManyWithWhereWithoutJobInput | InterviewUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: InterviewScalarWhereInput | InterviewScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCurriculumVitaeInput = {
    create?: XOR<UserCreateWithoutCurriculumVitaeInput, UserUncheckedCreateWithoutCurriculumVitaeInput>
    connectOrCreate?: UserCreateOrConnectWithoutCurriculumVitaeInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCurriculumVitaeNestedInput = {
    create?: XOR<UserCreateWithoutCurriculumVitaeInput, UserUncheckedCreateWithoutCurriculumVitaeInput>
    connectOrCreate?: UserCreateOrConnectWithoutCurriculumVitaeInput
    upsert?: UserUpsertWithoutCurriculumVitaeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCurriculumVitaeInput, UserUpdateWithoutCurriculumVitaeInput>, UserUncheckedUpdateWithoutCurriculumVitaeInput>
  }

  export type JobCreateNestedManyWithoutLocationInput = {
    create?: XOR<JobCreateWithoutLocationInput, JobUncheckedCreateWithoutLocationInput> | JobCreateWithoutLocationInput[] | JobUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: JobCreateOrConnectWithoutLocationInput | JobCreateOrConnectWithoutLocationInput[]
    createMany?: JobCreateManyLocationInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutLocationInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<JobCreateWithoutLocationInput, JobUncheckedCreateWithoutLocationInput> | JobCreateWithoutLocationInput[] | JobUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: JobCreateOrConnectWithoutLocationInput | JobCreateOrConnectWithoutLocationInput[]
    createMany?: JobCreateManyLocationInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type JobUpdateManyWithoutLocationNestedInput = {
    create?: XOR<JobCreateWithoutLocationInput, JobUncheckedCreateWithoutLocationInput> | JobCreateWithoutLocationInput[] | JobUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: JobCreateOrConnectWithoutLocationInput | JobCreateOrConnectWithoutLocationInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutLocationInput | JobUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: JobCreateManyLocationInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutLocationInput | JobUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: JobUpdateManyWithWhereWithoutLocationInput | JobUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type UserUpdateManyWithoutLocationNestedInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutLocationInput | UserUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutLocationInput | UserUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutLocationInput | UserUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<JobCreateWithoutLocationInput, JobUncheckedCreateWithoutLocationInput> | JobCreateWithoutLocationInput[] | JobUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: JobCreateOrConnectWithoutLocationInput | JobCreateOrConnectWithoutLocationInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutLocationInput | JobUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: JobCreateManyLocationInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutLocationInput | JobUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: JobUpdateManyWithWhereWithoutLocationInput | JobUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput> | UserCreateWithoutLocationInput[] | UserUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLocationInput | UserCreateOrConnectWithoutLocationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutLocationInput | UserUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: UserCreateManyLocationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutLocationInput | UserUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutLocationInput | UserUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TransactionCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<TransactionCreateWithoutSubscriptionInput, TransactionUncheckedCreateWithoutSubscriptionInput> | TransactionCreateWithoutSubscriptionInput[] | TransactionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSubscriptionInput | TransactionCreateOrConnectWithoutSubscriptionInput[]
    createMany?: TransactionCreateManySubscriptionInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserSubscriptionCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<UserSubscriptionCreateWithoutSubscriptionInput, UserSubscriptionUncheckedCreateWithoutSubscriptionInput> | UserSubscriptionCreateWithoutSubscriptionInput[] | UserSubscriptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutSubscriptionInput | UserSubscriptionCreateOrConnectWithoutSubscriptionInput[]
    createMany?: UserSubscriptionCreateManySubscriptionInputEnvelope
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<TransactionCreateWithoutSubscriptionInput, TransactionUncheckedCreateWithoutSubscriptionInput> | TransactionCreateWithoutSubscriptionInput[] | TransactionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSubscriptionInput | TransactionCreateOrConnectWithoutSubscriptionInput[]
    createMany?: TransactionCreateManySubscriptionInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserSubscriptionUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<UserSubscriptionCreateWithoutSubscriptionInput, UserSubscriptionUncheckedCreateWithoutSubscriptionInput> | UserSubscriptionCreateWithoutSubscriptionInput[] | UserSubscriptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutSubscriptionInput | UserSubscriptionCreateOrConnectWithoutSubscriptionInput[]
    createMany?: UserSubscriptionCreateManySubscriptionInputEnvelope
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
  }

  export type EnumSubscriptionCategoryFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionCategory
  }

  export type TransactionUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<TransactionCreateWithoutSubscriptionInput, TransactionUncheckedCreateWithoutSubscriptionInput> | TransactionCreateWithoutSubscriptionInput[] | TransactionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSubscriptionInput | TransactionCreateOrConnectWithoutSubscriptionInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutSubscriptionInput | TransactionUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: TransactionCreateManySubscriptionInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutSubscriptionInput | TransactionUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutSubscriptionInput | TransactionUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserSubscriptionUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutSubscriptionInput, UserSubscriptionUncheckedCreateWithoutSubscriptionInput> | UserSubscriptionCreateWithoutSubscriptionInput[] | UserSubscriptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutSubscriptionInput | UserSubscriptionCreateOrConnectWithoutSubscriptionInput[]
    upsert?: UserSubscriptionUpsertWithWhereUniqueWithoutSubscriptionInput | UserSubscriptionUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: UserSubscriptionCreateManySubscriptionInputEnvelope
    set?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    disconnect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    delete?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    update?: UserSubscriptionUpdateWithWhereUniqueWithoutSubscriptionInput | UserSubscriptionUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: UserSubscriptionUpdateManyWithWhereWithoutSubscriptionInput | UserSubscriptionUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<TransactionCreateWithoutSubscriptionInput, TransactionUncheckedCreateWithoutSubscriptionInput> | TransactionCreateWithoutSubscriptionInput[] | TransactionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSubscriptionInput | TransactionCreateOrConnectWithoutSubscriptionInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutSubscriptionInput | TransactionUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: TransactionCreateManySubscriptionInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutSubscriptionInput | TransactionUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutSubscriptionInput | TransactionUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserSubscriptionUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<UserSubscriptionCreateWithoutSubscriptionInput, UserSubscriptionUncheckedCreateWithoutSubscriptionInput> | UserSubscriptionCreateWithoutSubscriptionInput[] | UserSubscriptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: UserSubscriptionCreateOrConnectWithoutSubscriptionInput | UserSubscriptionCreateOrConnectWithoutSubscriptionInput[]
    upsert?: UserSubscriptionUpsertWithWhereUniqueWithoutSubscriptionInput | UserSubscriptionUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: UserSubscriptionCreateManySubscriptionInputEnvelope
    set?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    disconnect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    delete?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    connect?: UserSubscriptionWhereUniqueInput | UserSubscriptionWhereUniqueInput[]
    update?: UserSubscriptionUpdateWithWhereUniqueWithoutSubscriptionInput | UserSubscriptionUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: UserSubscriptionUpdateManyWithWhereWithoutSubscriptionInput | UserSubscriptionUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
  }

  export type JobCreateNestedOneWithoutPreSelectionTestInput = {
    create?: XOR<JobCreateWithoutPreSelectionTestInput, JobUncheckedCreateWithoutPreSelectionTestInput>
    connectOrCreate?: JobCreateOrConnectWithoutPreSelectionTestInput
    connect?: JobWhereUniqueInput
  }

  export type SelectionTestQuestionCreateNestedManyWithoutPreSelectionTestInput = {
    create?: XOR<SelectionTestQuestionCreateWithoutPreSelectionTestInput, SelectionTestQuestionUncheckedCreateWithoutPreSelectionTestInput> | SelectionTestQuestionCreateWithoutPreSelectionTestInput[] | SelectionTestQuestionUncheckedCreateWithoutPreSelectionTestInput[]
    connectOrCreate?: SelectionTestQuestionCreateOrConnectWithoutPreSelectionTestInput | SelectionTestQuestionCreateOrConnectWithoutPreSelectionTestInput[]
    createMany?: SelectionTestQuestionCreateManyPreSelectionTestInputEnvelope
    connect?: SelectionTestQuestionWhereUniqueInput | SelectionTestQuestionWhereUniqueInput[]
  }

  export type SelectionTestQuestionUncheckedCreateNestedManyWithoutPreSelectionTestInput = {
    create?: XOR<SelectionTestQuestionCreateWithoutPreSelectionTestInput, SelectionTestQuestionUncheckedCreateWithoutPreSelectionTestInput> | SelectionTestQuestionCreateWithoutPreSelectionTestInput[] | SelectionTestQuestionUncheckedCreateWithoutPreSelectionTestInput[]
    connectOrCreate?: SelectionTestQuestionCreateOrConnectWithoutPreSelectionTestInput | SelectionTestQuestionCreateOrConnectWithoutPreSelectionTestInput[]
    createMany?: SelectionTestQuestionCreateManyPreSelectionTestInputEnvelope
    connect?: SelectionTestQuestionWhereUniqueInput | SelectionTestQuestionWhereUniqueInput[]
  }

  export type JobUpdateOneRequiredWithoutPreSelectionTestNestedInput = {
    create?: XOR<JobCreateWithoutPreSelectionTestInput, JobUncheckedCreateWithoutPreSelectionTestInput>
    connectOrCreate?: JobCreateOrConnectWithoutPreSelectionTestInput
    upsert?: JobUpsertWithoutPreSelectionTestInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutPreSelectionTestInput, JobUpdateWithoutPreSelectionTestInput>, JobUncheckedUpdateWithoutPreSelectionTestInput>
  }

  export type SelectionTestQuestionUpdateManyWithoutPreSelectionTestNestedInput = {
    create?: XOR<SelectionTestQuestionCreateWithoutPreSelectionTestInput, SelectionTestQuestionUncheckedCreateWithoutPreSelectionTestInput> | SelectionTestQuestionCreateWithoutPreSelectionTestInput[] | SelectionTestQuestionUncheckedCreateWithoutPreSelectionTestInput[]
    connectOrCreate?: SelectionTestQuestionCreateOrConnectWithoutPreSelectionTestInput | SelectionTestQuestionCreateOrConnectWithoutPreSelectionTestInput[]
    upsert?: SelectionTestQuestionUpsertWithWhereUniqueWithoutPreSelectionTestInput | SelectionTestQuestionUpsertWithWhereUniqueWithoutPreSelectionTestInput[]
    createMany?: SelectionTestQuestionCreateManyPreSelectionTestInputEnvelope
    set?: SelectionTestQuestionWhereUniqueInput | SelectionTestQuestionWhereUniqueInput[]
    disconnect?: SelectionTestQuestionWhereUniqueInput | SelectionTestQuestionWhereUniqueInput[]
    delete?: SelectionTestQuestionWhereUniqueInput | SelectionTestQuestionWhereUniqueInput[]
    connect?: SelectionTestQuestionWhereUniqueInput | SelectionTestQuestionWhereUniqueInput[]
    update?: SelectionTestQuestionUpdateWithWhereUniqueWithoutPreSelectionTestInput | SelectionTestQuestionUpdateWithWhereUniqueWithoutPreSelectionTestInput[]
    updateMany?: SelectionTestQuestionUpdateManyWithWhereWithoutPreSelectionTestInput | SelectionTestQuestionUpdateManyWithWhereWithoutPreSelectionTestInput[]
    deleteMany?: SelectionTestQuestionScalarWhereInput | SelectionTestQuestionScalarWhereInput[]
  }

  export type SelectionTestQuestionUncheckedUpdateManyWithoutPreSelectionTestNestedInput = {
    create?: XOR<SelectionTestQuestionCreateWithoutPreSelectionTestInput, SelectionTestQuestionUncheckedCreateWithoutPreSelectionTestInput> | SelectionTestQuestionCreateWithoutPreSelectionTestInput[] | SelectionTestQuestionUncheckedCreateWithoutPreSelectionTestInput[]
    connectOrCreate?: SelectionTestQuestionCreateOrConnectWithoutPreSelectionTestInput | SelectionTestQuestionCreateOrConnectWithoutPreSelectionTestInput[]
    upsert?: SelectionTestQuestionUpsertWithWhereUniqueWithoutPreSelectionTestInput | SelectionTestQuestionUpsertWithWhereUniqueWithoutPreSelectionTestInput[]
    createMany?: SelectionTestQuestionCreateManyPreSelectionTestInputEnvelope
    set?: SelectionTestQuestionWhereUniqueInput | SelectionTestQuestionWhereUniqueInput[]
    disconnect?: SelectionTestQuestionWhereUniqueInput | SelectionTestQuestionWhereUniqueInput[]
    delete?: SelectionTestQuestionWhereUniqueInput | SelectionTestQuestionWhereUniqueInput[]
    connect?: SelectionTestQuestionWhereUniqueInput | SelectionTestQuestionWhereUniqueInput[]
    update?: SelectionTestQuestionUpdateWithWhereUniqueWithoutPreSelectionTestInput | SelectionTestQuestionUpdateWithWhereUniqueWithoutPreSelectionTestInput[]
    updateMany?: SelectionTestQuestionUpdateManyWithWhereWithoutPreSelectionTestInput | SelectionTestQuestionUpdateManyWithWhereWithoutPreSelectionTestInput[]
    deleteMany?: SelectionTestQuestionScalarWhereInput | SelectionTestQuestionScalarWhereInput[]
  }

  export type SelectionTestQuestionCreateoptionsInput = {
    set: string[]
  }

  export type PreSelectionTestCreateNestedOneWithoutSelectionTestQuestionInput = {
    create?: XOR<PreSelectionTestCreateWithoutSelectionTestQuestionInput, PreSelectionTestUncheckedCreateWithoutSelectionTestQuestionInput>
    connectOrCreate?: PreSelectionTestCreateOrConnectWithoutSelectionTestQuestionInput
    connect?: PreSelectionTestWhereUniqueInput
  }

  export type SelectionTestQuestionUpdateoptionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PreSelectionTestUpdateOneRequiredWithoutSelectionTestQuestionNestedInput = {
    create?: XOR<PreSelectionTestCreateWithoutSelectionTestQuestionInput, PreSelectionTestUncheckedCreateWithoutSelectionTestQuestionInput>
    connectOrCreate?: PreSelectionTestCreateOrConnectWithoutSelectionTestQuestionInput
    upsert?: PreSelectionTestUpsertWithoutSelectionTestQuestionInput
    connect?: PreSelectionTestWhereUniqueInput
    update?: XOR<XOR<PreSelectionTestUpdateToOneWithWhereWithoutSelectionTestQuestionInput, PreSelectionTestUpdateWithoutSelectionTestQuestionInput>, PreSelectionTestUncheckedUpdateWithoutSelectionTestQuestionInput>
  }

  export type JobCreateNestedOneWithoutJobApplicationInput = {
    create?: XOR<JobCreateWithoutJobApplicationInput, JobUncheckedCreateWithoutJobApplicationInput>
    connectOrCreate?: JobCreateOrConnectWithoutJobApplicationInput
    connect?: JobWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutJobApplicationInput = {
    create?: XOR<UserCreateWithoutJobApplicationInput, UserUncheckedCreateWithoutJobApplicationInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobApplicationInput
    connect?: UserWhereUniqueInput
  }

  export type EnumJobApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.JobApplicationStatus
  }

  export type JobUpdateOneRequiredWithoutJobApplicationNestedInput = {
    create?: XOR<JobCreateWithoutJobApplicationInput, JobUncheckedCreateWithoutJobApplicationInput>
    connectOrCreate?: JobCreateOrConnectWithoutJobApplicationInput
    upsert?: JobUpsertWithoutJobApplicationInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutJobApplicationInput, JobUpdateWithoutJobApplicationInput>, JobUncheckedUpdateWithoutJobApplicationInput>
  }

  export type UserUpdateOneRequiredWithoutJobApplicationNestedInput = {
    create?: XOR<UserCreateWithoutJobApplicationInput, UserUncheckedCreateWithoutJobApplicationInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobApplicationInput
    upsert?: UserUpsertWithoutJobApplicationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJobApplicationInput, UserUpdateWithoutJobApplicationInput>, UserUncheckedUpdateWithoutJobApplicationInput>
  }

  export type UserCreateNestedOneWithoutInterviewInput = {
    create?: XOR<UserCreateWithoutInterviewInput, UserUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterviewInput
    connect?: UserWhereUniqueInput
  }

  export type JobCreateNestedOneWithoutInterviewInput = {
    create?: XOR<JobCreateWithoutInterviewInput, JobUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: JobCreateOrConnectWithoutInterviewInput
    connect?: JobWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInterviewNestedInput = {
    create?: XOR<UserCreateWithoutInterviewInput, UserUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterviewInput
    upsert?: UserUpsertWithoutInterviewInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInterviewInput, UserUpdateWithoutInterviewInput>, UserUncheckedUpdateWithoutInterviewInput>
  }

  export type JobUpdateOneRequiredWithoutInterviewNestedInput = {
    create?: XOR<JobCreateWithoutInterviewInput, JobUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: JobCreateOrConnectWithoutInterviewInput
    upsert?: JobUpsertWithoutInterviewInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutInterviewInput, JobUpdateWithoutInterviewInput>, JobUncheckedUpdateWithoutInterviewInput>
  }

  export type UserCreateNestedOneWithoutReviewInput = {
    create?: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewInput
    connect?: UserWhereUniqueInput
  }

  export type JobCreateNestedOneWithoutReviewInput = {
    create?: XOR<JobCreateWithoutReviewInput, JobUncheckedCreateWithoutReviewInput>
    connectOrCreate?: JobCreateOrConnectWithoutReviewInput
    connect?: JobWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewInput
    upsert?: UserUpsertWithoutReviewInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewInput, UserUpdateWithoutReviewInput>, UserUncheckedUpdateWithoutReviewInput>
  }

  export type JobUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<JobCreateWithoutReviewInput, JobUncheckedCreateWithoutReviewInput>
    connectOrCreate?: JobCreateOrConnectWithoutReviewInput
    upsert?: JobUpsertWithoutReviewInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutReviewInput, JobUpdateWithoutReviewInput>, JobUncheckedUpdateWithoutReviewInput>
  }

  export type SubscriptionCreateNestedOneWithoutTransactionInput = {
    create?: XOR<SubscriptionCreateWithoutTransactionInput, SubscriptionUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutTransactionInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionInput = {
    create?: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type SubscriptionUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<SubscriptionCreateWithoutTransactionInput, SubscriptionUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutTransactionInput
    upsert?: SubscriptionUpsertWithoutTransactionInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutTransactionInput, SubscriptionUpdateWithoutTransactionInput>, SubscriptionUncheckedUpdateWithoutTransactionInput>
  }

  export type UserUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInput
    upsert?: UserUpsertWithoutTransactionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionInput, UserUpdateWithoutTransactionInput>, UserUncheckedUpdateWithoutTransactionInput>
  }

  export type AssessmentQuestionCreateNestedManyWithoutAssessmentInput = {
    create?: XOR<AssessmentQuestionCreateWithoutAssessmentInput, AssessmentQuestionUncheckedCreateWithoutAssessmentInput> | AssessmentQuestionCreateWithoutAssessmentInput[] | AssessmentQuestionUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: AssessmentQuestionCreateOrConnectWithoutAssessmentInput | AssessmentQuestionCreateOrConnectWithoutAssessmentInput[]
    createMany?: AssessmentQuestionCreateManyAssessmentInputEnvelope
    connect?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
  }

  export type UserAssessmentCreateNestedManyWithoutAssessmentInput = {
    create?: XOR<UserAssessmentCreateWithoutAssessmentInput, UserAssessmentUncheckedCreateWithoutAssessmentInput> | UserAssessmentCreateWithoutAssessmentInput[] | UserAssessmentUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: UserAssessmentCreateOrConnectWithoutAssessmentInput | UserAssessmentCreateOrConnectWithoutAssessmentInput[]
    createMany?: UserAssessmentCreateManyAssessmentInputEnvelope
    connect?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
  }

  export type AssessmentQuestionUncheckedCreateNestedManyWithoutAssessmentInput = {
    create?: XOR<AssessmentQuestionCreateWithoutAssessmentInput, AssessmentQuestionUncheckedCreateWithoutAssessmentInput> | AssessmentQuestionCreateWithoutAssessmentInput[] | AssessmentQuestionUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: AssessmentQuestionCreateOrConnectWithoutAssessmentInput | AssessmentQuestionCreateOrConnectWithoutAssessmentInput[]
    createMany?: AssessmentQuestionCreateManyAssessmentInputEnvelope
    connect?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
  }

  export type UserAssessmentUncheckedCreateNestedManyWithoutAssessmentInput = {
    create?: XOR<UserAssessmentCreateWithoutAssessmentInput, UserAssessmentUncheckedCreateWithoutAssessmentInput> | UserAssessmentCreateWithoutAssessmentInput[] | UserAssessmentUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: UserAssessmentCreateOrConnectWithoutAssessmentInput | UserAssessmentCreateOrConnectWithoutAssessmentInput[]
    createMany?: UserAssessmentCreateManyAssessmentInputEnvelope
    connect?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
  }

  export type AssessmentQuestionUpdateManyWithoutAssessmentNestedInput = {
    create?: XOR<AssessmentQuestionCreateWithoutAssessmentInput, AssessmentQuestionUncheckedCreateWithoutAssessmentInput> | AssessmentQuestionCreateWithoutAssessmentInput[] | AssessmentQuestionUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: AssessmentQuestionCreateOrConnectWithoutAssessmentInput | AssessmentQuestionCreateOrConnectWithoutAssessmentInput[]
    upsert?: AssessmentQuestionUpsertWithWhereUniqueWithoutAssessmentInput | AssessmentQuestionUpsertWithWhereUniqueWithoutAssessmentInput[]
    createMany?: AssessmentQuestionCreateManyAssessmentInputEnvelope
    set?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    disconnect?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    delete?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    connect?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    update?: AssessmentQuestionUpdateWithWhereUniqueWithoutAssessmentInput | AssessmentQuestionUpdateWithWhereUniqueWithoutAssessmentInput[]
    updateMany?: AssessmentQuestionUpdateManyWithWhereWithoutAssessmentInput | AssessmentQuestionUpdateManyWithWhereWithoutAssessmentInput[]
    deleteMany?: AssessmentQuestionScalarWhereInput | AssessmentQuestionScalarWhereInput[]
  }

  export type UserAssessmentUpdateManyWithoutAssessmentNestedInput = {
    create?: XOR<UserAssessmentCreateWithoutAssessmentInput, UserAssessmentUncheckedCreateWithoutAssessmentInput> | UserAssessmentCreateWithoutAssessmentInput[] | UserAssessmentUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: UserAssessmentCreateOrConnectWithoutAssessmentInput | UserAssessmentCreateOrConnectWithoutAssessmentInput[]
    upsert?: UserAssessmentUpsertWithWhereUniqueWithoutAssessmentInput | UserAssessmentUpsertWithWhereUniqueWithoutAssessmentInput[]
    createMany?: UserAssessmentCreateManyAssessmentInputEnvelope
    set?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    disconnect?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    delete?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    connect?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    update?: UserAssessmentUpdateWithWhereUniqueWithoutAssessmentInput | UserAssessmentUpdateWithWhereUniqueWithoutAssessmentInput[]
    updateMany?: UserAssessmentUpdateManyWithWhereWithoutAssessmentInput | UserAssessmentUpdateManyWithWhereWithoutAssessmentInput[]
    deleteMany?: UserAssessmentScalarWhereInput | UserAssessmentScalarWhereInput[]
  }

  export type AssessmentQuestionUncheckedUpdateManyWithoutAssessmentNestedInput = {
    create?: XOR<AssessmentQuestionCreateWithoutAssessmentInput, AssessmentQuestionUncheckedCreateWithoutAssessmentInput> | AssessmentQuestionCreateWithoutAssessmentInput[] | AssessmentQuestionUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: AssessmentQuestionCreateOrConnectWithoutAssessmentInput | AssessmentQuestionCreateOrConnectWithoutAssessmentInput[]
    upsert?: AssessmentQuestionUpsertWithWhereUniqueWithoutAssessmentInput | AssessmentQuestionUpsertWithWhereUniqueWithoutAssessmentInput[]
    createMany?: AssessmentQuestionCreateManyAssessmentInputEnvelope
    set?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    disconnect?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    delete?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    connect?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    update?: AssessmentQuestionUpdateWithWhereUniqueWithoutAssessmentInput | AssessmentQuestionUpdateWithWhereUniqueWithoutAssessmentInput[]
    updateMany?: AssessmentQuestionUpdateManyWithWhereWithoutAssessmentInput | AssessmentQuestionUpdateManyWithWhereWithoutAssessmentInput[]
    deleteMany?: AssessmentQuestionScalarWhereInput | AssessmentQuestionScalarWhereInput[]
  }

  export type UserAssessmentUncheckedUpdateManyWithoutAssessmentNestedInput = {
    create?: XOR<UserAssessmentCreateWithoutAssessmentInput, UserAssessmentUncheckedCreateWithoutAssessmentInput> | UserAssessmentCreateWithoutAssessmentInput[] | UserAssessmentUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: UserAssessmentCreateOrConnectWithoutAssessmentInput | UserAssessmentCreateOrConnectWithoutAssessmentInput[]
    upsert?: UserAssessmentUpsertWithWhereUniqueWithoutAssessmentInput | UserAssessmentUpsertWithWhereUniqueWithoutAssessmentInput[]
    createMany?: UserAssessmentCreateManyAssessmentInputEnvelope
    set?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    disconnect?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    delete?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    connect?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    update?: UserAssessmentUpdateWithWhereUniqueWithoutAssessmentInput | UserAssessmentUpdateWithWhereUniqueWithoutAssessmentInput[]
    updateMany?: UserAssessmentUpdateManyWithWhereWithoutAssessmentInput | UserAssessmentUpdateManyWithWhereWithoutAssessmentInput[]
    deleteMany?: UserAssessmentScalarWhereInput | UserAssessmentScalarWhereInput[]
  }

  export type CertificateCreateNestedOneWithoutUserAssessmentInput = {
    create?: XOR<CertificateCreateWithoutUserAssessmentInput, CertificateUncheckedCreateWithoutUserAssessmentInput>
    connectOrCreate?: CertificateCreateOrConnectWithoutUserAssessmentInput
    connect?: CertificateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserAssessmentInput = {
    create?: XOR<UserCreateWithoutUserAssessmentInput, UserUncheckedCreateWithoutUserAssessmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAssessmentInput
    connect?: UserWhereUniqueInput
  }

  export type AssessmentCreateNestedOneWithoutUserAssessmentInput = {
    create?: XOR<AssessmentCreateWithoutUserAssessmentInput, AssessmentUncheckedCreateWithoutUserAssessmentInput>
    connectOrCreate?: AssessmentCreateOrConnectWithoutUserAssessmentInput
    connect?: AssessmentWhereUniqueInput
  }

  export type NullableEnumUserAssessmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserAssessmentStatus | null
  }

  export type CertificateUpdateOneWithoutUserAssessmentNestedInput = {
    create?: XOR<CertificateCreateWithoutUserAssessmentInput, CertificateUncheckedCreateWithoutUserAssessmentInput>
    connectOrCreate?: CertificateCreateOrConnectWithoutUserAssessmentInput
    upsert?: CertificateUpsertWithoutUserAssessmentInput
    disconnect?: CertificateWhereInput | boolean
    delete?: CertificateWhereInput | boolean
    connect?: CertificateWhereUniqueInput
    update?: XOR<XOR<CertificateUpdateToOneWithWhereWithoutUserAssessmentInput, CertificateUpdateWithoutUserAssessmentInput>, CertificateUncheckedUpdateWithoutUserAssessmentInput>
  }

  export type UserUpdateOneRequiredWithoutUserAssessmentNestedInput = {
    create?: XOR<UserCreateWithoutUserAssessmentInput, UserUncheckedCreateWithoutUserAssessmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAssessmentInput
    upsert?: UserUpsertWithoutUserAssessmentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserAssessmentInput, UserUpdateWithoutUserAssessmentInput>, UserUncheckedUpdateWithoutUserAssessmentInput>
  }

  export type AssessmentUpdateOneRequiredWithoutUserAssessmentNestedInput = {
    create?: XOR<AssessmentCreateWithoutUserAssessmentInput, AssessmentUncheckedCreateWithoutUserAssessmentInput>
    connectOrCreate?: AssessmentCreateOrConnectWithoutUserAssessmentInput
    upsert?: AssessmentUpsertWithoutUserAssessmentInput
    connect?: AssessmentWhereUniqueInput
    update?: XOR<XOR<AssessmentUpdateToOneWithWhereWithoutUserAssessmentInput, AssessmentUpdateWithoutUserAssessmentInput>, AssessmentUncheckedUpdateWithoutUserAssessmentInput>
  }

  export type AssessmentQuestionCreateoptionsInput = {
    set: string[]
  }

  export type AssessmentCreateNestedOneWithoutAssessmentQuestionInput = {
    create?: XOR<AssessmentCreateWithoutAssessmentQuestionInput, AssessmentUncheckedCreateWithoutAssessmentQuestionInput>
    connectOrCreate?: AssessmentCreateOrConnectWithoutAssessmentQuestionInput
    connect?: AssessmentWhereUniqueInput
  }

  export type AssessmentQuestionUpdateoptionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AssessmentUpdateOneRequiredWithoutAssessmentQuestionNestedInput = {
    create?: XOR<AssessmentCreateWithoutAssessmentQuestionInput, AssessmentUncheckedCreateWithoutAssessmentQuestionInput>
    connectOrCreate?: AssessmentCreateOrConnectWithoutAssessmentQuestionInput
    upsert?: AssessmentUpsertWithoutAssessmentQuestionInput
    connect?: AssessmentWhereUniqueInput
    update?: XOR<XOR<AssessmentUpdateToOneWithWhereWithoutAssessmentQuestionInput, AssessmentUpdateWithoutAssessmentQuestionInput>, AssessmentUncheckedUpdateWithoutAssessmentQuestionInput>
  }

  export type UserAssessmentCreateNestedManyWithoutCertificateInput = {
    create?: XOR<UserAssessmentCreateWithoutCertificateInput, UserAssessmentUncheckedCreateWithoutCertificateInput> | UserAssessmentCreateWithoutCertificateInput[] | UserAssessmentUncheckedCreateWithoutCertificateInput[]
    connectOrCreate?: UserAssessmentCreateOrConnectWithoutCertificateInput | UserAssessmentCreateOrConnectWithoutCertificateInput[]
    createMany?: UserAssessmentCreateManyCertificateInputEnvelope
    connect?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
  }

  export type UserAssessmentUncheckedCreateNestedManyWithoutCertificateInput = {
    create?: XOR<UserAssessmentCreateWithoutCertificateInput, UserAssessmentUncheckedCreateWithoutCertificateInput> | UserAssessmentCreateWithoutCertificateInput[] | UserAssessmentUncheckedCreateWithoutCertificateInput[]
    connectOrCreate?: UserAssessmentCreateOrConnectWithoutCertificateInput | UserAssessmentCreateOrConnectWithoutCertificateInput[]
    createMany?: UserAssessmentCreateManyCertificateInputEnvelope
    connect?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
  }

  export type UserAssessmentUpdateManyWithoutCertificateNestedInput = {
    create?: XOR<UserAssessmentCreateWithoutCertificateInput, UserAssessmentUncheckedCreateWithoutCertificateInput> | UserAssessmentCreateWithoutCertificateInput[] | UserAssessmentUncheckedCreateWithoutCertificateInput[]
    connectOrCreate?: UserAssessmentCreateOrConnectWithoutCertificateInput | UserAssessmentCreateOrConnectWithoutCertificateInput[]
    upsert?: UserAssessmentUpsertWithWhereUniqueWithoutCertificateInput | UserAssessmentUpsertWithWhereUniqueWithoutCertificateInput[]
    createMany?: UserAssessmentCreateManyCertificateInputEnvelope
    set?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    disconnect?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    delete?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    connect?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    update?: UserAssessmentUpdateWithWhereUniqueWithoutCertificateInput | UserAssessmentUpdateWithWhereUniqueWithoutCertificateInput[]
    updateMany?: UserAssessmentUpdateManyWithWhereWithoutCertificateInput | UserAssessmentUpdateManyWithWhereWithoutCertificateInput[]
    deleteMany?: UserAssessmentScalarWhereInput | UserAssessmentScalarWhereInput[]
  }

  export type UserAssessmentUncheckedUpdateManyWithoutCertificateNestedInput = {
    create?: XOR<UserAssessmentCreateWithoutCertificateInput, UserAssessmentUncheckedCreateWithoutCertificateInput> | UserAssessmentCreateWithoutCertificateInput[] | UserAssessmentUncheckedCreateWithoutCertificateInput[]
    connectOrCreate?: UserAssessmentCreateOrConnectWithoutCertificateInput | UserAssessmentCreateOrConnectWithoutCertificateInput[]
    upsert?: UserAssessmentUpsertWithWhereUniqueWithoutCertificateInput | UserAssessmentUpsertWithWhereUniqueWithoutCertificateInput[]
    createMany?: UserAssessmentCreateManyCertificateInputEnvelope
    set?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    disconnect?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    delete?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    connect?: UserAssessmentWhereUniqueInput | UserAssessmentWhereUniqueInput[]
    update?: UserAssessmentUpdateWithWhereUniqueWithoutCertificateInput | UserAssessmentUpdateWithWhereUniqueWithoutCertificateInput[]
    updateMany?: UserAssessmentUpdateManyWithWhereWithoutCertificateInput | UserAssessmentUpdateManyWithWhereWithoutCertificateInput[]
    deleteMany?: UserAssessmentScalarWhereInput | UserAssessmentScalarWhereInput[]
  }

  export type SubscriptionCreateNestedOneWithoutUserSubscriptionInput = {
    create?: XOR<SubscriptionCreateWithoutUserSubscriptionInput, SubscriptionUncheckedCreateWithoutUserSubscriptionInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserSubscriptionInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserSubscriptionInput = {
    create?: XOR<UserCreateWithoutUserSubscriptionInput, UserUncheckedCreateWithoutUserSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriptionUpdateOneRequiredWithoutUserSubscriptionNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserSubscriptionInput, SubscriptionUncheckedCreateWithoutUserSubscriptionInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserSubscriptionInput
    upsert?: SubscriptionUpsertWithoutUserSubscriptionInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserSubscriptionInput, SubscriptionUpdateWithoutUserSubscriptionInput>, SubscriptionUncheckedUpdateWithoutUserSubscriptionInput>
  }

  export type UserUpdateOneRequiredWithoutUserSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutUserSubscriptionInput, UserUncheckedCreateWithoutUserSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSubscriptionInput
    upsert?: UserUpsertWithoutUserSubscriptionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSubscriptionInput, UserUpdateWithoutUserSubscriptionInput>, UserUncheckedUpdateWithoutUserSubscriptionInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumLastEduNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LastEdu | EnumLastEduFieldRefInput<$PrismaModel> | null
    in?: $Enums.LastEdu[] | ListEnumLastEduFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LastEdu[] | ListEnumLastEduFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLastEduNullableFilter<$PrismaModel> | $Enums.LastEdu | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumLastEduNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LastEdu | EnumLastEduFieldRefInput<$PrismaModel> | null
    in?: $Enums.LastEdu[] | ListEnumLastEduFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LastEdu[] | ListEnumLastEduFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLastEduNullableWithAggregatesFilter<$PrismaModel> | $Enums.LastEdu | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLastEduNullableFilter<$PrismaModel>
    _max?: NestedEnumLastEduNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumJobCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.JobCategory | EnumJobCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.JobCategory[] | ListEnumJobCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobCategory[] | ListEnumJobCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumJobCategoryFilter<$PrismaModel> | $Enums.JobCategory
  }

  export type NestedEnumJobCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobCategory | EnumJobCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.JobCategory[] | ListEnumJobCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobCategory[] | ListEnumJobCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumJobCategoryWithAggregatesFilter<$PrismaModel> | $Enums.JobCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobCategoryFilter<$PrismaModel>
    _max?: NestedEnumJobCategoryFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionCategory | EnumSubscriptionCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionCategory[] | ListEnumSubscriptionCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionCategory[] | ListEnumSubscriptionCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionCategoryFilter<$PrismaModel> | $Enums.SubscriptionCategory
  }

  export type NestedEnumSubscriptionCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionCategory | EnumSubscriptionCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionCategory[] | ListEnumSubscriptionCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionCategory[] | ListEnumSubscriptionCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionCategoryWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionCategoryFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionCategoryFilter<$PrismaModel>
  }

  export type NestedEnumJobApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobApplicationStatus | EnumJobApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobApplicationStatus[] | ListEnumJobApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobApplicationStatus[] | ListEnumJobApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobApplicationStatusFilter<$PrismaModel> | $Enums.JobApplicationStatus
  }

  export type NestedEnumJobApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobApplicationStatus | EnumJobApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobApplicationStatus[] | ListEnumJobApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobApplicationStatus[] | ListEnumJobApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumJobApplicationStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumUserAssessmentStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserAssessmentStatus | EnumUserAssessmentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserAssessmentStatus[] | ListEnumUserAssessmentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserAssessmentStatus[] | ListEnumUserAssessmentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserAssessmentStatusNullableFilter<$PrismaModel> | $Enums.UserAssessmentStatus | null
  }

  export type NestedEnumUserAssessmentStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserAssessmentStatus | EnumUserAssessmentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserAssessmentStatus[] | ListEnumUserAssessmentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserAssessmentStatus[] | ListEnumUserAssessmentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserAssessmentStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserAssessmentStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserAssessmentStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumUserAssessmentStatusNullableFilter<$PrismaModel>
  }

  export type CurriculumVitaeCreateWithoutUserInput = {
    summary: string
    experience: string
    skill: string
    education: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurriculumVitaeUncheckedCreateWithoutUserInput = {
    id?: number
    summary: string
    experience: string
    skill: string
    education: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurriculumVitaeCreateOrConnectWithoutUserInput = {
    where: CurriculumVitaeWhereUniqueInput
    create: XOR<CurriculumVitaeCreateWithoutUserInput, CurriculumVitaeUncheckedCreateWithoutUserInput>
  }

  export type CurriculumVitaeCreateManyUserInputEnvelope = {
    data: CurriculumVitaeCreateManyUserInput | CurriculumVitaeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type JobApplicationCreateWithoutUserInput = {
    resume: string
    expectedSalary: number
    status?: $Enums.JobApplicationStatus
    isTaken: boolean
    rejectedReview?: string | null
    selectionTestResult?: number | null
    createdAt?: Date | string
    job: JobCreateNestedOneWithoutJobApplicationInput
  }

  export type JobApplicationUncheckedCreateWithoutUserInput = {
    jobId: string
    resume: string
    expectedSalary: number
    status?: $Enums.JobApplicationStatus
    isTaken: boolean
    rejectedReview?: string | null
    selectionTestResult?: number | null
    createdAt?: Date | string
  }

  export type JobApplicationCreateOrConnectWithoutUserInput = {
    where: JobApplicationWhereUniqueInput
    create: XOR<JobApplicationCreateWithoutUserInput, JobApplicationUncheckedCreateWithoutUserInput>
  }

  export type JobApplicationCreateManyUserInputEnvelope = {
    data: JobApplicationCreateManyUserInput | JobApplicationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    review: string
    CultureRating: number
    balanceRating: number
    facilityRating: number
    careerRating: number
    salary: number
    createdAt?: Date | string
    job: JobCreateNestedOneWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    jobId: string
    review: string
    CultureRating: number
    balanceRating: number
    facilityRating: number
    careerRating: number
    salary: number
    createdAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    amount: number
    status: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    subscriptionId: number
    amount: number
    status: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LocationCreateWithoutUserInput = {
    city: string
    province: string
    latitude: number
    longitude: number
    Job?: JobCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutUserInput = {
    id?: number
    city: string
    province: string
    latitude: number
    longitude: number
    Job?: JobUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutUserInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutUserInput, LocationUncheckedCreateWithoutUserInput>
  }

  export type UserAssessmentCreateWithoutUserInput = {
    score?: number
    status?: $Enums.UserAssessmentStatus | null
    endTime: Date | string
    certificate?: CertificateCreateNestedOneWithoutUserAssessmentInput
    assessment: AssessmentCreateNestedOneWithoutUserAssessmentInput
  }

  export type UserAssessmentUncheckedCreateWithoutUserInput = {
    id?: number
    assessmentId: number
    score?: number
    certificateId?: number | null
    status?: $Enums.UserAssessmentStatus | null
    endTime: Date | string
  }

  export type UserAssessmentCreateOrConnectWithoutUserInput = {
    where: UserAssessmentWhereUniqueInput
    create: XOR<UserAssessmentCreateWithoutUserInput, UserAssessmentUncheckedCreateWithoutUserInput>
  }

  export type UserAssessmentCreateManyUserInputEnvelope = {
    data: UserAssessmentCreateManyUserInput | UserAssessmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSubscriptionCreateWithoutUserInput = {
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    assessmentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutUserSubscriptionInput
  }

  export type UserSubscriptionUncheckedCreateWithoutUserInput = {
    subscriptionId: number
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    assessmentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSubscriptionCreateOrConnectWithoutUserInput = {
    where: UserSubscriptionWhereUniqueInput
    create: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type UserSubscriptionCreateManyUserInputEnvelope = {
    data: UserSubscriptionCreateManyUserInput | UserSubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InterviewCreateWithoutUserInput = {
    startTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutInterviewInput
  }

  export type InterviewUncheckedCreateWithoutUserInput = {
    jobId: string
    startTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewCreateOrConnectWithoutUserInput = {
    where: InterviewWhereUniqueInput
    create: XOR<InterviewCreateWithoutUserInput, InterviewUncheckedCreateWithoutUserInput>
  }

  export type InterviewCreateManyUserInputEnvelope = {
    data: InterviewCreateManyUserInput | InterviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CurriculumVitaeUpsertWithWhereUniqueWithoutUserInput = {
    where: CurriculumVitaeWhereUniqueInput
    update: XOR<CurriculumVitaeUpdateWithoutUserInput, CurriculumVitaeUncheckedUpdateWithoutUserInput>
    create: XOR<CurriculumVitaeCreateWithoutUserInput, CurriculumVitaeUncheckedCreateWithoutUserInput>
  }

  export type CurriculumVitaeUpdateWithWhereUniqueWithoutUserInput = {
    where: CurriculumVitaeWhereUniqueInput
    data: XOR<CurriculumVitaeUpdateWithoutUserInput, CurriculumVitaeUncheckedUpdateWithoutUserInput>
  }

  export type CurriculumVitaeUpdateManyWithWhereWithoutUserInput = {
    where: CurriculumVitaeScalarWhereInput
    data: XOR<CurriculumVitaeUpdateManyMutationInput, CurriculumVitaeUncheckedUpdateManyWithoutUserInput>
  }

  export type CurriculumVitaeScalarWhereInput = {
    AND?: CurriculumVitaeScalarWhereInput | CurriculumVitaeScalarWhereInput[]
    OR?: CurriculumVitaeScalarWhereInput[]
    NOT?: CurriculumVitaeScalarWhereInput | CurriculumVitaeScalarWhereInput[]
    id?: IntFilter<"CurriculumVitae"> | number
    userId?: IntFilter<"CurriculumVitae"> | number
    summary?: StringFilter<"CurriculumVitae"> | string
    experience?: StringFilter<"CurriculumVitae"> | string
    skill?: StringFilter<"CurriculumVitae"> | string
    education?: StringFilter<"CurriculumVitae"> | string
    createdAt?: DateTimeFilter<"CurriculumVitae"> | Date | string
    updatedAt?: DateTimeFilter<"CurriculumVitae"> | Date | string
  }

  export type JobApplicationUpsertWithWhereUniqueWithoutUserInput = {
    where: JobApplicationWhereUniqueInput
    update: XOR<JobApplicationUpdateWithoutUserInput, JobApplicationUncheckedUpdateWithoutUserInput>
    create: XOR<JobApplicationCreateWithoutUserInput, JobApplicationUncheckedCreateWithoutUserInput>
  }

  export type JobApplicationUpdateWithWhereUniqueWithoutUserInput = {
    where: JobApplicationWhereUniqueInput
    data: XOR<JobApplicationUpdateWithoutUserInput, JobApplicationUncheckedUpdateWithoutUserInput>
  }

  export type JobApplicationUpdateManyWithWhereWithoutUserInput = {
    where: JobApplicationScalarWhereInput
    data: XOR<JobApplicationUpdateManyMutationInput, JobApplicationUncheckedUpdateManyWithoutUserInput>
  }

  export type JobApplicationScalarWhereInput = {
    AND?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
    OR?: JobApplicationScalarWhereInput[]
    NOT?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
    userId?: IntFilter<"JobApplication"> | number
    jobId?: StringFilter<"JobApplication"> | string
    resume?: StringFilter<"JobApplication"> | string
    expectedSalary?: IntFilter<"JobApplication"> | number
    status?: EnumJobApplicationStatusFilter<"JobApplication"> | $Enums.JobApplicationStatus
    isTaken?: BoolFilter<"JobApplication"> | boolean
    rejectedReview?: StringNullableFilter<"JobApplication"> | string | null
    selectionTestResult?: IntNullableFilter<"JobApplication"> | number | null
    createdAt?: DateTimeFilter<"JobApplication"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    userId?: IntFilter<"Review"> | number
    jobId?: StringFilter<"Review"> | string
    review?: StringFilter<"Review"> | string
    CultureRating?: IntFilter<"Review"> | number
    balanceRating?: IntFilter<"Review"> | number
    facilityRating?: IntFilter<"Review"> | number
    careerRating?: IntFilter<"Review"> | number
    salary?: IntFilter<"Review"> | number
    createdAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: IntFilter<"Transaction"> | number
    subscriptionId?: IntFilter<"Transaction"> | number
    amount?: IntFilter<"Transaction"> | number
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type LocationUpsertWithoutUserInput = {
    update: XOR<LocationUpdateWithoutUserInput, LocationUncheckedUpdateWithoutUserInput>
    create: XOR<LocationCreateWithoutUserInput, LocationUncheckedCreateWithoutUserInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutUserInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutUserInput, LocationUncheckedUpdateWithoutUserInput>
  }

  export type LocationUpdateWithoutUserInput = {
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    Job?: JobUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    Job?: JobUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type UserAssessmentUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAssessmentWhereUniqueInput
    update: XOR<UserAssessmentUpdateWithoutUserInput, UserAssessmentUncheckedUpdateWithoutUserInput>
    create: XOR<UserAssessmentCreateWithoutUserInput, UserAssessmentUncheckedCreateWithoutUserInput>
  }

  export type UserAssessmentUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAssessmentWhereUniqueInput
    data: XOR<UserAssessmentUpdateWithoutUserInput, UserAssessmentUncheckedUpdateWithoutUserInput>
  }

  export type UserAssessmentUpdateManyWithWhereWithoutUserInput = {
    where: UserAssessmentScalarWhereInput
    data: XOR<UserAssessmentUpdateManyMutationInput, UserAssessmentUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAssessmentScalarWhereInput = {
    AND?: UserAssessmentScalarWhereInput | UserAssessmentScalarWhereInput[]
    OR?: UserAssessmentScalarWhereInput[]
    NOT?: UserAssessmentScalarWhereInput | UserAssessmentScalarWhereInput[]
    id?: IntFilter<"UserAssessment"> | number
    userId?: IntFilter<"UserAssessment"> | number
    assessmentId?: IntFilter<"UserAssessment"> | number
    score?: IntFilter<"UserAssessment"> | number
    certificateId?: IntNullableFilter<"UserAssessment"> | number | null
    status?: EnumUserAssessmentStatusNullableFilter<"UserAssessment"> | $Enums.UserAssessmentStatus | null
    endTime?: DateTimeFilter<"UserAssessment"> | Date | string
  }

  export type UserSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSubscriptionWhereUniqueInput
    update: XOR<UserSubscriptionUpdateWithoutUserInput, UserSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSubscriptionCreateWithoutUserInput, UserSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type UserSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSubscriptionWhereUniqueInput
    data: XOR<UserSubscriptionUpdateWithoutUserInput, UserSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type UserSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: UserSubscriptionScalarWhereInput
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSubscriptionScalarWhereInput = {
    AND?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
    OR?: UserSubscriptionScalarWhereInput[]
    NOT?: UserSubscriptionScalarWhereInput | UserSubscriptionScalarWhereInput[]
    userId?: IntFilter<"UserSubscription"> | number
    subscriptionId?: IntFilter<"UserSubscription"> | number
    startDate?: DateTimeFilter<"UserSubscription"> | Date | string
    endDate?: DateTimeFilter<"UserSubscription"> | Date | string
    isActive?: BoolFilter<"UserSubscription"> | boolean
    assessmentCount?: IntFilter<"UserSubscription"> | number
    createdAt?: DateTimeFilter<"UserSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"UserSubscription"> | Date | string
  }

  export type InterviewUpsertWithWhereUniqueWithoutUserInput = {
    where: InterviewWhereUniqueInput
    update: XOR<InterviewUpdateWithoutUserInput, InterviewUncheckedUpdateWithoutUserInput>
    create: XOR<InterviewCreateWithoutUserInput, InterviewUncheckedCreateWithoutUserInput>
  }

  export type InterviewUpdateWithWhereUniqueWithoutUserInput = {
    where: InterviewWhereUniqueInput
    data: XOR<InterviewUpdateWithoutUserInput, InterviewUncheckedUpdateWithoutUserInput>
  }

  export type InterviewUpdateManyWithWhereWithoutUserInput = {
    where: InterviewScalarWhereInput
    data: XOR<InterviewUpdateManyMutationInput, InterviewUncheckedUpdateManyWithoutUserInput>
  }

  export type InterviewScalarWhereInput = {
    AND?: InterviewScalarWhereInput | InterviewScalarWhereInput[]
    OR?: InterviewScalarWhereInput[]
    NOT?: InterviewScalarWhereInput | InterviewScalarWhereInput[]
    userId?: IntFilter<"Interview"> | number
    jobId?: StringFilter<"Interview"> | string
    startTime?: DateTimeFilter<"Interview"> | Date | string
    createdAt?: DateTimeFilter<"Interview"> | Date | string
    updatedAt?: DateTimeFilter<"Interview"> | Date | string
  }

  export type JobCreateWithoutAdminInput = {
    id?: string
    title: string
    banner?: string | null
    category: $Enums.JobCategory
    role: string
    salary?: number | null
    description: string
    endDate: Date | string
    isPublished?: boolean
    isTestActive?: boolean
    tags?: JobCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    location: LocationCreateNestedOneWithoutJobInput
    JobApplication?: JobApplicationCreateNestedManyWithoutJobInput
    PreSelectionTest?: PreSelectionTestCreateNestedManyWithoutJobInput
    Review?: ReviewCreateNestedManyWithoutJobInput
    Interview?: InterviewCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutAdminInput = {
    id?: string
    title: string
    banner?: string | null
    category: $Enums.JobCategory
    role: string
    salary?: number | null
    description: string
    endDate: Date | string
    isPublished?: boolean
    isTestActive?: boolean
    tags?: JobCreatetagsInput | string[]
    locationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    JobApplication?: JobApplicationUncheckedCreateNestedManyWithoutJobInput
    PreSelectionTest?: PreSelectionTestUncheckedCreateNestedManyWithoutJobInput
    Review?: ReviewUncheckedCreateNestedManyWithoutJobInput
    Interview?: InterviewUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutAdminInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutAdminInput, JobUncheckedCreateWithoutAdminInput>
  }

  export type JobCreateManyAdminInputEnvelope = {
    data: JobCreateManyAdminInput | JobCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type JobUpsertWithWhereUniqueWithoutAdminInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutAdminInput, JobUncheckedUpdateWithoutAdminInput>
    create: XOR<JobCreateWithoutAdminInput, JobUncheckedCreateWithoutAdminInput>
  }

  export type JobUpdateWithWhereUniqueWithoutAdminInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutAdminInput, JobUncheckedUpdateWithoutAdminInput>
  }

  export type JobUpdateManyWithWhereWithoutAdminInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutAdminInput>
  }

  export type JobScalarWhereInput = {
    AND?: JobScalarWhereInput | JobScalarWhereInput[]
    OR?: JobScalarWhereInput[]
    NOT?: JobScalarWhereInput | JobScalarWhereInput[]
    id?: StringFilter<"Job"> | string
    title?: StringFilter<"Job"> | string
    adminId?: IntFilter<"Job"> | number
    banner?: StringNullableFilter<"Job"> | string | null
    category?: EnumJobCategoryFilter<"Job"> | $Enums.JobCategory
    role?: StringFilter<"Job"> | string
    salary?: IntNullableFilter<"Job"> | number | null
    description?: StringFilter<"Job"> | string
    endDate?: DateTimeFilter<"Job"> | Date | string
    isPublished?: BoolFilter<"Job"> | boolean
    isTestActive?: BoolFilter<"Job"> | boolean
    tags?: StringNullableListFilter<"Job">
    locationId?: IntFilter<"Job"> | number
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    isActive?: BoolFilter<"Job"> | boolean
  }

  export type AdminCreateWithoutJobInput = {
    companyName: string
    email: string
    password: string
    description: string
    isVerified?: boolean
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    noHandphone: string
  }

  export type AdminUncheckedCreateWithoutJobInput = {
    id?: number
    companyName: string
    email: string
    password: string
    description: string
    isVerified?: boolean
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    noHandphone: string
  }

  export type AdminCreateOrConnectWithoutJobInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutJobInput, AdminUncheckedCreateWithoutJobInput>
  }

  export type LocationCreateWithoutJobInput = {
    city: string
    province: string
    latitude: number
    longitude: number
    User?: UserCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutJobInput = {
    id?: number
    city: string
    province: string
    latitude: number
    longitude: number
    User?: UserUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutJobInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutJobInput, LocationUncheckedCreateWithoutJobInput>
  }

  export type JobApplicationCreateWithoutJobInput = {
    resume: string
    expectedSalary: number
    status?: $Enums.JobApplicationStatus
    isTaken: boolean
    rejectedReview?: string | null
    selectionTestResult?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutJobApplicationInput
  }

  export type JobApplicationUncheckedCreateWithoutJobInput = {
    userId: number
    resume: string
    expectedSalary: number
    status?: $Enums.JobApplicationStatus
    isTaken: boolean
    rejectedReview?: string | null
    selectionTestResult?: number | null
    createdAt?: Date | string
  }

  export type JobApplicationCreateOrConnectWithoutJobInput = {
    where: JobApplicationWhereUniqueInput
    create: XOR<JobApplicationCreateWithoutJobInput, JobApplicationUncheckedCreateWithoutJobInput>
  }

  export type JobApplicationCreateManyJobInputEnvelope = {
    data: JobApplicationCreateManyJobInput | JobApplicationCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type PreSelectionTestCreateWithoutJobInput = {
    title: string
    description: string
    createdAt?: Date | string
    SelectionTestQuestion?: SelectionTestQuestionCreateNestedManyWithoutPreSelectionTestInput
  }

  export type PreSelectionTestUncheckedCreateWithoutJobInput = {
    id?: number
    title: string
    description: string
    createdAt?: Date | string
    SelectionTestQuestion?: SelectionTestQuestionUncheckedCreateNestedManyWithoutPreSelectionTestInput
  }

  export type PreSelectionTestCreateOrConnectWithoutJobInput = {
    where: PreSelectionTestWhereUniqueInput
    create: XOR<PreSelectionTestCreateWithoutJobInput, PreSelectionTestUncheckedCreateWithoutJobInput>
  }

  export type PreSelectionTestCreateManyJobInputEnvelope = {
    data: PreSelectionTestCreateManyJobInput | PreSelectionTestCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutJobInput = {
    review: string
    CultureRating: number
    balanceRating: number
    facilityRating: number
    careerRating: number
    salary: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutJobInput = {
    userId: number
    review: string
    CultureRating: number
    balanceRating: number
    facilityRating: number
    careerRating: number
    salary: number
    createdAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutJobInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutJobInput, ReviewUncheckedCreateWithoutJobInput>
  }

  export type ReviewCreateManyJobInputEnvelope = {
    data: ReviewCreateManyJobInput | ReviewCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type InterviewCreateWithoutJobInput = {
    startTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInterviewInput
  }

  export type InterviewUncheckedCreateWithoutJobInput = {
    userId: number
    startTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewCreateOrConnectWithoutJobInput = {
    where: InterviewWhereUniqueInput
    create: XOR<InterviewCreateWithoutJobInput, InterviewUncheckedCreateWithoutJobInput>
  }

  export type InterviewCreateManyJobInputEnvelope = {
    data: InterviewCreateManyJobInput | InterviewCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutJobInput = {
    update: XOR<AdminUpdateWithoutJobInput, AdminUncheckedUpdateWithoutJobInput>
    create: XOR<AdminCreateWithoutJobInput, AdminUncheckedCreateWithoutJobInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutJobInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutJobInput, AdminUncheckedUpdateWithoutJobInput>
  }

  export type AdminUpdateWithoutJobInput = {
    companyName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    noHandphone?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    noHandphone?: StringFieldUpdateOperationsInput | string
  }

  export type LocationUpsertWithoutJobInput = {
    update: XOR<LocationUpdateWithoutJobInput, LocationUncheckedUpdateWithoutJobInput>
    create: XOR<LocationCreateWithoutJobInput, LocationUncheckedCreateWithoutJobInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutJobInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutJobInput, LocationUncheckedUpdateWithoutJobInput>
  }

  export type LocationUpdateWithoutJobInput = {
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    User?: UserUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    User?: UserUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type JobApplicationUpsertWithWhereUniqueWithoutJobInput = {
    where: JobApplicationWhereUniqueInput
    update: XOR<JobApplicationUpdateWithoutJobInput, JobApplicationUncheckedUpdateWithoutJobInput>
    create: XOR<JobApplicationCreateWithoutJobInput, JobApplicationUncheckedCreateWithoutJobInput>
  }

  export type JobApplicationUpdateWithWhereUniqueWithoutJobInput = {
    where: JobApplicationWhereUniqueInput
    data: XOR<JobApplicationUpdateWithoutJobInput, JobApplicationUncheckedUpdateWithoutJobInput>
  }

  export type JobApplicationUpdateManyWithWhereWithoutJobInput = {
    where: JobApplicationScalarWhereInput
    data: XOR<JobApplicationUpdateManyMutationInput, JobApplicationUncheckedUpdateManyWithoutJobInput>
  }

  export type PreSelectionTestUpsertWithWhereUniqueWithoutJobInput = {
    where: PreSelectionTestWhereUniqueInput
    update: XOR<PreSelectionTestUpdateWithoutJobInput, PreSelectionTestUncheckedUpdateWithoutJobInput>
    create: XOR<PreSelectionTestCreateWithoutJobInput, PreSelectionTestUncheckedCreateWithoutJobInput>
  }

  export type PreSelectionTestUpdateWithWhereUniqueWithoutJobInput = {
    where: PreSelectionTestWhereUniqueInput
    data: XOR<PreSelectionTestUpdateWithoutJobInput, PreSelectionTestUncheckedUpdateWithoutJobInput>
  }

  export type PreSelectionTestUpdateManyWithWhereWithoutJobInput = {
    where: PreSelectionTestScalarWhereInput
    data: XOR<PreSelectionTestUpdateManyMutationInput, PreSelectionTestUncheckedUpdateManyWithoutJobInput>
  }

  export type PreSelectionTestScalarWhereInput = {
    AND?: PreSelectionTestScalarWhereInput | PreSelectionTestScalarWhereInput[]
    OR?: PreSelectionTestScalarWhereInput[]
    NOT?: PreSelectionTestScalarWhereInput | PreSelectionTestScalarWhereInput[]
    id?: IntFilter<"PreSelectionTest"> | number
    title?: StringFilter<"PreSelectionTest"> | string
    description?: StringFilter<"PreSelectionTest"> | string
    jobId?: StringFilter<"PreSelectionTest"> | string
    createdAt?: DateTimeFilter<"PreSelectionTest"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutJobInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutJobInput, ReviewUncheckedUpdateWithoutJobInput>
    create: XOR<ReviewCreateWithoutJobInput, ReviewUncheckedCreateWithoutJobInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutJobInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutJobInput, ReviewUncheckedUpdateWithoutJobInput>
  }

  export type ReviewUpdateManyWithWhereWithoutJobInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutJobInput>
  }

  export type InterviewUpsertWithWhereUniqueWithoutJobInput = {
    where: InterviewWhereUniqueInput
    update: XOR<InterviewUpdateWithoutJobInput, InterviewUncheckedUpdateWithoutJobInput>
    create: XOR<InterviewCreateWithoutJobInput, InterviewUncheckedCreateWithoutJobInput>
  }

  export type InterviewUpdateWithWhereUniqueWithoutJobInput = {
    where: InterviewWhereUniqueInput
    data: XOR<InterviewUpdateWithoutJobInput, InterviewUncheckedUpdateWithoutJobInput>
  }

  export type InterviewUpdateManyWithWhereWithoutJobInput = {
    where: InterviewScalarWhereInput
    data: XOR<InterviewUpdateManyMutationInput, InterviewUncheckedUpdateManyWithoutJobInput>
  }

  export type UserCreateWithoutCurriculumVitaeInput = {
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    createdAt?: Date | string
    updatedAt?: Date | string
    JobApplication?: JobApplicationCreateNestedManyWithoutUserInput
    Review?: ReviewCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    UserAssessment?: UserAssessmentCreateNestedManyWithoutUserInput
    UserSubscription?: UserSubscriptionCreateNestedManyWithoutUserInput
    Interview?: InterviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCurriculumVitaeInput = {
    id?: number
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    domicileId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    JobApplication?: JobApplicationUncheckedCreateNestedManyWithoutUserInput
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    UserAssessment?: UserAssessmentUncheckedCreateNestedManyWithoutUserInput
    UserSubscription?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    Interview?: InterviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCurriculumVitaeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCurriculumVitaeInput, UserUncheckedCreateWithoutCurriculumVitaeInput>
  }

  export type UserUpsertWithoutCurriculumVitaeInput = {
    update: XOR<UserUpdateWithoutCurriculumVitaeInput, UserUncheckedUpdateWithoutCurriculumVitaeInput>
    create: XOR<UserCreateWithoutCurriculumVitaeInput, UserUncheckedCreateWithoutCurriculumVitaeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCurriculumVitaeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCurriculumVitaeInput, UserUncheckedUpdateWithoutCurriculumVitaeInput>
  }

  export type UserUpdateWithoutCurriculumVitaeInput = {
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    JobApplication?: JobApplicationUpdateManyWithoutUserNestedInput
    Review?: ReviewUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    UserAssessment?: UserAssessmentUpdateManyWithoutUserNestedInput
    UserSubscription?: UserSubscriptionUpdateManyWithoutUserNestedInput
    Interview?: InterviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCurriculumVitaeInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    domicileId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    JobApplication?: JobApplicationUncheckedUpdateManyWithoutUserNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    UserAssessment?: UserAssessmentUncheckedUpdateManyWithoutUserNestedInput
    UserSubscription?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Interview?: InterviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type JobCreateWithoutLocationInput = {
    id?: string
    title: string
    banner?: string | null
    category: $Enums.JobCategory
    role: string
    salary?: number | null
    description: string
    endDate: Date | string
    isPublished?: boolean
    isTestActive?: boolean
    tags?: JobCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    admin: AdminCreateNestedOneWithoutJobInput
    JobApplication?: JobApplicationCreateNestedManyWithoutJobInput
    PreSelectionTest?: PreSelectionTestCreateNestedManyWithoutJobInput
    Review?: ReviewCreateNestedManyWithoutJobInput
    Interview?: InterviewCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutLocationInput = {
    id?: string
    title: string
    adminId: number
    banner?: string | null
    category: $Enums.JobCategory
    role: string
    salary?: number | null
    description: string
    endDate: Date | string
    isPublished?: boolean
    isTestActive?: boolean
    tags?: JobCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    JobApplication?: JobApplicationUncheckedCreateNestedManyWithoutJobInput
    PreSelectionTest?: PreSelectionTestUncheckedCreateNestedManyWithoutJobInput
    Review?: ReviewUncheckedCreateNestedManyWithoutJobInput
    Interview?: InterviewUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutLocationInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutLocationInput, JobUncheckedCreateWithoutLocationInput>
  }

  export type JobCreateManyLocationInputEnvelope = {
    data: JobCreateManyLocationInput | JobCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutLocationInput = {
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CurriculumVitae?: CurriculumVitaeCreateNestedManyWithoutUserInput
    JobApplication?: JobApplicationCreateNestedManyWithoutUserInput
    Review?: ReviewCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    UserAssessment?: UserAssessmentCreateNestedManyWithoutUserInput
    UserSubscription?: UserSubscriptionCreateNestedManyWithoutUserInput
    Interview?: InterviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLocationInput = {
    id?: number
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CurriculumVitae?: CurriculumVitaeUncheckedCreateNestedManyWithoutUserInput
    JobApplication?: JobApplicationUncheckedCreateNestedManyWithoutUserInput
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    UserAssessment?: UserAssessmentUncheckedCreateNestedManyWithoutUserInput
    UserSubscription?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    Interview?: InterviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLocationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput>
  }

  export type UserCreateManyLocationInputEnvelope = {
    data: UserCreateManyLocationInput | UserCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type JobUpsertWithWhereUniqueWithoutLocationInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutLocationInput, JobUncheckedUpdateWithoutLocationInput>
    create: XOR<JobCreateWithoutLocationInput, JobUncheckedCreateWithoutLocationInput>
  }

  export type JobUpdateWithWhereUniqueWithoutLocationInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutLocationInput, JobUncheckedUpdateWithoutLocationInput>
  }

  export type JobUpdateManyWithWhereWithoutLocationInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutLocationInput>
  }

  export type UserUpsertWithWhereUniqueWithoutLocationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutLocationInput, UserUncheckedUpdateWithoutLocationInput>
    create: XOR<UserCreateWithoutLocationInput, UserUncheckedCreateWithoutLocationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutLocationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutLocationInput, UserUncheckedUpdateWithoutLocationInput>
  }

  export type UserUpdateManyWithWhereWithoutLocationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutLocationInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    fullname?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    isVerified?: BoolFilter<"User"> | boolean
    avatar?: StringFilter<"User"> | string
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    dob?: DateTimeNullableFilter<"User"> | Date | string | null
    lastEdu?: EnumLastEduNullableFilter<"User"> | $Enums.LastEdu | null
    domicileId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type TransactionCreateWithoutSubscriptionInput = {
    id?: string
    amount: number
    status: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    userId: number
    amount: number
    status: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutSubscriptionInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutSubscriptionInput, TransactionUncheckedCreateWithoutSubscriptionInput>
  }

  export type TransactionCreateManySubscriptionInputEnvelope = {
    data: TransactionCreateManySubscriptionInput | TransactionCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type UserSubscriptionCreateWithoutSubscriptionInput = {
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    assessmentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserSubscriptionInput
  }

  export type UserSubscriptionUncheckedCreateWithoutSubscriptionInput = {
    userId: number
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    assessmentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSubscriptionCreateOrConnectWithoutSubscriptionInput = {
    where: UserSubscriptionWhereUniqueInput
    create: XOR<UserSubscriptionCreateWithoutSubscriptionInput, UserSubscriptionUncheckedCreateWithoutSubscriptionInput>
  }

  export type UserSubscriptionCreateManySubscriptionInputEnvelope = {
    data: UserSubscriptionCreateManySubscriptionInput | UserSubscriptionCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type TransactionUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutSubscriptionInput, TransactionUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<TransactionCreateWithoutSubscriptionInput, TransactionUncheckedCreateWithoutSubscriptionInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutSubscriptionInput, TransactionUncheckedUpdateWithoutSubscriptionInput>
  }

  export type TransactionUpdateManyWithWhereWithoutSubscriptionInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type UserSubscriptionUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: UserSubscriptionWhereUniqueInput
    update: XOR<UserSubscriptionUpdateWithoutSubscriptionInput, UserSubscriptionUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UserSubscriptionCreateWithoutSubscriptionInput, UserSubscriptionUncheckedCreateWithoutSubscriptionInput>
  }

  export type UserSubscriptionUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: UserSubscriptionWhereUniqueInput
    data: XOR<UserSubscriptionUpdateWithoutSubscriptionInput, UserSubscriptionUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserSubscriptionUpdateManyWithWhereWithoutSubscriptionInput = {
    where: UserSubscriptionScalarWhereInput
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type JobCreateWithoutPreSelectionTestInput = {
    id?: string
    title: string
    banner?: string | null
    category: $Enums.JobCategory
    role: string
    salary?: number | null
    description: string
    endDate: Date | string
    isPublished?: boolean
    isTestActive?: boolean
    tags?: JobCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    admin: AdminCreateNestedOneWithoutJobInput
    location: LocationCreateNestedOneWithoutJobInput
    JobApplication?: JobApplicationCreateNestedManyWithoutJobInput
    Review?: ReviewCreateNestedManyWithoutJobInput
    Interview?: InterviewCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutPreSelectionTestInput = {
    id?: string
    title: string
    adminId: number
    banner?: string | null
    category: $Enums.JobCategory
    role: string
    salary?: number | null
    description: string
    endDate: Date | string
    isPublished?: boolean
    isTestActive?: boolean
    tags?: JobCreatetagsInput | string[]
    locationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    JobApplication?: JobApplicationUncheckedCreateNestedManyWithoutJobInput
    Review?: ReviewUncheckedCreateNestedManyWithoutJobInput
    Interview?: InterviewUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutPreSelectionTestInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutPreSelectionTestInput, JobUncheckedCreateWithoutPreSelectionTestInput>
  }

  export type SelectionTestQuestionCreateWithoutPreSelectionTestInput = {
    question: string
    options?: SelectionTestQuestionCreateoptionsInput | string[]
    correctAnswer: number
  }

  export type SelectionTestQuestionUncheckedCreateWithoutPreSelectionTestInput = {
    id?: number
    question: string
    options?: SelectionTestQuestionCreateoptionsInput | string[]
    correctAnswer: number
  }

  export type SelectionTestQuestionCreateOrConnectWithoutPreSelectionTestInput = {
    where: SelectionTestQuestionWhereUniqueInput
    create: XOR<SelectionTestQuestionCreateWithoutPreSelectionTestInput, SelectionTestQuestionUncheckedCreateWithoutPreSelectionTestInput>
  }

  export type SelectionTestQuestionCreateManyPreSelectionTestInputEnvelope = {
    data: SelectionTestQuestionCreateManyPreSelectionTestInput | SelectionTestQuestionCreateManyPreSelectionTestInput[]
    skipDuplicates?: boolean
  }

  export type JobUpsertWithoutPreSelectionTestInput = {
    update: XOR<JobUpdateWithoutPreSelectionTestInput, JobUncheckedUpdateWithoutPreSelectionTestInput>
    create: XOR<JobCreateWithoutPreSelectionTestInput, JobUncheckedCreateWithoutPreSelectionTestInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutPreSelectionTestInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutPreSelectionTestInput, JobUncheckedUpdateWithoutPreSelectionTestInput>
  }

  export type JobUpdateWithoutPreSelectionTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumJobCategoryFieldUpdateOperationsInput | $Enums.JobCategory
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isTestActive?: BoolFieldUpdateOperationsInput | boolean
    tags?: JobUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    admin?: AdminUpdateOneRequiredWithoutJobNestedInput
    location?: LocationUpdateOneRequiredWithoutJobNestedInput
    JobApplication?: JobApplicationUpdateManyWithoutJobNestedInput
    Review?: ReviewUpdateManyWithoutJobNestedInput
    Interview?: InterviewUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutPreSelectionTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    adminId?: IntFieldUpdateOperationsInput | number
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumJobCategoryFieldUpdateOperationsInput | $Enums.JobCategory
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isTestActive?: BoolFieldUpdateOperationsInput | boolean
    tags?: JobUpdatetagsInput | string[]
    locationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    JobApplication?: JobApplicationUncheckedUpdateManyWithoutJobNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutJobNestedInput
    Interview?: InterviewUncheckedUpdateManyWithoutJobNestedInput
  }

  export type SelectionTestQuestionUpsertWithWhereUniqueWithoutPreSelectionTestInput = {
    where: SelectionTestQuestionWhereUniqueInput
    update: XOR<SelectionTestQuestionUpdateWithoutPreSelectionTestInput, SelectionTestQuestionUncheckedUpdateWithoutPreSelectionTestInput>
    create: XOR<SelectionTestQuestionCreateWithoutPreSelectionTestInput, SelectionTestQuestionUncheckedCreateWithoutPreSelectionTestInput>
  }

  export type SelectionTestQuestionUpdateWithWhereUniqueWithoutPreSelectionTestInput = {
    where: SelectionTestQuestionWhereUniqueInput
    data: XOR<SelectionTestQuestionUpdateWithoutPreSelectionTestInput, SelectionTestQuestionUncheckedUpdateWithoutPreSelectionTestInput>
  }

  export type SelectionTestQuestionUpdateManyWithWhereWithoutPreSelectionTestInput = {
    where: SelectionTestQuestionScalarWhereInput
    data: XOR<SelectionTestQuestionUpdateManyMutationInput, SelectionTestQuestionUncheckedUpdateManyWithoutPreSelectionTestInput>
  }

  export type SelectionTestQuestionScalarWhereInput = {
    AND?: SelectionTestQuestionScalarWhereInput | SelectionTestQuestionScalarWhereInput[]
    OR?: SelectionTestQuestionScalarWhereInput[]
    NOT?: SelectionTestQuestionScalarWhereInput | SelectionTestQuestionScalarWhereInput[]
    id?: IntFilter<"SelectionTestQuestion"> | number
    preSelectionTestId?: IntFilter<"SelectionTestQuestion"> | number
    question?: StringFilter<"SelectionTestQuestion"> | string
    options?: StringNullableListFilter<"SelectionTestQuestion">
    correctAnswer?: IntFilter<"SelectionTestQuestion"> | number
  }

  export type PreSelectionTestCreateWithoutSelectionTestQuestionInput = {
    title: string
    description: string
    createdAt?: Date | string
    job: JobCreateNestedOneWithoutPreSelectionTestInput
  }

  export type PreSelectionTestUncheckedCreateWithoutSelectionTestQuestionInput = {
    id?: number
    title: string
    description: string
    jobId: string
    createdAt?: Date | string
  }

  export type PreSelectionTestCreateOrConnectWithoutSelectionTestQuestionInput = {
    where: PreSelectionTestWhereUniqueInput
    create: XOR<PreSelectionTestCreateWithoutSelectionTestQuestionInput, PreSelectionTestUncheckedCreateWithoutSelectionTestQuestionInput>
  }

  export type PreSelectionTestUpsertWithoutSelectionTestQuestionInput = {
    update: XOR<PreSelectionTestUpdateWithoutSelectionTestQuestionInput, PreSelectionTestUncheckedUpdateWithoutSelectionTestQuestionInput>
    create: XOR<PreSelectionTestCreateWithoutSelectionTestQuestionInput, PreSelectionTestUncheckedCreateWithoutSelectionTestQuestionInput>
    where?: PreSelectionTestWhereInput
  }

  export type PreSelectionTestUpdateToOneWithWhereWithoutSelectionTestQuestionInput = {
    where?: PreSelectionTestWhereInput
    data: XOR<PreSelectionTestUpdateWithoutSelectionTestQuestionInput, PreSelectionTestUncheckedUpdateWithoutSelectionTestQuestionInput>
  }

  export type PreSelectionTestUpdateWithoutSelectionTestQuestionInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutPreSelectionTestNestedInput
  }

  export type PreSelectionTestUncheckedUpdateWithoutSelectionTestQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateWithoutJobApplicationInput = {
    id?: string
    title: string
    banner?: string | null
    category: $Enums.JobCategory
    role: string
    salary?: number | null
    description: string
    endDate: Date | string
    isPublished?: boolean
    isTestActive?: boolean
    tags?: JobCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    admin: AdminCreateNestedOneWithoutJobInput
    location: LocationCreateNestedOneWithoutJobInput
    PreSelectionTest?: PreSelectionTestCreateNestedManyWithoutJobInput
    Review?: ReviewCreateNestedManyWithoutJobInput
    Interview?: InterviewCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutJobApplicationInput = {
    id?: string
    title: string
    adminId: number
    banner?: string | null
    category: $Enums.JobCategory
    role: string
    salary?: number | null
    description: string
    endDate: Date | string
    isPublished?: boolean
    isTestActive?: boolean
    tags?: JobCreatetagsInput | string[]
    locationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    PreSelectionTest?: PreSelectionTestUncheckedCreateNestedManyWithoutJobInput
    Review?: ReviewUncheckedCreateNestedManyWithoutJobInput
    Interview?: InterviewUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutJobApplicationInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutJobApplicationInput, JobUncheckedCreateWithoutJobApplicationInput>
  }

  export type UserCreateWithoutJobApplicationInput = {
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CurriculumVitae?: CurriculumVitaeCreateNestedManyWithoutUserInput
    Review?: ReviewCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    UserAssessment?: UserAssessmentCreateNestedManyWithoutUserInput
    UserSubscription?: UserSubscriptionCreateNestedManyWithoutUserInput
    Interview?: InterviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutJobApplicationInput = {
    id?: number
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    domicileId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CurriculumVitae?: CurriculumVitaeUncheckedCreateNestedManyWithoutUserInput
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    UserAssessment?: UserAssessmentUncheckedCreateNestedManyWithoutUserInput
    UserSubscription?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    Interview?: InterviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutJobApplicationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJobApplicationInput, UserUncheckedCreateWithoutJobApplicationInput>
  }

  export type JobUpsertWithoutJobApplicationInput = {
    update: XOR<JobUpdateWithoutJobApplicationInput, JobUncheckedUpdateWithoutJobApplicationInput>
    create: XOR<JobCreateWithoutJobApplicationInput, JobUncheckedCreateWithoutJobApplicationInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutJobApplicationInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutJobApplicationInput, JobUncheckedUpdateWithoutJobApplicationInput>
  }

  export type JobUpdateWithoutJobApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumJobCategoryFieldUpdateOperationsInput | $Enums.JobCategory
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isTestActive?: BoolFieldUpdateOperationsInput | boolean
    tags?: JobUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    admin?: AdminUpdateOneRequiredWithoutJobNestedInput
    location?: LocationUpdateOneRequiredWithoutJobNestedInput
    PreSelectionTest?: PreSelectionTestUpdateManyWithoutJobNestedInput
    Review?: ReviewUpdateManyWithoutJobNestedInput
    Interview?: InterviewUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutJobApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    adminId?: IntFieldUpdateOperationsInput | number
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumJobCategoryFieldUpdateOperationsInput | $Enums.JobCategory
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isTestActive?: BoolFieldUpdateOperationsInput | boolean
    tags?: JobUpdatetagsInput | string[]
    locationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    PreSelectionTest?: PreSelectionTestUncheckedUpdateManyWithoutJobNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutJobNestedInput
    Interview?: InterviewUncheckedUpdateManyWithoutJobNestedInput
  }

  export type UserUpsertWithoutJobApplicationInput = {
    update: XOR<UserUpdateWithoutJobApplicationInput, UserUncheckedUpdateWithoutJobApplicationInput>
    create: XOR<UserCreateWithoutJobApplicationInput, UserUncheckedCreateWithoutJobApplicationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJobApplicationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJobApplicationInput, UserUncheckedUpdateWithoutJobApplicationInput>
  }

  export type UserUpdateWithoutJobApplicationInput = {
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CurriculumVitae?: CurriculumVitaeUpdateManyWithoutUserNestedInput
    Review?: ReviewUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    UserAssessment?: UserAssessmentUpdateManyWithoutUserNestedInput
    UserSubscription?: UserSubscriptionUpdateManyWithoutUserNestedInput
    Interview?: InterviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutJobApplicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    domicileId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CurriculumVitae?: CurriculumVitaeUncheckedUpdateManyWithoutUserNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    UserAssessment?: UserAssessmentUncheckedUpdateManyWithoutUserNestedInput
    UserSubscription?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Interview?: InterviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInterviewInput = {
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CurriculumVitae?: CurriculumVitaeCreateNestedManyWithoutUserInput
    JobApplication?: JobApplicationCreateNestedManyWithoutUserInput
    Review?: ReviewCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    UserAssessment?: UserAssessmentCreateNestedManyWithoutUserInput
    UserSubscription?: UserSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInterviewInput = {
    id?: number
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    domicileId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CurriculumVitae?: CurriculumVitaeUncheckedCreateNestedManyWithoutUserInput
    JobApplication?: JobApplicationUncheckedCreateNestedManyWithoutUserInput
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    UserAssessment?: UserAssessmentUncheckedCreateNestedManyWithoutUserInput
    UserSubscription?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInterviewInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInterviewInput, UserUncheckedCreateWithoutInterviewInput>
  }

  export type JobCreateWithoutInterviewInput = {
    id?: string
    title: string
    banner?: string | null
    category: $Enums.JobCategory
    role: string
    salary?: number | null
    description: string
    endDate: Date | string
    isPublished?: boolean
    isTestActive?: boolean
    tags?: JobCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    admin: AdminCreateNestedOneWithoutJobInput
    location: LocationCreateNestedOneWithoutJobInput
    JobApplication?: JobApplicationCreateNestedManyWithoutJobInput
    PreSelectionTest?: PreSelectionTestCreateNestedManyWithoutJobInput
    Review?: ReviewCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutInterviewInput = {
    id?: string
    title: string
    adminId: number
    banner?: string | null
    category: $Enums.JobCategory
    role: string
    salary?: number | null
    description: string
    endDate: Date | string
    isPublished?: boolean
    isTestActive?: boolean
    tags?: JobCreatetagsInput | string[]
    locationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    JobApplication?: JobApplicationUncheckedCreateNestedManyWithoutJobInput
    PreSelectionTest?: PreSelectionTestUncheckedCreateNestedManyWithoutJobInput
    Review?: ReviewUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutInterviewInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutInterviewInput, JobUncheckedCreateWithoutInterviewInput>
  }

  export type UserUpsertWithoutInterviewInput = {
    update: XOR<UserUpdateWithoutInterviewInput, UserUncheckedUpdateWithoutInterviewInput>
    create: XOR<UserCreateWithoutInterviewInput, UserUncheckedCreateWithoutInterviewInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInterviewInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInterviewInput, UserUncheckedUpdateWithoutInterviewInput>
  }

  export type UserUpdateWithoutInterviewInput = {
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CurriculumVitae?: CurriculumVitaeUpdateManyWithoutUserNestedInput
    JobApplication?: JobApplicationUpdateManyWithoutUserNestedInput
    Review?: ReviewUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    UserAssessment?: UserAssessmentUpdateManyWithoutUserNestedInput
    UserSubscription?: UserSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInterviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    domicileId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CurriculumVitae?: CurriculumVitaeUncheckedUpdateManyWithoutUserNestedInput
    JobApplication?: JobApplicationUncheckedUpdateManyWithoutUserNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    UserAssessment?: UserAssessmentUncheckedUpdateManyWithoutUserNestedInput
    UserSubscription?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type JobUpsertWithoutInterviewInput = {
    update: XOR<JobUpdateWithoutInterviewInput, JobUncheckedUpdateWithoutInterviewInput>
    create: XOR<JobCreateWithoutInterviewInput, JobUncheckedCreateWithoutInterviewInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutInterviewInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutInterviewInput, JobUncheckedUpdateWithoutInterviewInput>
  }

  export type JobUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumJobCategoryFieldUpdateOperationsInput | $Enums.JobCategory
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isTestActive?: BoolFieldUpdateOperationsInput | boolean
    tags?: JobUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    admin?: AdminUpdateOneRequiredWithoutJobNestedInput
    location?: LocationUpdateOneRequiredWithoutJobNestedInput
    JobApplication?: JobApplicationUpdateManyWithoutJobNestedInput
    PreSelectionTest?: PreSelectionTestUpdateManyWithoutJobNestedInput
    Review?: ReviewUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    adminId?: IntFieldUpdateOperationsInput | number
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumJobCategoryFieldUpdateOperationsInput | $Enums.JobCategory
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isTestActive?: BoolFieldUpdateOperationsInput | boolean
    tags?: JobUpdatetagsInput | string[]
    locationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    JobApplication?: JobApplicationUncheckedUpdateManyWithoutJobNestedInput
    PreSelectionTest?: PreSelectionTestUncheckedUpdateManyWithoutJobNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutJobNestedInput
  }

  export type UserCreateWithoutReviewInput = {
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CurriculumVitae?: CurriculumVitaeCreateNestedManyWithoutUserInput
    JobApplication?: JobApplicationCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    UserAssessment?: UserAssessmentCreateNestedManyWithoutUserInput
    UserSubscription?: UserSubscriptionCreateNestedManyWithoutUserInput
    Interview?: InterviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewInput = {
    id?: number
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    domicileId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CurriculumVitae?: CurriculumVitaeUncheckedCreateNestedManyWithoutUserInput
    JobApplication?: JobApplicationUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    UserAssessment?: UserAssessmentUncheckedCreateNestedManyWithoutUserInput
    UserSubscription?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    Interview?: InterviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
  }

  export type JobCreateWithoutReviewInput = {
    id?: string
    title: string
    banner?: string | null
    category: $Enums.JobCategory
    role: string
    salary?: number | null
    description: string
    endDate: Date | string
    isPublished?: boolean
    isTestActive?: boolean
    tags?: JobCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    admin: AdminCreateNestedOneWithoutJobInput
    location: LocationCreateNestedOneWithoutJobInput
    JobApplication?: JobApplicationCreateNestedManyWithoutJobInput
    PreSelectionTest?: PreSelectionTestCreateNestedManyWithoutJobInput
    Interview?: InterviewCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutReviewInput = {
    id?: string
    title: string
    adminId: number
    banner?: string | null
    category: $Enums.JobCategory
    role: string
    salary?: number | null
    description: string
    endDate: Date | string
    isPublished?: boolean
    isTestActive?: boolean
    tags?: JobCreatetagsInput | string[]
    locationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    JobApplication?: JobApplicationUncheckedCreateNestedManyWithoutJobInput
    PreSelectionTest?: PreSelectionTestUncheckedCreateNestedManyWithoutJobInput
    Interview?: InterviewUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutReviewInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutReviewInput, JobUncheckedCreateWithoutReviewInput>
  }

  export type UserUpsertWithoutReviewInput = {
    update: XOR<UserUpdateWithoutReviewInput, UserUncheckedUpdateWithoutReviewInput>
    create: XOR<UserCreateWithoutReviewInput, UserUncheckedCreateWithoutReviewInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewInput, UserUncheckedUpdateWithoutReviewInput>
  }

  export type UserUpdateWithoutReviewInput = {
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CurriculumVitae?: CurriculumVitaeUpdateManyWithoutUserNestedInput
    JobApplication?: JobApplicationUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    UserAssessment?: UserAssessmentUpdateManyWithoutUserNestedInput
    UserSubscription?: UserSubscriptionUpdateManyWithoutUserNestedInput
    Interview?: InterviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    domicileId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CurriculumVitae?: CurriculumVitaeUncheckedUpdateManyWithoutUserNestedInput
    JobApplication?: JobApplicationUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    UserAssessment?: UserAssessmentUncheckedUpdateManyWithoutUserNestedInput
    UserSubscription?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Interview?: InterviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type JobUpsertWithoutReviewInput = {
    update: XOR<JobUpdateWithoutReviewInput, JobUncheckedUpdateWithoutReviewInput>
    create: XOR<JobCreateWithoutReviewInput, JobUncheckedCreateWithoutReviewInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutReviewInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutReviewInput, JobUncheckedUpdateWithoutReviewInput>
  }

  export type JobUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumJobCategoryFieldUpdateOperationsInput | $Enums.JobCategory
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isTestActive?: BoolFieldUpdateOperationsInput | boolean
    tags?: JobUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    admin?: AdminUpdateOneRequiredWithoutJobNestedInput
    location?: LocationUpdateOneRequiredWithoutJobNestedInput
    JobApplication?: JobApplicationUpdateManyWithoutJobNestedInput
    PreSelectionTest?: PreSelectionTestUpdateManyWithoutJobNestedInput
    Interview?: InterviewUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    adminId?: IntFieldUpdateOperationsInput | number
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumJobCategoryFieldUpdateOperationsInput | $Enums.JobCategory
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isTestActive?: BoolFieldUpdateOperationsInput | boolean
    tags?: JobUpdatetagsInput | string[]
    locationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    JobApplication?: JobApplicationUncheckedUpdateManyWithoutJobNestedInput
    PreSelectionTest?: PreSelectionTestUncheckedUpdateManyWithoutJobNestedInput
    Interview?: InterviewUncheckedUpdateManyWithoutJobNestedInput
  }

  export type SubscriptionCreateWithoutTransactionInput = {
    category: $Enums.SubscriptionCategory
    price: number
    feature: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSubscription?: UserSubscriptionCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutTransactionInput = {
    id?: number
    category: $Enums.SubscriptionCategory
    price: number
    feature: string
    createdAt?: Date | string
    updatedAt?: Date | string
    UserSubscription?: UserSubscriptionUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutTransactionInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutTransactionInput, SubscriptionUncheckedCreateWithoutTransactionInput>
  }

  export type UserCreateWithoutTransactionInput = {
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CurriculumVitae?: CurriculumVitaeCreateNestedManyWithoutUserInput
    JobApplication?: JobApplicationCreateNestedManyWithoutUserInput
    Review?: ReviewCreateNestedManyWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    UserAssessment?: UserAssessmentCreateNestedManyWithoutUserInput
    UserSubscription?: UserSubscriptionCreateNestedManyWithoutUserInput
    Interview?: InterviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionInput = {
    id?: number
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    domicileId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CurriculumVitae?: CurriculumVitaeUncheckedCreateNestedManyWithoutUserInput
    JobApplication?: JobApplicationUncheckedCreateNestedManyWithoutUserInput
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    UserAssessment?: UserAssessmentUncheckedCreateNestedManyWithoutUserInput
    UserSubscription?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    Interview?: InterviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
  }

  export type SubscriptionUpsertWithoutTransactionInput = {
    update: XOR<SubscriptionUpdateWithoutTransactionInput, SubscriptionUncheckedUpdateWithoutTransactionInput>
    create: XOR<SubscriptionCreateWithoutTransactionInput, SubscriptionUncheckedCreateWithoutTransactionInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutTransactionInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutTransactionInput, SubscriptionUncheckedUpdateWithoutTransactionInput>
  }

  export type SubscriptionUpdateWithoutTransactionInput = {
    category?: EnumSubscriptionCategoryFieldUpdateOperationsInput | $Enums.SubscriptionCategory
    price?: IntFieldUpdateOperationsInput | number
    feature?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSubscription?: UserSubscriptionUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: EnumSubscriptionCategoryFieldUpdateOperationsInput | $Enums.SubscriptionCategory
    price?: IntFieldUpdateOperationsInput | number
    feature?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSubscription?: UserSubscriptionUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type UserUpsertWithoutTransactionInput = {
    update: XOR<UserUpdateWithoutTransactionInput, UserUncheckedUpdateWithoutTransactionInput>
    create: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionInput, UserUncheckedUpdateWithoutTransactionInput>
  }

  export type UserUpdateWithoutTransactionInput = {
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CurriculumVitae?: CurriculumVitaeUpdateManyWithoutUserNestedInput
    JobApplication?: JobApplicationUpdateManyWithoutUserNestedInput
    Review?: ReviewUpdateManyWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    UserAssessment?: UserAssessmentUpdateManyWithoutUserNestedInput
    UserSubscription?: UserSubscriptionUpdateManyWithoutUserNestedInput
    Interview?: InterviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    domicileId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CurriculumVitae?: CurriculumVitaeUncheckedUpdateManyWithoutUserNestedInput
    JobApplication?: JobApplicationUncheckedUpdateManyWithoutUserNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    UserAssessment?: UserAssessmentUncheckedUpdateManyWithoutUserNestedInput
    UserSubscription?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Interview?: InterviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AssessmentQuestionCreateWithoutAssessmentInput = {
    question: string
    options?: AssessmentQuestionCreateoptionsInput | string[]
    correctAnswer: number
  }

  export type AssessmentQuestionUncheckedCreateWithoutAssessmentInput = {
    id?: number
    question: string
    options?: AssessmentQuestionCreateoptionsInput | string[]
    correctAnswer: number
  }

  export type AssessmentQuestionCreateOrConnectWithoutAssessmentInput = {
    where: AssessmentQuestionWhereUniqueInput
    create: XOR<AssessmentQuestionCreateWithoutAssessmentInput, AssessmentQuestionUncheckedCreateWithoutAssessmentInput>
  }

  export type AssessmentQuestionCreateManyAssessmentInputEnvelope = {
    data: AssessmentQuestionCreateManyAssessmentInput | AssessmentQuestionCreateManyAssessmentInput[]
    skipDuplicates?: boolean
  }

  export type UserAssessmentCreateWithoutAssessmentInput = {
    score?: number
    status?: $Enums.UserAssessmentStatus | null
    endTime: Date | string
    certificate?: CertificateCreateNestedOneWithoutUserAssessmentInput
    User: UserCreateNestedOneWithoutUserAssessmentInput
  }

  export type UserAssessmentUncheckedCreateWithoutAssessmentInput = {
    id?: number
    userId: number
    score?: number
    certificateId?: number | null
    status?: $Enums.UserAssessmentStatus | null
    endTime: Date | string
  }

  export type UserAssessmentCreateOrConnectWithoutAssessmentInput = {
    where: UserAssessmentWhereUniqueInput
    create: XOR<UserAssessmentCreateWithoutAssessmentInput, UserAssessmentUncheckedCreateWithoutAssessmentInput>
  }

  export type UserAssessmentCreateManyAssessmentInputEnvelope = {
    data: UserAssessmentCreateManyAssessmentInput | UserAssessmentCreateManyAssessmentInput[]
    skipDuplicates?: boolean
  }

  export type AssessmentQuestionUpsertWithWhereUniqueWithoutAssessmentInput = {
    where: AssessmentQuestionWhereUniqueInput
    update: XOR<AssessmentQuestionUpdateWithoutAssessmentInput, AssessmentQuestionUncheckedUpdateWithoutAssessmentInput>
    create: XOR<AssessmentQuestionCreateWithoutAssessmentInput, AssessmentQuestionUncheckedCreateWithoutAssessmentInput>
  }

  export type AssessmentQuestionUpdateWithWhereUniqueWithoutAssessmentInput = {
    where: AssessmentQuestionWhereUniqueInput
    data: XOR<AssessmentQuestionUpdateWithoutAssessmentInput, AssessmentQuestionUncheckedUpdateWithoutAssessmentInput>
  }

  export type AssessmentQuestionUpdateManyWithWhereWithoutAssessmentInput = {
    where: AssessmentQuestionScalarWhereInput
    data: XOR<AssessmentQuestionUpdateManyMutationInput, AssessmentQuestionUncheckedUpdateManyWithoutAssessmentInput>
  }

  export type AssessmentQuestionScalarWhereInput = {
    AND?: AssessmentQuestionScalarWhereInput | AssessmentQuestionScalarWhereInput[]
    OR?: AssessmentQuestionScalarWhereInput[]
    NOT?: AssessmentQuestionScalarWhereInput | AssessmentQuestionScalarWhereInput[]
    id?: IntFilter<"AssessmentQuestion"> | number
    assessmentId?: IntFilter<"AssessmentQuestion"> | number
    question?: StringFilter<"AssessmentQuestion"> | string
    options?: StringNullableListFilter<"AssessmentQuestion">
    correctAnswer?: IntFilter<"AssessmentQuestion"> | number
  }

  export type UserAssessmentUpsertWithWhereUniqueWithoutAssessmentInput = {
    where: UserAssessmentWhereUniqueInput
    update: XOR<UserAssessmentUpdateWithoutAssessmentInput, UserAssessmentUncheckedUpdateWithoutAssessmentInput>
    create: XOR<UserAssessmentCreateWithoutAssessmentInput, UserAssessmentUncheckedCreateWithoutAssessmentInput>
  }

  export type UserAssessmentUpdateWithWhereUniqueWithoutAssessmentInput = {
    where: UserAssessmentWhereUniqueInput
    data: XOR<UserAssessmentUpdateWithoutAssessmentInput, UserAssessmentUncheckedUpdateWithoutAssessmentInput>
  }

  export type UserAssessmentUpdateManyWithWhereWithoutAssessmentInput = {
    where: UserAssessmentScalarWhereInput
    data: XOR<UserAssessmentUpdateManyMutationInput, UserAssessmentUncheckedUpdateManyWithoutAssessmentInput>
  }

  export type CertificateCreateWithoutUserAssessmentInput = {
    CertificateUrl: string
    badgeName: string
    badgeIcon: string
    createdAt?: Date | string
  }

  export type CertificateUncheckedCreateWithoutUserAssessmentInput = {
    id?: number
    CertificateUrl: string
    badgeName: string
    badgeIcon: string
    createdAt?: Date | string
  }

  export type CertificateCreateOrConnectWithoutUserAssessmentInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutUserAssessmentInput, CertificateUncheckedCreateWithoutUserAssessmentInput>
  }

  export type UserCreateWithoutUserAssessmentInput = {
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CurriculumVitae?: CurriculumVitaeCreateNestedManyWithoutUserInput
    JobApplication?: JobApplicationCreateNestedManyWithoutUserInput
    Review?: ReviewCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    UserSubscription?: UserSubscriptionCreateNestedManyWithoutUserInput
    Interview?: InterviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserAssessmentInput = {
    id?: number
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    domicileId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CurriculumVitae?: CurriculumVitaeUncheckedCreateNestedManyWithoutUserInput
    JobApplication?: JobApplicationUncheckedCreateNestedManyWithoutUserInput
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    UserSubscription?: UserSubscriptionUncheckedCreateNestedManyWithoutUserInput
    Interview?: InterviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserAssessmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserAssessmentInput, UserUncheckedCreateWithoutUserAssessmentInput>
  }

  export type AssessmentCreateWithoutUserAssessmentInput = {
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    AssessmentQuestion?: AssessmentQuestionCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentUncheckedCreateWithoutUserAssessmentInput = {
    id?: number
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    AssessmentQuestion?: AssessmentQuestionUncheckedCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentCreateOrConnectWithoutUserAssessmentInput = {
    where: AssessmentWhereUniqueInput
    create: XOR<AssessmentCreateWithoutUserAssessmentInput, AssessmentUncheckedCreateWithoutUserAssessmentInput>
  }

  export type CertificateUpsertWithoutUserAssessmentInput = {
    update: XOR<CertificateUpdateWithoutUserAssessmentInput, CertificateUncheckedUpdateWithoutUserAssessmentInput>
    create: XOR<CertificateCreateWithoutUserAssessmentInput, CertificateUncheckedCreateWithoutUserAssessmentInput>
    where?: CertificateWhereInput
  }

  export type CertificateUpdateToOneWithWhereWithoutUserAssessmentInput = {
    where?: CertificateWhereInput
    data: XOR<CertificateUpdateWithoutUserAssessmentInput, CertificateUncheckedUpdateWithoutUserAssessmentInput>
  }

  export type CertificateUpdateWithoutUserAssessmentInput = {
    CertificateUrl?: StringFieldUpdateOperationsInput | string
    badgeName?: StringFieldUpdateOperationsInput | string
    badgeIcon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateWithoutUserAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    CertificateUrl?: StringFieldUpdateOperationsInput | string
    badgeName?: StringFieldUpdateOperationsInput | string
    badgeIcon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutUserAssessmentInput = {
    update: XOR<UserUpdateWithoutUserAssessmentInput, UserUncheckedUpdateWithoutUserAssessmentInput>
    create: XOR<UserCreateWithoutUserAssessmentInput, UserUncheckedCreateWithoutUserAssessmentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserAssessmentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserAssessmentInput, UserUncheckedUpdateWithoutUserAssessmentInput>
  }

  export type UserUpdateWithoutUserAssessmentInput = {
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CurriculumVitae?: CurriculumVitaeUpdateManyWithoutUserNestedInput
    JobApplication?: JobApplicationUpdateManyWithoutUserNestedInput
    Review?: ReviewUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    UserSubscription?: UserSubscriptionUpdateManyWithoutUserNestedInput
    Interview?: InterviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    domicileId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CurriculumVitae?: CurriculumVitaeUncheckedUpdateManyWithoutUserNestedInput
    JobApplication?: JobApplicationUncheckedUpdateManyWithoutUserNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    UserSubscription?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Interview?: InterviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AssessmentUpsertWithoutUserAssessmentInput = {
    update: XOR<AssessmentUpdateWithoutUserAssessmentInput, AssessmentUncheckedUpdateWithoutUserAssessmentInput>
    create: XOR<AssessmentCreateWithoutUserAssessmentInput, AssessmentUncheckedCreateWithoutUserAssessmentInput>
    where?: AssessmentWhereInput
  }

  export type AssessmentUpdateToOneWithWhereWithoutUserAssessmentInput = {
    where?: AssessmentWhereInput
    data: XOR<AssessmentUpdateWithoutUserAssessmentInput, AssessmentUncheckedUpdateWithoutUserAssessmentInput>
  }

  export type AssessmentUpdateWithoutUserAssessmentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AssessmentQuestion?: AssessmentQuestionUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentUncheckedUpdateWithoutUserAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AssessmentQuestion?: AssessmentQuestionUncheckedUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentCreateWithoutAssessmentQuestionInput = {
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    UserAssessment?: UserAssessmentCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentUncheckedCreateWithoutAssessmentQuestionInput = {
    id?: number
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    UserAssessment?: UserAssessmentUncheckedCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentCreateOrConnectWithoutAssessmentQuestionInput = {
    where: AssessmentWhereUniqueInput
    create: XOR<AssessmentCreateWithoutAssessmentQuestionInput, AssessmentUncheckedCreateWithoutAssessmentQuestionInput>
  }

  export type AssessmentUpsertWithoutAssessmentQuestionInput = {
    update: XOR<AssessmentUpdateWithoutAssessmentQuestionInput, AssessmentUncheckedUpdateWithoutAssessmentQuestionInput>
    create: XOR<AssessmentCreateWithoutAssessmentQuestionInput, AssessmentUncheckedCreateWithoutAssessmentQuestionInput>
    where?: AssessmentWhereInput
  }

  export type AssessmentUpdateToOneWithWhereWithoutAssessmentQuestionInput = {
    where?: AssessmentWhereInput
    data: XOR<AssessmentUpdateWithoutAssessmentQuestionInput, AssessmentUncheckedUpdateWithoutAssessmentQuestionInput>
  }

  export type AssessmentUpdateWithoutAssessmentQuestionInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserAssessment?: UserAssessmentUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentUncheckedUpdateWithoutAssessmentQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserAssessment?: UserAssessmentUncheckedUpdateManyWithoutAssessmentNestedInput
  }

  export type UserAssessmentCreateWithoutCertificateInput = {
    score?: number
    status?: $Enums.UserAssessmentStatus | null
    endTime: Date | string
    User: UserCreateNestedOneWithoutUserAssessmentInput
    assessment: AssessmentCreateNestedOneWithoutUserAssessmentInput
  }

  export type UserAssessmentUncheckedCreateWithoutCertificateInput = {
    id?: number
    userId: number
    assessmentId: number
    score?: number
    status?: $Enums.UserAssessmentStatus | null
    endTime: Date | string
  }

  export type UserAssessmentCreateOrConnectWithoutCertificateInput = {
    where: UserAssessmentWhereUniqueInput
    create: XOR<UserAssessmentCreateWithoutCertificateInput, UserAssessmentUncheckedCreateWithoutCertificateInput>
  }

  export type UserAssessmentCreateManyCertificateInputEnvelope = {
    data: UserAssessmentCreateManyCertificateInput | UserAssessmentCreateManyCertificateInput[]
    skipDuplicates?: boolean
  }

  export type UserAssessmentUpsertWithWhereUniqueWithoutCertificateInput = {
    where: UserAssessmentWhereUniqueInput
    update: XOR<UserAssessmentUpdateWithoutCertificateInput, UserAssessmentUncheckedUpdateWithoutCertificateInput>
    create: XOR<UserAssessmentCreateWithoutCertificateInput, UserAssessmentUncheckedCreateWithoutCertificateInput>
  }

  export type UserAssessmentUpdateWithWhereUniqueWithoutCertificateInput = {
    where: UserAssessmentWhereUniqueInput
    data: XOR<UserAssessmentUpdateWithoutCertificateInput, UserAssessmentUncheckedUpdateWithoutCertificateInput>
  }

  export type UserAssessmentUpdateManyWithWhereWithoutCertificateInput = {
    where: UserAssessmentScalarWhereInput
    data: XOR<UserAssessmentUpdateManyMutationInput, UserAssessmentUncheckedUpdateManyWithoutCertificateInput>
  }

  export type SubscriptionCreateWithoutUserSubscriptionInput = {
    category: $Enums.SubscriptionCategory
    price: number
    feature: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Transaction?: TransactionCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUserSubscriptionInput = {
    id?: number
    category: $Enums.SubscriptionCategory
    price: number
    feature: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Transaction?: TransactionUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUserSubscriptionInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserSubscriptionInput, SubscriptionUncheckedCreateWithoutUserSubscriptionInput>
  }

  export type UserCreateWithoutUserSubscriptionInput = {
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CurriculumVitae?: CurriculumVitaeCreateNestedManyWithoutUserInput
    JobApplication?: JobApplicationCreateNestedManyWithoutUserInput
    Review?: ReviewCreateNestedManyWithoutUserInput
    Transaction?: TransactionCreateNestedManyWithoutUserInput
    location?: LocationCreateNestedOneWithoutUserInput
    UserAssessment?: UserAssessmentCreateNestedManyWithoutUserInput
    Interview?: InterviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSubscriptionInput = {
    id?: number
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    domicileId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    CurriculumVitae?: CurriculumVitaeUncheckedCreateNestedManyWithoutUserInput
    JobApplication?: JobApplicationUncheckedCreateNestedManyWithoutUserInput
    Review?: ReviewUncheckedCreateNestedManyWithoutUserInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
    UserAssessment?: UserAssessmentUncheckedCreateNestedManyWithoutUserInput
    Interview?: InterviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSubscriptionInput, UserUncheckedCreateWithoutUserSubscriptionInput>
  }

  export type SubscriptionUpsertWithoutUserSubscriptionInput = {
    update: XOR<SubscriptionUpdateWithoutUserSubscriptionInput, SubscriptionUncheckedUpdateWithoutUserSubscriptionInput>
    create: XOR<SubscriptionCreateWithoutUserSubscriptionInput, SubscriptionUncheckedCreateWithoutUserSubscriptionInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutUserSubscriptionInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutUserSubscriptionInput, SubscriptionUncheckedUpdateWithoutUserSubscriptionInput>
  }

  export type SubscriptionUpdateWithoutUserSubscriptionInput = {
    category?: EnumSubscriptionCategoryFieldUpdateOperationsInput | $Enums.SubscriptionCategory
    price?: IntFieldUpdateOperationsInput | number
    feature?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Transaction?: TransactionUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUserSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: EnumSubscriptionCategoryFieldUpdateOperationsInput | $Enums.SubscriptionCategory
    price?: IntFieldUpdateOperationsInput | number
    feature?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Transaction?: TransactionUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type UserUpsertWithoutUserSubscriptionInput = {
    update: XOR<UserUpdateWithoutUserSubscriptionInput, UserUncheckedUpdateWithoutUserSubscriptionInput>
    create: XOR<UserCreateWithoutUserSubscriptionInput, UserUncheckedCreateWithoutUserSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSubscriptionInput, UserUncheckedUpdateWithoutUserSubscriptionInput>
  }

  export type UserUpdateWithoutUserSubscriptionInput = {
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CurriculumVitae?: CurriculumVitaeUpdateManyWithoutUserNestedInput
    JobApplication?: JobApplicationUpdateManyWithoutUserNestedInput
    Review?: ReviewUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    location?: LocationUpdateOneWithoutUserNestedInput
    UserAssessment?: UserAssessmentUpdateManyWithoutUserNestedInput
    Interview?: InterviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    domicileId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CurriculumVitae?: CurriculumVitaeUncheckedUpdateManyWithoutUserNestedInput
    JobApplication?: JobApplicationUncheckedUpdateManyWithoutUserNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    UserAssessment?: UserAssessmentUncheckedUpdateManyWithoutUserNestedInput
    Interview?: InterviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CurriculumVitaeCreateManyUserInput = {
    id?: number
    summary: string
    experience: string
    skill: string
    education: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobApplicationCreateManyUserInput = {
    jobId: string
    resume: string
    expectedSalary: number
    status?: $Enums.JobApplicationStatus
    isTaken: boolean
    rejectedReview?: string | null
    selectionTestResult?: number | null
    createdAt?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    jobId: string
    review: string
    CultureRating: number
    balanceRating: number
    facilityRating: number
    careerRating: number
    salary: number
    createdAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    subscriptionId: number
    amount: number
    status: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAssessmentCreateManyUserInput = {
    id?: number
    assessmentId: number
    score?: number
    certificateId?: number | null
    status?: $Enums.UserAssessmentStatus | null
    endTime: Date | string
  }

  export type UserSubscriptionCreateManyUserInput = {
    subscriptionId: number
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    assessmentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewCreateManyUserInput = {
    jobId: string
    startTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurriculumVitaeUpdateWithoutUserInput = {
    summary?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurriculumVitaeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    summary?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurriculumVitaeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    summary?: StringFieldUpdateOperationsInput | string
    experience?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    education?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationUpdateWithoutUserInput = {
    resume?: StringFieldUpdateOperationsInput | string
    expectedSalary?: IntFieldUpdateOperationsInput | number
    status?: EnumJobApplicationStatusFieldUpdateOperationsInput | $Enums.JobApplicationStatus
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    rejectedReview?: NullableStringFieldUpdateOperationsInput | string | null
    selectionTestResult?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutJobApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateWithoutUserInput = {
    jobId?: StringFieldUpdateOperationsInput | string
    resume?: StringFieldUpdateOperationsInput | string
    expectedSalary?: IntFieldUpdateOperationsInput | number
    status?: EnumJobApplicationStatusFieldUpdateOperationsInput | $Enums.JobApplicationStatus
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    rejectedReview?: NullableStringFieldUpdateOperationsInput | string | null
    selectionTestResult?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationUncheckedUpdateManyWithoutUserInput = {
    jobId?: StringFieldUpdateOperationsInput | string
    resume?: StringFieldUpdateOperationsInput | string
    expectedSalary?: IntFieldUpdateOperationsInput | number
    status?: EnumJobApplicationStatusFieldUpdateOperationsInput | $Enums.JobApplicationStatus
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    rejectedReview?: NullableStringFieldUpdateOperationsInput | string | null
    selectionTestResult?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    review?: StringFieldUpdateOperationsInput | string
    CultureRating?: IntFieldUpdateOperationsInput | number
    balanceRating?: IntFieldUpdateOperationsInput | number
    facilityRating?: IntFieldUpdateOperationsInput | number
    careerRating?: IntFieldUpdateOperationsInput | number
    salary?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    jobId?: StringFieldUpdateOperationsInput | string
    review?: StringFieldUpdateOperationsInput | string
    CultureRating?: IntFieldUpdateOperationsInput | number
    balanceRating?: IntFieldUpdateOperationsInput | number
    facilityRating?: IntFieldUpdateOperationsInput | number
    careerRating?: IntFieldUpdateOperationsInput | number
    salary?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    jobId?: StringFieldUpdateOperationsInput | string
    review?: StringFieldUpdateOperationsInput | string
    CultureRating?: IntFieldUpdateOperationsInput | number
    balanceRating?: IntFieldUpdateOperationsInput | number
    facilityRating?: IntFieldUpdateOperationsInput | number
    careerRating?: IntFieldUpdateOperationsInput | number
    salary?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAssessmentUpdateWithoutUserInput = {
    score?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumUserAssessmentStatusFieldUpdateOperationsInput | $Enums.UserAssessmentStatus | null
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: CertificateUpdateOneWithoutUserAssessmentNestedInput
    assessment?: AssessmentUpdateOneRequiredWithoutUserAssessmentNestedInput
  }

  export type UserAssessmentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    certificateId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumUserAssessmentStatusFieldUpdateOperationsInput | $Enums.UserAssessmentStatus | null
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAssessmentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    certificateId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumUserAssessmentStatusFieldUpdateOperationsInput | $Enums.UserAssessmentStatus | null
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUpdateWithoutUserInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assessmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutUserSubscriptionNestedInput
  }

  export type UserSubscriptionUncheckedUpdateWithoutUserInput = {
    subscriptionId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assessmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUncheckedUpdateManyWithoutUserInput = {
    subscriptionId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assessmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewUpdateWithoutUserInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutInterviewNestedInput
  }

  export type InterviewUncheckedUpdateWithoutUserInput = {
    jobId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewUncheckedUpdateManyWithoutUserInput = {
    jobId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateManyAdminInput = {
    id?: string
    title: string
    banner?: string | null
    category: $Enums.JobCategory
    role: string
    salary?: number | null
    description: string
    endDate: Date | string
    isPublished?: boolean
    isTestActive?: boolean
    tags?: JobCreatetagsInput | string[]
    locationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type JobUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumJobCategoryFieldUpdateOperationsInput | $Enums.JobCategory
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isTestActive?: BoolFieldUpdateOperationsInput | boolean
    tags?: JobUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneRequiredWithoutJobNestedInput
    JobApplication?: JobApplicationUpdateManyWithoutJobNestedInput
    PreSelectionTest?: PreSelectionTestUpdateManyWithoutJobNestedInput
    Review?: ReviewUpdateManyWithoutJobNestedInput
    Interview?: InterviewUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumJobCategoryFieldUpdateOperationsInput | $Enums.JobCategory
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isTestActive?: BoolFieldUpdateOperationsInput | boolean
    tags?: JobUpdatetagsInput | string[]
    locationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    JobApplication?: JobApplicationUncheckedUpdateManyWithoutJobNestedInput
    PreSelectionTest?: PreSelectionTestUncheckedUpdateManyWithoutJobNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutJobNestedInput
    Interview?: InterviewUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumJobCategoryFieldUpdateOperationsInput | $Enums.JobCategory
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isTestActive?: BoolFieldUpdateOperationsInput | boolean
    tags?: JobUpdatetagsInput | string[]
    locationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JobApplicationCreateManyJobInput = {
    userId: number
    resume: string
    expectedSalary: number
    status?: $Enums.JobApplicationStatus
    isTaken: boolean
    rejectedReview?: string | null
    selectionTestResult?: number | null
    createdAt?: Date | string
  }

  export type PreSelectionTestCreateManyJobInput = {
    id?: number
    title: string
    description: string
    createdAt?: Date | string
  }

  export type ReviewCreateManyJobInput = {
    userId: number
    review: string
    CultureRating: number
    balanceRating: number
    facilityRating: number
    careerRating: number
    salary: number
    createdAt?: Date | string
  }

  export type InterviewCreateManyJobInput = {
    userId: number
    startTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobApplicationUpdateWithoutJobInput = {
    resume?: StringFieldUpdateOperationsInput | string
    expectedSalary?: IntFieldUpdateOperationsInput | number
    status?: EnumJobApplicationStatusFieldUpdateOperationsInput | $Enums.JobApplicationStatus
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    rejectedReview?: NullableStringFieldUpdateOperationsInput | string | null
    selectionTestResult?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutJobApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateWithoutJobInput = {
    userId?: IntFieldUpdateOperationsInput | number
    resume?: StringFieldUpdateOperationsInput | string
    expectedSalary?: IntFieldUpdateOperationsInput | number
    status?: EnumJobApplicationStatusFieldUpdateOperationsInput | $Enums.JobApplicationStatus
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    rejectedReview?: NullableStringFieldUpdateOperationsInput | string | null
    selectionTestResult?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationUncheckedUpdateManyWithoutJobInput = {
    userId?: IntFieldUpdateOperationsInput | number
    resume?: StringFieldUpdateOperationsInput | string
    expectedSalary?: IntFieldUpdateOperationsInput | number
    status?: EnumJobApplicationStatusFieldUpdateOperationsInput | $Enums.JobApplicationStatus
    isTaken?: BoolFieldUpdateOperationsInput | boolean
    rejectedReview?: NullableStringFieldUpdateOperationsInput | string | null
    selectionTestResult?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PreSelectionTestUpdateWithoutJobInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SelectionTestQuestion?: SelectionTestQuestionUpdateManyWithoutPreSelectionTestNestedInput
  }

  export type PreSelectionTestUncheckedUpdateWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SelectionTestQuestion?: SelectionTestQuestionUncheckedUpdateManyWithoutPreSelectionTestNestedInput
  }

  export type PreSelectionTestUncheckedUpdateManyWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutJobInput = {
    review?: StringFieldUpdateOperationsInput | string
    CultureRating?: IntFieldUpdateOperationsInput | number
    balanceRating?: IntFieldUpdateOperationsInput | number
    facilityRating?: IntFieldUpdateOperationsInput | number
    careerRating?: IntFieldUpdateOperationsInput | number
    salary?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutJobInput = {
    userId?: IntFieldUpdateOperationsInput | number
    review?: StringFieldUpdateOperationsInput | string
    CultureRating?: IntFieldUpdateOperationsInput | number
    balanceRating?: IntFieldUpdateOperationsInput | number
    facilityRating?: IntFieldUpdateOperationsInput | number
    careerRating?: IntFieldUpdateOperationsInput | number
    salary?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutJobInput = {
    userId?: IntFieldUpdateOperationsInput | number
    review?: StringFieldUpdateOperationsInput | string
    CultureRating?: IntFieldUpdateOperationsInput | number
    balanceRating?: IntFieldUpdateOperationsInput | number
    facilityRating?: IntFieldUpdateOperationsInput | number
    careerRating?: IntFieldUpdateOperationsInput | number
    salary?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewUpdateWithoutJobInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInterviewNestedInput
  }

  export type InterviewUncheckedUpdateWithoutJobInput = {
    userId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewUncheckedUpdateManyWithoutJobInput = {
    userId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateManyLocationInput = {
    id?: string
    title: string
    adminId: number
    banner?: string | null
    category: $Enums.JobCategory
    role: string
    salary?: number | null
    description: string
    endDate: Date | string
    isPublished?: boolean
    isTestActive?: boolean
    tags?: JobCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
  }

  export type UserCreateManyLocationInput = {
    id?: number
    username: string
    fullname?: string | null
    email: string
    password: string
    isVerified?: boolean
    avatar?: string
    gender?: $Enums.Gender | null
    dob?: Date | string | null
    lastEdu?: $Enums.LastEdu | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumJobCategoryFieldUpdateOperationsInput | $Enums.JobCategory
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isTestActive?: BoolFieldUpdateOperationsInput | boolean
    tags?: JobUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    admin?: AdminUpdateOneRequiredWithoutJobNestedInput
    JobApplication?: JobApplicationUpdateManyWithoutJobNestedInput
    PreSelectionTest?: PreSelectionTestUpdateManyWithoutJobNestedInput
    Review?: ReviewUpdateManyWithoutJobNestedInput
    Interview?: InterviewUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    adminId?: IntFieldUpdateOperationsInput | number
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumJobCategoryFieldUpdateOperationsInput | $Enums.JobCategory
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isTestActive?: BoolFieldUpdateOperationsInput | boolean
    tags?: JobUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    JobApplication?: JobApplicationUncheckedUpdateManyWithoutJobNestedInput
    PreSelectionTest?: PreSelectionTestUncheckedUpdateManyWithoutJobNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutJobNestedInput
    Interview?: InterviewUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    adminId?: IntFieldUpdateOperationsInput | number
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumJobCategoryFieldUpdateOperationsInput | $Enums.JobCategory
    role?: StringFieldUpdateOperationsInput | string
    salary?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isTestActive?: BoolFieldUpdateOperationsInput | boolean
    tags?: JobUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpdateWithoutLocationInput = {
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CurriculumVitae?: CurriculumVitaeUpdateManyWithoutUserNestedInput
    JobApplication?: JobApplicationUpdateManyWithoutUserNestedInput
    Review?: ReviewUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUpdateManyWithoutUserNestedInput
    UserAssessment?: UserAssessmentUpdateManyWithoutUserNestedInput
    UserSubscription?: UserSubscriptionUpdateManyWithoutUserNestedInput
    Interview?: InterviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CurriculumVitae?: CurriculumVitaeUncheckedUpdateManyWithoutUserNestedInput
    JobApplication?: JobApplicationUncheckedUpdateManyWithoutUserNestedInput
    Review?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    UserAssessment?: UserAssessmentUncheckedUpdateManyWithoutUserNestedInput
    UserSubscription?: UserSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Interview?: InterviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    avatar?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastEdu?: NullableEnumLastEduFieldUpdateOperationsInput | $Enums.LastEdu | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManySubscriptionInput = {
    id?: string
    userId: number
    amount: number
    status: $Enums.TransactionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSubscriptionCreateManySubscriptionInput = {
    userId: number
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    assessmentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUpdateWithoutSubscriptionInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assessmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserSubscriptionNestedInput
  }

  export type UserSubscriptionUncheckedUpdateWithoutSubscriptionInput = {
    userId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assessmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUncheckedUpdateManyWithoutSubscriptionInput = {
    userId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assessmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SelectionTestQuestionCreateManyPreSelectionTestInput = {
    id?: number
    question: string
    options?: SelectionTestQuestionCreateoptionsInput | string[]
    correctAnswer: number
  }

  export type SelectionTestQuestionUpdateWithoutPreSelectionTestInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: SelectionTestQuestionUpdateoptionsInput | string[]
    correctAnswer?: IntFieldUpdateOperationsInput | number
  }

  export type SelectionTestQuestionUncheckedUpdateWithoutPreSelectionTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    options?: SelectionTestQuestionUpdateoptionsInput | string[]
    correctAnswer?: IntFieldUpdateOperationsInput | number
  }

  export type SelectionTestQuestionUncheckedUpdateManyWithoutPreSelectionTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    options?: SelectionTestQuestionUpdateoptionsInput | string[]
    correctAnswer?: IntFieldUpdateOperationsInput | number
  }

  export type AssessmentQuestionCreateManyAssessmentInput = {
    id?: number
    question: string
    options?: AssessmentQuestionCreateoptionsInput | string[]
    correctAnswer: number
  }

  export type UserAssessmentCreateManyAssessmentInput = {
    id?: number
    userId: number
    score?: number
    certificateId?: number | null
    status?: $Enums.UserAssessmentStatus | null
    endTime: Date | string
  }

  export type AssessmentQuestionUpdateWithoutAssessmentInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: AssessmentQuestionUpdateoptionsInput | string[]
    correctAnswer?: IntFieldUpdateOperationsInput | number
  }

  export type AssessmentQuestionUncheckedUpdateWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    options?: AssessmentQuestionUpdateoptionsInput | string[]
    correctAnswer?: IntFieldUpdateOperationsInput | number
  }

  export type AssessmentQuestionUncheckedUpdateManyWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    options?: AssessmentQuestionUpdateoptionsInput | string[]
    correctAnswer?: IntFieldUpdateOperationsInput | number
  }

  export type UserAssessmentUpdateWithoutAssessmentInput = {
    score?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumUserAssessmentStatusFieldUpdateOperationsInput | $Enums.UserAssessmentStatus | null
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: CertificateUpdateOneWithoutUserAssessmentNestedInput
    User?: UserUpdateOneRequiredWithoutUserAssessmentNestedInput
  }

  export type UserAssessmentUncheckedUpdateWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    certificateId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumUserAssessmentStatusFieldUpdateOperationsInput | $Enums.UserAssessmentStatus | null
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAssessmentUncheckedUpdateManyWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    certificateId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumUserAssessmentStatusFieldUpdateOperationsInput | $Enums.UserAssessmentStatus | null
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAssessmentCreateManyCertificateInput = {
    id?: number
    userId: number
    assessmentId: number
    score?: number
    status?: $Enums.UserAssessmentStatus | null
    endTime: Date | string
  }

  export type UserAssessmentUpdateWithoutCertificateInput = {
    score?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumUserAssessmentStatusFieldUpdateOperationsInput | $Enums.UserAssessmentStatus | null
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutUserAssessmentNestedInput
    assessment?: AssessmentUpdateOneRequiredWithoutUserAssessmentNestedInput
  }

  export type UserAssessmentUncheckedUpdateWithoutCertificateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumUserAssessmentStatusFieldUpdateOperationsInput | $Enums.UserAssessmentStatus | null
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAssessmentUncheckedUpdateManyWithoutCertificateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumUserAssessmentStatusFieldUpdateOperationsInput | $Enums.UserAssessmentStatus | null
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}